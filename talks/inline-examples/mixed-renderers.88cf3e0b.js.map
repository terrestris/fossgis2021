{"mappings":"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","sources":["node_modules/ol/src/source/Vector.js","node_modules/ol/src/structs/RBush.js","node_modules/ol/src/source/VectorEventType.js","node_modules/ol/src/loadingstrategy.js","node_modules/ol/src/featureloader.js","node_modules/ol/src/format/FormatType.js","node_modules/ol/src/Feature.js","node_modules/ol/src/geom/LineString.js","node_modules/ol/src/geom/flat/interpolate.js","node_modules/ol/src/geom/MultiLineString.js","node_modules/ol/src/format/XMLFeature.js","node_modules/ol/src/format/Feature.js","node_modules/ol/src/xml.js","node_modules/ol/src/format/xsd.js","node_modules/ol/src/geom/GeometryCollection.js"],"sourcesContent":["/**\n * @module ol/source/Vector\n */\n\nimport Collection from '../Collection.js';\nimport CollectionEventType from '../CollectionEventType.js';\nimport Event from '../events/Event.js';\nimport EventType from '../events/EventType.js';\nimport ObjectEventType from '../ObjectEventType.js';\nimport RBush from '../structs/RBush.js';\nimport Source from './Source.js';\nimport SourceState from './State.js';\nimport VectorEventType from './VectorEventType.js';\nimport {TRUE, VOID} from '../functions.js';\nimport {all as allStrategy} from '../loadingstrategy.js';\nimport {assert} from '../asserts.js';\nimport {containsExtent, equals} from '../extent.js';\nimport {extend} from '../array.js';\nimport {getUid} from '../util.js';\nimport {getValues, isEmpty} from '../obj.js';\nimport {listen, unlistenByKey} from '../events.js';\nimport {xhr} from '../featureloader.js';\n\n/**\n * A function that takes an {@link module:ol/extent~Extent} and a resolution as arguments, and\n * returns an array of {@link module:ol/extent~Extent} with the extents to load. Usually this\n * is one of the standard {@link module:ol/loadingstrategy} strategies.\n *\n * @typedef {function(import(\"../extent.js\").Extent, number): Array<import(\"../extent.js\").Extent>} LoadingStrategy\n * @api\n */\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/source/Vector} instances are instances of this\n * type.\n * @template {import(\"../geom/Geometry.js\").default} Geometry\n */\nexport class VectorSourceEvent extends Event {\n  /**\n   * @param {string} type Type.\n   * @param {import(\"../Feature.js\").default<Geometry>} [opt_feature] Feature.\n   * @param {Array<import(\"../Feature.js\").default<Geometry>>} [opt_features] Features.\n   */\n  constructor(type, opt_feature, opt_features) {\n    super(type);\n\n    /**\n     * The added or removed feature for the `ADDFEATURE` and `REMOVEFEATURE` events, `undefined` otherwise.\n     * @type {import(\"../Feature.js\").default<Geometry>|undefined}\n     * @api\n     */\n    this.feature = opt_feature;\n\n    /**\n     * The loaded features for the `FEATURESLOADED` event, `undefined` otherwise.\n     * @type {Array<import(\"../Feature.js\").default<Geometry>>|undefined}\n     * @api\n     */\n    this.features = opt_features;\n  }\n}\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {Array<import(\"../Feature.js\").default>|Collection<import(\"../Feature.js\").default>} [features]\n * Features. If provided as {@link module:ol/Collection}, the features in the source\n * and the collection will stay in sync.\n * @property {import(\"../format/Feature.js\").default} [format] The feature format used by the XHR\n * feature loader when `url` is set. Required if `url` is set, otherwise ignored.\n * @property {import(\"../featureloader.js\").FeatureLoader} [loader]\n * The loader function used to load features, from a remote source for example.\n * If this is not set and `url` is set, the source will create and use an XHR\n * feature loader. The `'featuresloadend'` and `'featuresloaderror'` events\n * will only fire if the `success` and `failure` callbacks are used.\n *\n * Example:\n *\n * ```js\n * import {Vector} from 'ol/source';\n * import {GeoJSON} from 'ol/format';\n * import {bbox} from 'ol/loadingstrategy';\n *\n * var vectorSource = new Vector({\n *   format: new GeoJSON(),\n *   loader: function(extent, resolution, projection, success, failure) {\n *      var proj = projection.getCode();\n *      var url = 'https://ahocevar.com/geoserver/wfs?service=WFS&' +\n *          'version=1.1.0&request=GetFeature&typename=osm:water_areas&' +\n *          'outputFormat=application/json&srsname=' + proj + '&' +\n *          'bbox=' + extent.join(',') + ',' + proj;\n *      var xhr = new XMLHttpRequest();\n *      xhr.open('GET', url);\n *      var onError = function() {\n *        vectorSource.removeLoadedExtent(extent);\n *        failure();\n *      }\n *      xhr.onerror = onError;\n *      xhr.onload = function() {\n *        if (xhr.status == 200) {\n *          var features = vectorSource.getFormat().readFeatures(xhr.responseText);\n *          vectorSource.addFeatures(features);\n *          success(features);\n *        } else {\n *          onError();\n *        }\n *      }\n *      xhr.send();\n *    },\n *    strategy: bbox\n *  });\n * ```\n * @property {boolean} [overlaps=true] This source may have overlapping geometries.\n * Setting this to `false` (e.g. for sources with polygons that represent administrative\n * boundaries or TopoJSON sources) allows the renderer to optimise fill and\n * stroke operations.\n * @property {LoadingStrategy} [strategy] The loading strategy to use.\n * By default an {@link module:ol/loadingstrategy~all}\n * strategy is used, a one-off strategy which loads all features at once.\n * @property {string|import(\"../featureloader.js\").FeatureUrlFunction} [url]\n * Setting this option instructs the source to load features using an XHR loader\n * (see {@link module:ol/featureloader~xhr}). Use a `string` and an\n * {@link module:ol/loadingstrategy~all} for a one-off download of all features from\n * the given URL. Use a {@link module:ol/featureloader~FeatureUrlFunction} to generate the url with\n * other loading strategies.\n * Requires `format` to be set as well.\n * When default XHR feature loader is provided, the features will\n * be transformed from the data projection to the view projection\n * during parsing. If your remote data source does not advertise its projection\n * properly, this transformation will be incorrect. For some formats, the\n * default projection (usually EPSG:4326) can be overridden by setting the\n * dataProjection constructor option on the format.\n * Note that if a source contains non-feature data, such as a GeoJSON geometry\n * or a KML NetworkLink, these will be ignored. Use a custom loader to load these.\n * @property {boolean} [useSpatialIndex=true]\n * By default, an RTree is used as spatial index. When features are removed and\n * added frequently, and the total number of features is low, setting this to\n * `false` may improve performance.\n *\n * Note that\n * {@link module:ol/source/Vector~VectorSource#getFeaturesInExtent},\n * {@link module:ol/source/Vector~VectorSource#getClosestFeatureToCoordinate} and\n * {@link module:ol/source/Vector~VectorSource#getExtent} cannot be used when `useSpatialIndex` is\n * set to `false`, and {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent} will loop\n * through all features.\n *\n * When set to `false`, the features will be maintained in an\n * {@link module:ol/Collection}, which can be retrieved through\n * {@link module:ol/source/Vector~VectorSource#getFeaturesCollection}.\n * @property {boolean} [wrapX=true] Wrap the world horizontally. For vector editing across the\n * -180° and 180° meridians to work properly, this should be set to `false`. The\n * resulting geometry coordinates will then exceed the world bounds.\n */\n\n/**\n * @classdesc\n * Provides a source of features for vector layers. Vector features provided\n * by this source are suitable for editing. See {@link module:ol/source/VectorTile~VectorTile} for\n * vector data that is optimized for rendering.\n *\n * @fires VectorSourceEvent\n * @api\n * @template {import(\"../geom/Geometry.js\").default} Geometry\n */\nclass VectorSource extends Source {\n  /**\n   * @param {Options} [opt_options] Vector source options.\n   */\n  constructor(opt_options) {\n    const options = opt_options || {};\n\n    super({\n      attributions: options.attributions,\n      projection: undefined,\n      state: SourceState.READY,\n      wrapX: options.wrapX !== undefined ? options.wrapX : true,\n    });\n\n    /**\n     * @private\n     * @type {import(\"../featureloader.js\").FeatureLoader}\n     */\n    this.loader_ = VOID;\n\n    /**\n     * @private\n     * @type {import(\"../format/Feature.js\").default|undefined}\n     */\n    this.format_ = options.format;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.overlaps_ = options.overlaps === undefined ? true : options.overlaps;\n\n    /**\n     * @private\n     * @type {string|import(\"../featureloader.js\").FeatureUrlFunction|undefined}\n     */\n    this.url_ = options.url;\n\n    if (options.loader !== undefined) {\n      this.loader_ = options.loader;\n    } else if (this.url_ !== undefined) {\n      assert(this.format_, 7); // `format` must be set when `url` is set\n      // create a XHR feature loader for \"url\" and \"format\"\n      this.loader_ = xhr(\n        this.url_,\n        /** @type {import(\"../format/Feature.js\").default} */ (this.format_)\n      );\n    }\n\n    /**\n     * @private\n     * @type {LoadingStrategy}\n     */\n    this.strategy_ =\n      options.strategy !== undefined ? options.strategy : allStrategy;\n\n    const useSpatialIndex =\n      options.useSpatialIndex !== undefined ? options.useSpatialIndex : true;\n\n    /**\n     * @private\n     * @type {RBush<import(\"../Feature.js\").default<Geometry>>}\n     */\n    this.featuresRtree_ = useSpatialIndex ? new RBush() : null;\n\n    /**\n     * @private\n     * @type {RBush<{extent: import(\"../extent.js\").Extent}>}\n     */\n    this.loadedExtentsRtree_ = new RBush();\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.loadingExtentsCount_ = 0;\n\n    /**\n     * @private\n     * @type {!Object<string, import(\"../Feature.js\").default<Geometry>>}\n     */\n    this.nullGeometryFeatures_ = {};\n\n    /**\n     * A lookup of features by id (the return from feature.getId()).\n     * @private\n     * @type {!Object<string, import(\"../Feature.js\").default<Geometry>>}\n     */\n    this.idIndex_ = {};\n\n    /**\n     * A lookup of features by uid (using getUid(feature)).\n     * @private\n     * @type {!Object<string, import(\"../Feature.js\").default<Geometry>>}\n     */\n    this.uidIndex_ = {};\n\n    /**\n     * @private\n     * @type {Object<string, Array<import(\"../events.js\").EventsKey>>}\n     */\n    this.featureChangeKeys_ = {};\n\n    /**\n     * @private\n     * @type {Collection<import(\"../Feature.js\").default<Geometry>>}\n     */\n    this.featuresCollection_ = null;\n\n    let collection, features;\n    if (Array.isArray(options.features)) {\n      features = options.features;\n    } else if (options.features) {\n      collection = options.features;\n      features = collection.getArray();\n    }\n    if (!useSpatialIndex && collection === undefined) {\n      collection = new Collection(features);\n    }\n    if (features !== undefined) {\n      this.addFeaturesInternal(features);\n    }\n    if (collection !== undefined) {\n      this.bindFeaturesCollection_(collection);\n    }\n  }\n\n  /**\n   * Add a single feature to the source.  If you want to add a batch of features\n   * at once, call {@link module:ol/source/Vector~VectorSource#addFeatures #addFeatures()}\n   * instead. A feature will not be added to the source if feature with\n   * the same id is already there. The reason for this behavior is to avoid\n   * feature duplication when using bbox or tile loading strategies.\n   * Note: this also applies if an {@link module:ol/Collection} is used for features,\n   * meaning that if a feature with a duplicate id is added in the collection, it will\n   * be removed from it right away.\n   * @param {import(\"../Feature.js\").default<Geometry>} feature Feature to add.\n   * @api\n   */\n  addFeature(feature) {\n    this.addFeatureInternal(feature);\n    this.changed();\n  }\n\n  /**\n   * Add a feature without firing a `change` event.\n   * @param {import(\"../Feature.js\").default<Geometry>} feature Feature.\n   * @protected\n   */\n  addFeatureInternal(feature) {\n    const featureKey = getUid(feature);\n\n    if (!this.addToIndex_(featureKey, feature)) {\n      if (this.featuresCollection_) {\n        this.featuresCollection_.remove(feature);\n      }\n      return;\n    }\n\n    this.setupChangeEvents_(featureKey, feature);\n\n    const geometry = feature.getGeometry();\n    if (geometry) {\n      const extent = geometry.getExtent();\n      if (this.featuresRtree_) {\n        this.featuresRtree_.insert(extent, feature);\n      }\n    } else {\n      this.nullGeometryFeatures_[featureKey] = feature;\n    }\n\n    this.dispatchEvent(\n      new VectorSourceEvent(VectorEventType.ADDFEATURE, feature)\n    );\n  }\n\n  /**\n   * @param {string} featureKey Unique identifier for the feature.\n   * @param {import(\"../Feature.js\").default<Geometry>} feature The feature.\n   * @private\n   */\n  setupChangeEvents_(featureKey, feature) {\n    this.featureChangeKeys_[featureKey] = [\n      listen(feature, EventType.CHANGE, this.handleFeatureChange_, this),\n      listen(\n        feature,\n        ObjectEventType.PROPERTYCHANGE,\n        this.handleFeatureChange_,\n        this\n      ),\n    ];\n  }\n\n  /**\n   * @param {string} featureKey Unique identifier for the feature.\n   * @param {import(\"../Feature.js\").default<Geometry>} feature The feature.\n   * @return {boolean} The feature is \"valid\", in the sense that it is also a\n   *     candidate for insertion into the Rtree.\n   * @private\n   */\n  addToIndex_(featureKey, feature) {\n    let valid = true;\n    const id = feature.getId();\n    if (id !== undefined) {\n      if (!(id.toString() in this.idIndex_)) {\n        this.idIndex_[id.toString()] = feature;\n      } else {\n        valid = false;\n      }\n    }\n    if (valid) {\n      assert(!(featureKey in this.uidIndex_), 30); // The passed `feature` was already added to the source\n      this.uidIndex_[featureKey] = feature;\n    }\n    return valid;\n  }\n\n  /**\n   * Add a batch of features to the source.\n   * @param {Array<import(\"../Feature.js\").default<Geometry>>} features Features to add.\n   * @api\n   */\n  addFeatures(features) {\n    this.addFeaturesInternal(features);\n    this.changed();\n  }\n\n  /**\n   * Add features without firing a `change` event.\n   * @param {Array<import(\"../Feature.js\").default<Geometry>>} features Features.\n   * @protected\n   */\n  addFeaturesInternal(features) {\n    const extents = [];\n    const newFeatures = [];\n    const geometryFeatures = [];\n\n    for (let i = 0, length = features.length; i < length; i++) {\n      const feature = features[i];\n      const featureKey = getUid(feature);\n      if (this.addToIndex_(featureKey, feature)) {\n        newFeatures.push(feature);\n      }\n    }\n\n    for (let i = 0, length = newFeatures.length; i < length; i++) {\n      const feature = newFeatures[i];\n      const featureKey = getUid(feature);\n      this.setupChangeEvents_(featureKey, feature);\n\n      const geometry = feature.getGeometry();\n      if (geometry) {\n        const extent = geometry.getExtent();\n        extents.push(extent);\n        geometryFeatures.push(feature);\n      } else {\n        this.nullGeometryFeatures_[featureKey] = feature;\n      }\n    }\n    if (this.featuresRtree_) {\n      this.featuresRtree_.load(extents, geometryFeatures);\n    }\n\n    for (let i = 0, length = newFeatures.length; i < length; i++) {\n      this.dispatchEvent(\n        new VectorSourceEvent(VectorEventType.ADDFEATURE, newFeatures[i])\n      );\n    }\n  }\n\n  /**\n   * @param {!Collection<import(\"../Feature.js\").default<Geometry>>} collection Collection.\n   * @private\n   */\n  bindFeaturesCollection_(collection) {\n    let modifyingCollection = false;\n    this.addEventListener(\n      VectorEventType.ADDFEATURE,\n      /**\n       * @param {VectorSourceEvent<Geometry>} evt The vector source event\n       */\n      function (evt) {\n        if (!modifyingCollection) {\n          modifyingCollection = true;\n          collection.push(evt.feature);\n          modifyingCollection = false;\n        }\n      }\n    );\n    this.addEventListener(\n      VectorEventType.REMOVEFEATURE,\n      /**\n       * @param {VectorSourceEvent<Geometry>} evt The vector source event\n       */\n      function (evt) {\n        if (!modifyingCollection) {\n          modifyingCollection = true;\n          collection.remove(evt.feature);\n          modifyingCollection = false;\n        }\n      }\n    );\n    collection.addEventListener(\n      CollectionEventType.ADD,\n      /**\n       * @param {import(\"../Collection.js\").CollectionEvent} evt The collection event\n       */\n      function (evt) {\n        if (!modifyingCollection) {\n          modifyingCollection = true;\n          this.addFeature(\n            /** @type {import(\"../Feature.js\").default<Geometry>} */ (evt.element)\n          );\n          modifyingCollection = false;\n        }\n      }.bind(this)\n    );\n    collection.addEventListener(\n      CollectionEventType.REMOVE,\n      /**\n       * @param {import(\"../Collection.js\").CollectionEvent} evt The collection event\n       */\n      function (evt) {\n        if (!modifyingCollection) {\n          modifyingCollection = true;\n          this.removeFeature(\n            /** @type {import(\"../Feature.js\").default<Geometry>} */ (evt.element)\n          );\n          modifyingCollection = false;\n        }\n      }.bind(this)\n    );\n    this.featuresCollection_ = collection;\n  }\n\n  /**\n   * Remove all features from the source.\n   * @param {boolean} [opt_fast] Skip dispatching of {@link module:ol/source/Vector.VectorSourceEvent#removefeature} events.\n   * @api\n   */\n  clear(opt_fast) {\n    if (opt_fast) {\n      for (const featureId in this.featureChangeKeys_) {\n        const keys = this.featureChangeKeys_[featureId];\n        keys.forEach(unlistenByKey);\n      }\n      if (!this.featuresCollection_) {\n        this.featureChangeKeys_ = {};\n        this.idIndex_ = {};\n        this.uidIndex_ = {};\n      }\n    } else {\n      if (this.featuresRtree_) {\n        this.featuresRtree_.forEach(this.removeFeatureInternal.bind(this));\n        for (const id in this.nullGeometryFeatures_) {\n          this.removeFeatureInternal(this.nullGeometryFeatures_[id]);\n        }\n      }\n    }\n    if (this.featuresCollection_) {\n      this.featuresCollection_.clear();\n    }\n\n    if (this.featuresRtree_) {\n      this.featuresRtree_.clear();\n    }\n    this.nullGeometryFeatures_ = {};\n\n    const clearEvent = new VectorSourceEvent(VectorEventType.CLEAR);\n    this.dispatchEvent(clearEvent);\n    this.changed();\n  }\n\n  /**\n   * Iterate through all features on the source, calling the provided callback\n   * with each one.  If the callback returns any \"truthy\" value, iteration will\n   * stop and the function will return the same value.\n   * Note: this function only iterate through the feature that have a defined geometry.\n   *\n   * @param {function(import(\"../Feature.js\").default<Geometry>): T} callback Called with each feature\n   *     on the source.  Return a truthy value to stop iteration.\n   * @return {T|undefined} The return value from the last call to the callback.\n   * @template T\n   * @api\n   */\n  forEachFeature(callback) {\n    if (this.featuresRtree_) {\n      return this.featuresRtree_.forEach(callback);\n    } else if (this.featuresCollection_) {\n      this.featuresCollection_.forEach(callback);\n    }\n  }\n\n  /**\n   * Iterate through all features whose geometries contain the provided\n   * coordinate, calling the callback with each feature.  If the callback returns\n   * a \"truthy\" value, iteration will stop and the function will return the same\n   * value.\n   *\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {function(import(\"../Feature.js\").default<Geometry>): T} callback Called with each feature\n   *     whose goemetry contains the provided coordinate.\n   * @return {T|undefined} The return value from the last call to the callback.\n   * @template T\n   */\n  forEachFeatureAtCoordinateDirect(coordinate, callback) {\n    const extent = [coordinate[0], coordinate[1], coordinate[0], coordinate[1]];\n    return this.forEachFeatureInExtent(extent, function (feature) {\n      const geometry = feature.getGeometry();\n      if (geometry.intersectsCoordinate(coordinate)) {\n        return callback(feature);\n      } else {\n        return undefined;\n      }\n    });\n  }\n\n  /**\n   * Iterate through all features whose bounding box intersects the provided\n   * extent (note that the feature's geometry may not intersect the extent),\n   * calling the callback with each feature.  If the callback returns a \"truthy\"\n   * value, iteration will stop and the function will return the same value.\n   *\n   * If you are interested in features whose geometry intersects an extent, call\n   * the {@link module:ol/source/Vector~VectorSource#forEachFeatureIntersectingExtent #forEachFeatureIntersectingExtent()} method instead.\n   *\n   * When `useSpatialIndex` is set to false, this method will loop through all\n   * features, equivalent to {@link module:ol/source/Vector~VectorSource#forEachFeature #forEachFeature()}.\n   *\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {function(import(\"../Feature.js\").default<Geometry>): T} callback Called with each feature\n   *     whose bounding box intersects the provided extent.\n   * @return {T|undefined} The return value from the last call to the callback.\n   * @template T\n   * @api\n   */\n  forEachFeatureInExtent(extent, callback) {\n    if (this.featuresRtree_) {\n      return this.featuresRtree_.forEachInExtent(extent, callback);\n    } else if (this.featuresCollection_) {\n      this.featuresCollection_.forEach(callback);\n    }\n  }\n\n  /**\n   * Iterate through all features whose geometry intersects the provided extent,\n   * calling the callback with each feature.  If the callback returns a \"truthy\"\n   * value, iteration will stop and the function will return the same value.\n   *\n   * If you only want to test for bounding box intersection, call the\n   * {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent #forEachFeatureInExtent()} method instead.\n   *\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {function(import(\"../Feature.js\").default<Geometry>): T} callback Called with each feature\n   *     whose geometry intersects the provided extent.\n   * @return {T|undefined} The return value from the last call to the callback.\n   * @template T\n   * @api\n   */\n  forEachFeatureIntersectingExtent(extent, callback) {\n    return this.forEachFeatureInExtent(\n      extent,\n      /**\n       * @param {import(\"../Feature.js\").default<Geometry>} feature Feature.\n       * @return {T|undefined} The return value from the last call to the callback.\n       */\n      function (feature) {\n        const geometry = feature.getGeometry();\n        if (geometry.intersectsExtent(extent)) {\n          const result = callback(feature);\n          if (result) {\n            return result;\n          }\n        }\n      }\n    );\n  }\n\n  /**\n   * Get the features collection associated with this source. Will be `null`\n   * unless the source was configured with `useSpatialIndex` set to `false`, or\n   * with an {@link module:ol/Collection} as `features`.\n   * @return {Collection<import(\"../Feature.js\").default<Geometry>>} The collection of features.\n   * @api\n   */\n  getFeaturesCollection() {\n    return this.featuresCollection_;\n  }\n\n  /**\n   * Get a snapshot of the features currently on the source in random order. The returned array\n   * is a copy, the features are references to the features in the source.\n   * @return {Array<import(\"../Feature.js\").default<Geometry>>} Features.\n   * @api\n   */\n  getFeatures() {\n    let features;\n    if (this.featuresCollection_) {\n      features = this.featuresCollection_.getArray().slice(0);\n    } else if (this.featuresRtree_) {\n      features = this.featuresRtree_.getAll();\n      if (!isEmpty(this.nullGeometryFeatures_)) {\n        extend(features, getValues(this.nullGeometryFeatures_));\n      }\n    }\n    return /** @type {Array<import(\"../Feature.js\").default<Geometry>>} */ (features);\n  }\n\n  /**\n   * Get all features whose geometry intersects the provided coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @return {Array<import(\"../Feature.js\").default<Geometry>>} Features.\n   * @api\n   */\n  getFeaturesAtCoordinate(coordinate) {\n    const features = [];\n    this.forEachFeatureAtCoordinateDirect(coordinate, function (feature) {\n      features.push(feature);\n    });\n    return features;\n  }\n\n  /**\n   * Get all features whose bounding box intersects the provided extent.  Note that this returns an array of\n   * all features intersecting the given extent in random order (so it may include\n   * features whose geometries do not intersect the extent).\n   *\n   * When `useSpatialIndex` is set to false, this method will return all\n   * features.\n   *\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {Array<import(\"../Feature.js\").default<Geometry>>} Features.\n   * @api\n   */\n  getFeaturesInExtent(extent) {\n    if (this.featuresRtree_) {\n      return this.featuresRtree_.getInExtent(extent);\n    } else if (this.featuresCollection_) {\n      return this.featuresCollection_.getArray().slice(0);\n    } else {\n      return [];\n    }\n  }\n\n  /**\n   * Get the closest feature to the provided coordinate.\n   *\n   * This method is not available when the source is configured with\n   * `useSpatialIndex` set to `false`.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {function(import(\"../Feature.js\").default<Geometry>):boolean} [opt_filter] Feature filter function.\n   *     The filter function will receive one argument, the {@link module:ol/Feature feature}\n   *     and it should return a boolean value. By default, no filtering is made.\n   * @return {import(\"../Feature.js\").default<Geometry>} Closest feature.\n   * @api\n   */\n  getClosestFeatureToCoordinate(coordinate, opt_filter) {\n    // Find the closest feature using branch and bound.  We start searching an\n    // infinite extent, and find the distance from the first feature found.  This\n    // becomes the closest feature.  We then compute a smaller extent which any\n    // closer feature must intersect.  We continue searching with this smaller\n    // extent, trying to find a closer feature.  Every time we find a closer\n    // feature, we update the extent being searched so that any even closer\n    // feature must intersect it.  We continue until we run out of features.\n    const x = coordinate[0];\n    const y = coordinate[1];\n    let closestFeature = null;\n    const closestPoint = [NaN, NaN];\n    let minSquaredDistance = Infinity;\n    const extent = [-Infinity, -Infinity, Infinity, Infinity];\n    const filter = opt_filter ? opt_filter : TRUE;\n    this.featuresRtree_.forEachInExtent(\n      extent,\n      /**\n       * @param {import(\"../Feature.js\").default<Geometry>} feature Feature.\n       */\n      function (feature) {\n        if (filter(feature)) {\n          const geometry = feature.getGeometry();\n          const previousMinSquaredDistance = minSquaredDistance;\n          minSquaredDistance = geometry.closestPointXY(\n            x,\n            y,\n            closestPoint,\n            minSquaredDistance\n          );\n          if (minSquaredDistance < previousMinSquaredDistance) {\n            closestFeature = feature;\n            // This is sneaky.  Reduce the extent that it is currently being\n            // searched while the R-Tree traversal using this same extent object\n            // is still in progress.  This is safe because the new extent is\n            // strictly contained by the old extent.\n            const minDistance = Math.sqrt(minSquaredDistance);\n            extent[0] = x - minDistance;\n            extent[1] = y - minDistance;\n            extent[2] = x + minDistance;\n            extent[3] = y + minDistance;\n          }\n        }\n      }\n    );\n    return closestFeature;\n  }\n\n  /**\n   * Get the extent of the features currently in the source.\n   *\n   * This method is not available when the source is configured with\n   * `useSpatialIndex` set to `false`.\n   * @param {import(\"../extent.js\").Extent} [opt_extent] Destination extent. If provided, no new extent\n   *     will be created. Instead, that extent's coordinates will be overwritten.\n   * @return {import(\"../extent.js\").Extent} Extent.\n   * @api\n   */\n  getExtent(opt_extent) {\n    return this.featuresRtree_.getExtent(opt_extent);\n  }\n\n  /**\n   * Get a feature by its identifier (the value returned by feature.getId()).\n   * Note that the index treats string and numeric identifiers as the same.  So\n   * `source.getFeatureById(2)` will return a feature with id `'2'` or `2`.\n   *\n   * @param {string|number} id Feature identifier.\n   * @return {import(\"../Feature.js\").default<Geometry>} The feature (or `null` if not found).\n   * @api\n   */\n  getFeatureById(id) {\n    const feature = this.idIndex_[id.toString()];\n    return feature !== undefined ? feature : null;\n  }\n\n  /**\n   * Get a feature by its internal unique identifier (using `getUid`).\n   *\n   * @param {string} uid Feature identifier.\n   * @return {import(\"../Feature.js\").default<Geometry>} The feature (or `null` if not found).\n   */\n  getFeatureByUid(uid) {\n    const feature = this.uidIndex_[uid];\n    return feature !== undefined ? feature : null;\n  }\n\n  /**\n   * Get the format associated with this source.\n   *\n   * @return {import(\"../format/Feature.js\").default|undefined} The feature format.\n   * @api\n   */\n  getFormat() {\n    return this.format_;\n  }\n\n  /**\n   * @return {boolean} The source can have overlapping geometries.\n   */\n  getOverlaps() {\n    return this.overlaps_;\n  }\n\n  /**\n   * Get the url associated with this source.\n   *\n   * @return {string|import(\"../featureloader.js\").FeatureUrlFunction|undefined} The url.\n   * @api\n   */\n  getUrl() {\n    return this.url_;\n  }\n\n  /**\n   * @param {Event} event Event.\n   * @private\n   */\n  handleFeatureChange_(event) {\n    const feature = /** @type {import(\"../Feature.js\").default<Geometry>} */ (event.target);\n    const featureKey = getUid(feature);\n    const geometry = feature.getGeometry();\n    if (!geometry) {\n      if (!(featureKey in this.nullGeometryFeatures_)) {\n        if (this.featuresRtree_) {\n          this.featuresRtree_.remove(feature);\n        }\n        this.nullGeometryFeatures_[featureKey] = feature;\n      }\n    } else {\n      const extent = geometry.getExtent();\n      if (featureKey in this.nullGeometryFeatures_) {\n        delete this.nullGeometryFeatures_[featureKey];\n        if (this.featuresRtree_) {\n          this.featuresRtree_.insert(extent, feature);\n        }\n      } else {\n        if (this.featuresRtree_) {\n          this.featuresRtree_.update(extent, feature);\n        }\n      }\n    }\n    const id = feature.getId();\n    if (id !== undefined) {\n      const sid = id.toString();\n      if (this.idIndex_[sid] !== feature) {\n        this.removeFromIdIndex_(feature);\n        this.idIndex_[sid] = feature;\n      }\n    } else {\n      this.removeFromIdIndex_(feature);\n      this.uidIndex_[featureKey] = feature;\n    }\n    this.changed();\n    this.dispatchEvent(\n      new VectorSourceEvent(VectorEventType.CHANGEFEATURE, feature)\n    );\n  }\n\n  /**\n   * Returns true if the feature is contained within the source.\n   * @param {import(\"../Feature.js\").default<Geometry>} feature Feature.\n   * @return {boolean} Has feature.\n   * @api\n   */\n  hasFeature(feature) {\n    const id = feature.getId();\n    if (id !== undefined) {\n      return id in this.idIndex_;\n    } else {\n      return getUid(feature) in this.uidIndex_;\n    }\n  }\n\n  /**\n   * @return {boolean} Is empty.\n   */\n  isEmpty() {\n    return this.featuresRtree_.isEmpty() && isEmpty(this.nullGeometryFeatures_);\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   */\n  loadFeatures(extent, resolution, projection) {\n    const loadedExtentsRtree = this.loadedExtentsRtree_;\n    const extentsToLoad = this.strategy_(extent, resolution);\n    for (let i = 0, ii = extentsToLoad.length; i < ii; ++i) {\n      const extentToLoad = extentsToLoad[i];\n      const alreadyLoaded = loadedExtentsRtree.forEachInExtent(\n        extentToLoad,\n        /**\n         * @param {{extent: import(\"../extent.js\").Extent}} object Object.\n         * @return {boolean} Contains.\n         */\n        function (object) {\n          return containsExtent(object.extent, extentToLoad);\n        }\n      );\n      if (!alreadyLoaded) {\n        ++this.loadingExtentsCount_;\n        this.dispatchEvent(\n          new VectorSourceEvent(VectorEventType.FEATURESLOADSTART)\n        );\n        this.loader_.call(\n          this,\n          extentToLoad,\n          resolution,\n          projection,\n          function (features) {\n            --this.loadingExtentsCount_;\n            this.dispatchEvent(\n              new VectorSourceEvent(\n                VectorEventType.FEATURESLOADEND,\n                undefined,\n                features\n              )\n            );\n          }.bind(this),\n          function () {\n            --this.loadingExtentsCount_;\n            this.dispatchEvent(\n              new VectorSourceEvent(VectorEventType.FEATURESLOADERROR)\n            );\n          }.bind(this)\n        );\n        loadedExtentsRtree.insert(extentToLoad, {extent: extentToLoad.slice()});\n      }\n    }\n    this.loading =\n      this.loader_ === VOID ? false : this.loadingExtentsCount_ > 0;\n  }\n\n  refresh() {\n    this.clear(true);\n    this.loadedExtentsRtree_.clear();\n    super.refresh();\n  }\n\n  /**\n   * Remove an extent from the list of loaded extents.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @api\n   */\n  removeLoadedExtent(extent) {\n    const loadedExtentsRtree = this.loadedExtentsRtree_;\n    let obj;\n    loadedExtentsRtree.forEachInExtent(extent, function (object) {\n      if (equals(object.extent, extent)) {\n        obj = object;\n        return true;\n      }\n    });\n    if (obj) {\n      loadedExtentsRtree.remove(obj);\n    }\n  }\n\n  /**\n   * Remove a single feature from the source.  If you want to remove all features\n   * at once, use the {@link module:ol/source/Vector~VectorSource#clear #clear()} method\n   * instead.\n   * @param {import(\"../Feature.js\").default<Geometry>} feature Feature to remove.\n   * @api\n   */\n  removeFeature(feature) {\n    const featureKey = getUid(feature);\n    if (featureKey in this.nullGeometryFeatures_) {\n      delete this.nullGeometryFeatures_[featureKey];\n    } else {\n      if (this.featuresRtree_) {\n        this.featuresRtree_.remove(feature);\n      }\n    }\n    this.removeFeatureInternal(feature);\n    this.changed();\n  }\n\n  /**\n   * Remove feature without firing a `change` event.\n   * @param {import(\"../Feature.js\").default<Geometry>} feature Feature.\n   * @protected\n   */\n  removeFeatureInternal(feature) {\n    const featureKey = getUid(feature);\n    this.featureChangeKeys_[featureKey].forEach(unlistenByKey);\n    delete this.featureChangeKeys_[featureKey];\n    const id = feature.getId();\n    if (id !== undefined) {\n      delete this.idIndex_[id.toString()];\n    }\n    delete this.uidIndex_[featureKey];\n    this.dispatchEvent(\n      new VectorSourceEvent(VectorEventType.REMOVEFEATURE, feature)\n    );\n  }\n\n  /**\n   * Remove a feature from the id index.  Called internally when the feature id\n   * may have changed.\n   * @param {import(\"../Feature.js\").default<Geometry>} feature The feature.\n   * @return {boolean} Removed the feature from the index.\n   * @private\n   */\n  removeFromIdIndex_(feature) {\n    let removed = false;\n    for (const id in this.idIndex_) {\n      if (this.idIndex_[id] === feature) {\n        delete this.idIndex_[id];\n        removed = true;\n        break;\n      }\n    }\n    return removed;\n  }\n\n  /**\n   * Set the new loader of the source. The next render cycle will use the\n   * new loader.\n   * @param {import(\"../featureloader.js\").FeatureLoader} loader The loader to set.\n   * @api\n   */\n  setLoader(loader) {\n    this.loader_ = loader;\n  }\n\n  /**\n   * Points the source to a new url. The next render cycle will use the new url.\n   * @param {string|import(\"../featureloader.js\").FeatureUrlFunction} url Url.\n   * @api\n   */\n  setUrl(url) {\n    assert(this.format_, 7); // `format` must be set when `url` is set\n    this.setLoader(xhr(url, this.format_));\n  }\n}\n\nexport default VectorSource;\n","/**\n * @module ol/structs/RBush\n */\nimport RBush_ from 'rbush';\nimport {createOrUpdate, equals} from '../extent.js';\nimport {getUid} from '../util.js';\nimport {isEmpty} from '../obj.js';\n\n/**\n * @typedef {Object} Entry\n * @property {number} minX MinX.\n * @property {number} minY MinY.\n * @property {number} maxX MaxX.\n * @property {number} maxY MaxY.\n * @property {Object} [value] Value.\n */\n\n/**\n * @classdesc\n * Wrapper around the RBush by Vladimir Agafonkin.\n * See https://github.com/mourner/rbush.\n *\n * @template T\n */\nclass RBush {\n  /**\n   * @param {number} [opt_maxEntries] Max entries.\n   */\n  constructor(opt_maxEntries) {\n    /**\n     * @private\n     */\n    this.rbush_ = new RBush_(opt_maxEntries);\n\n    /**\n     * A mapping between the objects added to this rbush wrapper\n     * and the objects that are actually added to the internal rbush.\n     * @private\n     * @type {Object<string, Entry>}\n     */\n    this.items_ = {};\n  }\n\n  /**\n   * Insert a value into the RBush.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {T} value Value.\n   */\n  insert(extent, value) {\n    /** @type {Entry} */\n    const item = {\n      minX: extent[0],\n      minY: extent[1],\n      maxX: extent[2],\n      maxY: extent[3],\n      value: value,\n    };\n\n    this.rbush_.insert(item);\n    this.items_[getUid(value)] = item;\n  }\n\n  /**\n   * Bulk-insert values into the RBush.\n   * @param {Array<import(\"../extent.js\").Extent>} extents Extents.\n   * @param {Array<T>} values Values.\n   */\n  load(extents, values) {\n    const items = new Array(values.length);\n    for (let i = 0, l = values.length; i < l; i++) {\n      const extent = extents[i];\n      const value = values[i];\n\n      /** @type {Entry} */\n      const item = {\n        minX: extent[0],\n        minY: extent[1],\n        maxX: extent[2],\n        maxY: extent[3],\n        value: value,\n      };\n      items[i] = item;\n      this.items_[getUid(value)] = item;\n    }\n    this.rbush_.load(items);\n  }\n\n  /**\n   * Remove a value from the RBush.\n   * @param {T} value Value.\n   * @return {boolean} Removed.\n   */\n  remove(value) {\n    const uid = getUid(value);\n\n    // get the object in which the value was wrapped when adding to the\n    // internal rbush. then use that object to do the removal.\n    const item = this.items_[uid];\n    delete this.items_[uid];\n    return this.rbush_.remove(item) !== null;\n  }\n\n  /**\n   * Update the extent of a value in the RBush.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {T} value Value.\n   */\n  update(extent, value) {\n    const item = this.items_[getUid(value)];\n    const bbox = [item.minX, item.minY, item.maxX, item.maxY];\n    if (!equals(bbox, extent)) {\n      this.remove(value);\n      this.insert(extent, value);\n    }\n  }\n\n  /**\n   * Return all values in the RBush.\n   * @return {Array<T>} All.\n   */\n  getAll() {\n    const items = this.rbush_.all();\n    return items.map(function (item) {\n      return item.value;\n    });\n  }\n\n  /**\n   * Return all values in the given extent.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {Array<T>} All in extent.\n   */\n  getInExtent(extent) {\n    /** @type {Entry} */\n    const bbox = {\n      minX: extent[0],\n      minY: extent[1],\n      maxX: extent[2],\n      maxY: extent[3],\n    };\n    const items = this.rbush_.search(bbox);\n    return items.map(function (item) {\n      return item.value;\n    });\n  }\n\n  /**\n   * Calls a callback function with each value in the tree.\n   * If the callback returns a truthy value, this value is returned without\n   * checking the rest of the tree.\n   * @param {function(T): *} callback Callback.\n   * @return {*} Callback return value.\n   */\n  forEach(callback) {\n    return this.forEach_(this.getAll(), callback);\n  }\n\n  /**\n   * Calls a callback function with each value in the provided extent.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {function(T): *} callback Callback.\n   * @return {*} Callback return value.\n   */\n  forEachInExtent(extent, callback) {\n    return this.forEach_(this.getInExtent(extent), callback);\n  }\n\n  /**\n   * @param {Array<T>} values Values.\n   * @param {function(T): *} callback Callback.\n   * @private\n   * @return {*} Callback return value.\n   */\n  forEach_(values, callback) {\n    let result;\n    for (let i = 0, l = values.length; i < l; i++) {\n      result = callback(values[i]);\n      if (result) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * @return {boolean} Is empty.\n   */\n  isEmpty() {\n    return isEmpty(this.items_);\n  }\n\n  /**\n   * Remove all values from the RBush.\n   */\n  clear() {\n    this.rbush_.clear();\n    this.items_ = {};\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} [opt_extent] Extent.\n   * @return {import(\"../extent.js\").Extent} Extent.\n   */\n  getExtent(opt_extent) {\n    const data = this.rbush_.toJSON();\n    return createOrUpdate(\n      data.minX,\n      data.minY,\n      data.maxX,\n      data.maxY,\n      opt_extent\n    );\n  }\n\n  /**\n   * @param {RBush} rbush R-Tree.\n   */\n  concat(rbush) {\n    this.rbush_.load(rbush.rbush_.all());\n    for (const i in rbush.items_) {\n      this.items_[i] = rbush.items_[i];\n    }\n  }\n}\n\nexport default RBush;\n","/**\n * @module ol/source/VectorEventType\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  /**\n   * Triggered when a feature is added to the source.\n   * @event module:ol/source/Vector.VectorSourceEvent#addfeature\n   * @api\n   */\n  ADDFEATURE: 'addfeature',\n\n  /**\n   * Triggered when a feature is updated.\n   * @event module:ol/source/Vector.VectorSourceEvent#changefeature\n   * @api\n   */\n  CHANGEFEATURE: 'changefeature',\n\n  /**\n   * Triggered when the clear method is called on the source.\n   * @event module:ol/source/Vector.VectorSourceEvent#clear\n   * @api\n   */\n  CLEAR: 'clear',\n\n  /**\n   * Triggered when a feature is removed from the source.\n   * See {@link module:ol/source/Vector#clear source.clear()} for exceptions.\n   * @event module:ol/source/Vector.VectorSourceEvent#removefeature\n   * @api\n   */\n  REMOVEFEATURE: 'removefeature',\n\n  /**\n   * Triggered when features starts loading.\n   * @event module:ol/source/Vector.VectorSourceEvent#featuresloadstart\n   * @api\n   */\n  FEATURESLOADSTART: 'featuresloadstart',\n\n  /**\n   * Triggered when features finishes loading.\n   * @event module:ol/source/Vector.VectorSourceEvent#featuresloadend\n   * @api\n   */\n  FEATURESLOADEND: 'featuresloadend',\n\n  /**\n   * Triggered if feature loading results in an error.\n   * @event module:ol/source/Vector.VectorSourceEvent#featuresloaderror\n   * @api\n   */\n  FEATURESLOADERROR: 'featuresloaderror',\n};\n","/**\n * @module ol/loadingstrategy\n */\n\n/**\n * Strategy function for loading all features with a single request.\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number} resolution Resolution.\n * @return {Array<import(\"./extent.js\").Extent>} Extents.\n * @api\n */\nexport function all(extent, resolution) {\n  return [[-Infinity, -Infinity, Infinity, Infinity]];\n}\n\n/**\n * Strategy function for loading features based on the view's extent and\n * resolution.\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number} resolution Resolution.\n * @return {Array<import(\"./extent.js\").Extent>} Extents.\n * @api\n */\nexport function bbox(extent, resolution) {\n  return [extent];\n}\n\n/**\n * Creates a strategy function for loading features based on a tile grid.\n * @param {import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n * @return {function(import(\"./extent.js\").Extent, number): Array<import(\"./extent.js\").Extent>} Loading strategy.\n * @api\n */\nexport function tile(tileGrid) {\n  return (\n    /**\n     * @param {import(\"./extent.js\").Extent} extent Extent.\n     * @param {number} resolution Resolution.\n     * @return {Array<import(\"./extent.js\").Extent>} Extents.\n     */\n    function (extent, resolution) {\n      const z = tileGrid.getZForResolution(resolution);\n      const tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);\n      /** @type {Array<import(\"./extent.js\").Extent>} */\n      const extents = [];\n      /** @type {import(\"./tilecoord.js\").TileCoord} */\n      const tileCoord = [z, 0, 0];\n      for (\n        tileCoord[1] = tileRange.minX;\n        tileCoord[1] <= tileRange.maxX;\n        ++tileCoord[1]\n      ) {\n        for (\n          tileCoord[2] = tileRange.minY;\n          tileCoord[2] <= tileRange.maxY;\n          ++tileCoord[2]\n        ) {\n          extents.push(tileGrid.getTileCoordExtent(tileCoord));\n        }\n      }\n      return extents;\n    }\n  );\n}\n","/**\n * @module ol/featureloader\n */\nimport FormatType from './format/FormatType.js';\nimport {VOID} from './functions.js';\n\n/**\n *\n * @type {boolean}\n * @private\n */\nlet withCredentials = false;\n\n/**\n * {@link module:ol/source/Vector} sources use a function of this type to\n * load features.\n *\n * This function takes up to 5 arguments. These are an {@link module:ol/extent~Extent} representing\n * the area to be loaded, a `{number}` representing the resolution (map units per pixel), an\n * {@link module:ol/proj/Projection} for the projection, an optional success callback that should get\n * the loaded features passed as an argument and an optional failure callback with no arguments. If\n * the callbacks are not used, the corresponding vector source will not fire `'featuresloadend'` and\n * `'featuresloaderror'` events. `this` within the function is bound to the\n * {@link module:ol/source/Vector} it's called from.\n *\n * The function is responsible for loading the features and adding them to the\n * source.\n * @typedef {function(this:(import(\"./source/Vector\").default|import(\"./VectorTile.js\").default),\n *           import(\"./extent.js\").Extent,\n *           number,\n *           import(\"./proj/Projection.js\").default,\n *           function(Array<import(\"./Feature.js\").default>): void=,\n *           function(): void=): void} FeatureLoader\n * @api\n */\n\n/**\n * {@link module:ol/source/Vector} sources use a function of this type to\n * get the url to load features from.\n *\n * This function takes an {@link module:ol/extent~Extent} representing the area\n * to be loaded, a `{number}` representing the resolution (map units per pixel)\n * and an {@link module:ol/proj/Projection} for the projection  as\n * arguments and returns a `{string}` representing the URL.\n * @typedef {function(import(\"./extent.js\").Extent, number, import(\"./proj/Projection.js\").default): string} FeatureUrlFunction\n * @api\n */\n\n/**\n * @param {string|FeatureUrlFunction} url Feature URL service.\n * @param {import(\"./format/Feature.js\").default} format Feature format.\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number} resolution Resolution.\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @param {function(Array<import(\"./Feature.js\").default>, import(\"./proj/Projection.js\").default): void} success Success\n *      Function called with the loaded features and optionally with the data projection.\n * @param {function(): void} failure Failure\n *      Function called when loading failed.\n */\nexport function loadFeaturesXhr(\n  url,\n  format,\n  extent,\n  resolution,\n  projection,\n  success,\n  failure\n) {\n  const xhr = new XMLHttpRequest();\n  xhr.open(\n    'GET',\n    typeof url === 'function' ? url(extent, resolution, projection) : url,\n    true\n  );\n  if (format.getType() == FormatType.ARRAY_BUFFER) {\n    xhr.responseType = 'arraybuffer';\n  }\n  xhr.withCredentials = withCredentials;\n  /**\n   * @param {Event} event Event.\n   * @private\n   */\n  xhr.onload = function (event) {\n    // status will be 0 for file:// urls\n    if (!xhr.status || (xhr.status >= 200 && xhr.status < 300)) {\n      const type = format.getType();\n      /** @type {Document|Node|Object|string|undefined} */\n      let source;\n      if (type == FormatType.JSON || type == FormatType.TEXT) {\n        source = xhr.responseText;\n      } else if (type == FormatType.XML) {\n        source = xhr.responseXML;\n        if (!source) {\n          source = new DOMParser().parseFromString(\n            xhr.responseText,\n            'application/xml'\n          );\n        }\n      } else if (type == FormatType.ARRAY_BUFFER) {\n        source = /** @type {ArrayBuffer} */ (xhr.response);\n      }\n      if (source) {\n        success(\n          /** @type {Array<import(\"./Feature.js\").default>} */\n          (format.readFeatures(source, {\n            extent: extent,\n            featureProjection: projection,\n          })),\n          format.readProjection(source)\n        );\n      } else {\n        failure();\n      }\n    } else {\n      failure();\n    }\n  };\n  /**\n   * @private\n   */\n  xhr.onerror = failure;\n  xhr.send();\n}\n\n/**\n * Create an XHR feature loader for a `url` and `format`. The feature loader\n * loads features (with XHR), parses the features, and adds them to the\n * vector source.\n * @param {string|FeatureUrlFunction} url Feature URL service.\n * @param {import(\"./format/Feature.js\").default} format Feature format.\n * @return {FeatureLoader} The feature loader.\n * @api\n */\nexport function xhr(url, format) {\n  /**\n   * @param {import(\"./extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {import(\"./proj/Projection.js\").default} projection Projection.\n   * @param {function(): void} [success] Success\n   *      Function called when loading succeeded.\n   * @param {function(): void} [failure] Failure\n   *      Function called when loading failed.\n   * @this {import(\"./source/Vector\").default}\n   */\n  return function (extent, resolution, projection, success, failure) {\n    const source = /** @type {import(\"./source/Vector\").default} */ (this);\n    loadFeaturesXhr(\n      url,\n      format,\n      extent,\n      resolution,\n      projection,\n      /**\n       * @param {Array<import(\"./Feature.js\").default>} features The loaded features.\n       * @param {import(\"./proj/Projection.js\").default} dataProjection Data\n       * projection.\n       */\n      function (features, dataProjection) {\n        source.addFeatures(features);\n        if (success !== undefined) {\n          success(features);\n        }\n      },\n      /* FIXME handle error */ failure ? failure : VOID\n    );\n  };\n}\n\n/**\n * Setter for the withCredentials configuration for the XHR.\n *\n * @param {boolean} xhrWithCredentials The value of withCredentials to set.\n * Compare https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/\n * @api\n */\nexport function setWithCredentials(xhrWithCredentials) {\n  withCredentials = xhrWithCredentials;\n}\n","/**\n * @module ol/format/FormatType\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  ARRAY_BUFFER: 'arraybuffer',\n  JSON: 'json',\n  TEXT: 'text',\n  XML: 'xml',\n};\n","/**\n * @module ol/Feature\n */\nimport BaseObject, {getChangeEventType} from './Object.js';\nimport EventType from './events/EventType.js';\nimport {assert} from './asserts.js';\nimport {listen, unlistenByKey} from './events.js';\n\n/**\n * @typedef {typeof Feature|typeof import(\"./render/Feature.js\").default} FeatureClass\n */\n\n/**\n * @typedef {Feature|import(\"./render/Feature.js\").default} FeatureLike\n */\n\n/**\n * @classdesc\n * A vector object for geographic features with a geometry and other\n * attribute properties, similar to the features in vector file formats like\n * GeoJSON.\n *\n * Features can be styled individually with `setStyle`; otherwise they use the\n * style of their vector layer.\n *\n * Note that attribute properties are set as {@link module:ol/Object} properties on\n * the feature object, so they are observable, and have get/set accessors.\n *\n * Typically, a feature has a single geometry property. You can set the\n * geometry using the `setGeometry` method and get it with `getGeometry`.\n * It is possible to store more than one geometry on a feature using attribute\n * properties. By default, the geometry used for rendering is identified by\n * the property name `geometry`. If you want to use another geometry property\n * for rendering, use the `setGeometryName` method to change the attribute\n * property associated with the geometry for the feature.  For example:\n *\n * ```js\n *\n * import Feature from 'ol/Feature';\n * import Polygon from 'ol/geom/Polygon';\n * import Point from 'ol/geom/Point';\n *\n * var feature = new Feature({\n *   geometry: new Polygon(polyCoords),\n *   labelPoint: new Point(labelCoords),\n *   name: 'My Polygon'\n * });\n *\n * // get the polygon geometry\n * var poly = feature.getGeometry();\n *\n * // Render the feature as a point using the coordinates from labelPoint\n * feature.setGeometryName('labelPoint');\n *\n * // get the point geometry\n * var point = feature.getGeometry();\n * ```\n *\n * @api\n * @template {import(\"./geom/Geometry.js\").default} Geometry\n */\nclass Feature extends BaseObject {\n  /**\n   * @param {Geometry|Object<string, *>} [opt_geometryOrProperties]\n   *     You may pass a Geometry object directly, or an object literal containing\n   *     properties. If you pass an object literal, you may include a Geometry\n   *     associated with a `geometry` key.\n   */\n  constructor(opt_geometryOrProperties) {\n    super();\n\n    /**\n     * @private\n     * @type {number|string|undefined}\n     */\n    this.id_ = undefined;\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.geometryName_ = 'geometry';\n\n    /**\n     * User provided style.\n     * @private\n     * @type {import(\"./style/Style.js\").StyleLike}\n     */\n    this.style_ = null;\n\n    /**\n     * @private\n     * @type {import(\"./style/Style.js\").StyleFunction|undefined}\n     */\n    this.styleFunction_ = undefined;\n\n    /**\n     * @private\n     * @type {?import(\"./events.js\").EventsKey}\n     */\n    this.geometryChangeKey_ = null;\n\n    this.addEventListener(\n      getChangeEventType(this.geometryName_),\n      this.handleGeometryChanged_\n    );\n\n    if (opt_geometryOrProperties) {\n      if (\n        typeof (\n          /** @type {?} */ (opt_geometryOrProperties).getSimplifiedGeometry\n        ) === 'function'\n      ) {\n        const geometry = /** @type {Geometry} */ (opt_geometryOrProperties);\n        this.setGeometry(geometry);\n      } else {\n        /** @type {Object<string, *>} */\n        const properties = opt_geometryOrProperties;\n        this.setProperties(properties);\n      }\n    }\n  }\n\n  /**\n   * Clone this feature. If the original feature has a geometry it\n   * is also cloned. The feature id is not set in the clone.\n   * @return {Feature} The clone.\n   * @api\n   */\n  clone() {\n    const clone = new Feature(\n      this.hasProperties() ? this.getProperties() : null\n    );\n    clone.setGeometryName(this.getGeometryName());\n    const geometry = this.getGeometry();\n    if (geometry) {\n      clone.setGeometry(geometry.clone());\n    }\n    const style = this.getStyle();\n    if (style) {\n      clone.setStyle(style);\n    }\n    return clone;\n  }\n\n  /**\n   * Get the feature's default geometry.  A feature may have any number of named\n   * geometries.  The \"default\" geometry (the one that is rendered by default) is\n   * set when calling {@link module:ol/Feature~Feature#setGeometry}.\n   * @return {Geometry|undefined} The default geometry for the feature.\n   * @api\n   * @observable\n   */\n  getGeometry() {\n    return /** @type {Geometry|undefined} */ (this.get(this.geometryName_));\n  }\n\n  /**\n   * Get the feature identifier.  This is a stable identifier for the feature and\n   * is either set when reading data from a remote source or set explicitly by\n   * calling {@link module:ol/Feature~Feature#setId}.\n   * @return {number|string|undefined} Id.\n   * @api\n   */\n  getId() {\n    return this.id_;\n  }\n\n  /**\n   * Get the name of the feature's default geometry.  By default, the default\n   * geometry is named `geometry`.\n   * @return {string} Get the property name associated with the default geometry\n   *     for this feature.\n   * @api\n   */\n  getGeometryName() {\n    return this.geometryName_;\n  }\n\n  /**\n   * Get the feature's style. Will return what was provided to the\n   * {@link module:ol/Feature~Feature#setStyle} method.\n   * @return {import(\"./style/Style.js\").StyleLike|undefined} The feature style.\n   * @api\n   */\n  getStyle() {\n    return this.style_;\n  }\n\n  /**\n   * Get the feature's style function.\n   * @return {import(\"./style/Style.js\").StyleFunction|undefined} Return a function\n   * representing the current style of this feature.\n   * @api\n   */\n  getStyleFunction() {\n    return this.styleFunction_;\n  }\n\n  /**\n   * @private\n   */\n  handleGeometryChange_() {\n    this.changed();\n  }\n\n  /**\n   * @private\n   */\n  handleGeometryChanged_() {\n    if (this.geometryChangeKey_) {\n      unlistenByKey(this.geometryChangeKey_);\n      this.geometryChangeKey_ = null;\n    }\n    const geometry = this.getGeometry();\n    if (geometry) {\n      this.geometryChangeKey_ = listen(\n        geometry,\n        EventType.CHANGE,\n        this.handleGeometryChange_,\n        this\n      );\n    }\n    this.changed();\n  }\n\n  /**\n   * Set the default geometry for the feature.  This will update the property\n   * with the name returned by {@link module:ol/Feature~Feature#getGeometryName}.\n   * @param {Geometry|undefined} geometry The new geometry.\n   * @api\n   * @observable\n   */\n  setGeometry(geometry) {\n    this.set(this.geometryName_, geometry);\n  }\n\n  /**\n   * Set the style for the feature to override the layer style.  This can be a\n   * single style object, an array of styles, or a function that takes a\n   * resolution and returns an array of styles. To unset the feature style, call\n   * `setStyle()` without arguments or a falsey value.\n   * @param {import(\"./style/Style.js\").StyleLike} [opt_style] Style for this feature.\n   * @api\n   * @fires module:ol/events/Event~BaseEvent#event:change\n   */\n  setStyle(opt_style) {\n    this.style_ = opt_style;\n    this.styleFunction_ = !opt_style\n      ? undefined\n      : createStyleFunction(opt_style);\n    this.changed();\n  }\n\n  /**\n   * Set the feature id.  The feature id is considered stable and may be used when\n   * requesting features or comparing identifiers returned from a remote source.\n   * The feature id can be used with the\n   * {@link module:ol/source/Vector~VectorSource#getFeatureById} method.\n   * @param {number|string|undefined} id The feature id.\n   * @api\n   * @fires module:ol/events/Event~BaseEvent#event:change\n   */\n  setId(id) {\n    this.id_ = id;\n    this.changed();\n  }\n\n  /**\n   * Set the property name to be used when getting the feature's default geometry.\n   * When calling {@link module:ol/Feature~Feature#getGeometry}, the value of the property with\n   * this name will be returned.\n   * @param {string} name The property name of the default geometry.\n   * @api\n   */\n  setGeometryName(name) {\n    this.removeEventListener(\n      getChangeEventType(this.geometryName_),\n      this.handleGeometryChanged_\n    );\n    this.geometryName_ = name;\n    this.addEventListener(\n      getChangeEventType(this.geometryName_),\n      this.handleGeometryChanged_\n    );\n    this.handleGeometryChanged_();\n  }\n}\n\n/**\n * Convert the provided object into a feature style function.  Functions passed\n * through unchanged.  Arrays of Style or single style objects wrapped\n * in a new feature style function.\n * @param {!import(\"./style/Style.js\").StyleFunction|!Array<import(\"./style/Style.js\").default>|!import(\"./style/Style.js\").default} obj\n *     A feature style function, a single style, or an array of styles.\n * @return {import(\"./style/Style.js\").StyleFunction} A style function.\n */\nexport function createStyleFunction(obj) {\n  if (typeof obj === 'function') {\n    return obj;\n  } else {\n    /**\n     * @type {Array<import(\"./style/Style.js\").default>}\n     */\n    let styles;\n    if (Array.isArray(obj)) {\n      styles = obj;\n    } else {\n      assert(typeof (/** @type {?} */ (obj).getZIndex) === 'function', 41); // Expected an `import(\"./style/Style.js\").Style` or an array of `import(\"./style/Style.js\").Style`\n      const style = /** @type {import(\"./style/Style.js\").default} */ (obj);\n      styles = [style];\n    }\n    return function () {\n      return styles;\n    };\n  }\n}\nexport default Feature;\n","/**\n * @module ol/geom/LineString\n */\nimport GeometryLayout from './GeometryLayout.js';\nimport GeometryType from './GeometryType.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {assignClosestPoint, maxSquaredDelta} from './flat/closest.js';\nimport {closestSquaredDistanceXY} from '../extent.js';\nimport {deflateCoordinates} from './flat/deflate.js';\nimport {douglasPeucker} from './flat/simplify.js';\nimport {extend} from '../array.js';\nimport {forEach as forEachSegment} from './flat/segments.js';\nimport {inflateCoordinates} from './flat/inflate.js';\nimport {interpolatePoint, lineStringCoordinateAtM} from './flat/interpolate.js';\nimport {intersectsLineString} from './flat/intersectsextent.js';\nimport {lineStringLength} from './flat/length.js';\n\n/**\n * @classdesc\n * Linestring geometry.\n *\n * @api\n */\nclass LineString extends SimpleGeometry {\n  /**\n   * @param {Array<import(\"../coordinate.js\").Coordinate>|Array<number>} coordinates Coordinates.\n   *     For internal use, flat coordinates in combination with `opt_layout` are also accepted.\n   * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n   */\n  constructor(coordinates, opt_layout) {\n    super();\n\n    /**\n     * @private\n     * @type {import(\"../coordinate.js\").Coordinate}\n     */\n    this.flatMidpoint_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.flatMidpointRevision_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDeltaRevision_ = -1;\n\n    if (opt_layout !== undefined && !Array.isArray(coordinates[0])) {\n      this.setFlatCoordinates(\n        opt_layout,\n        /** @type {Array<number>} */ (coordinates)\n      );\n    } else {\n      this.setCoordinates(\n        /** @type {Array<import(\"../coordinate.js\").Coordinate>} */ (coordinates),\n        opt_layout\n      );\n    }\n  }\n\n  /**\n   * Append the passed coordinate to the coordinates of the linestring.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @api\n   */\n  appendCoordinate(coordinate) {\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = coordinate.slice();\n    } else {\n      extend(this.flatCoordinates, coordinate);\n    }\n    this.changed();\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!LineString} Clone.\n   * @api\n   */\n  clone() {\n    const lineString = new LineString(\n      this.flatCoordinates.slice(),\n      this.layout\n    );\n    lineString.applyProperties(this);\n    return lineString;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(\n        maxSquaredDelta(\n          this.flatCoordinates,\n          0,\n          this.flatCoordinates.length,\n          this.stride,\n          0\n        )\n      );\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return assignClosestPoint(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n      this.maxDelta_,\n      false,\n      x,\n      y,\n      closestPoint,\n      minSquaredDistance\n    );\n  }\n\n  /**\n   * Iterate over each segment, calling the provided callback.\n   * If the callback returns a truthy value the function returns that\n   * value immediately. Otherwise the function returns `false`.\n   *\n   * @param {function(this: S, import(\"../coordinate.js\").Coordinate, import(\"../coordinate.js\").Coordinate): T} callback Function\n   *     called for each segment. The function will receive two arguments, the start and end coordinates of the segment.\n   * @return {T|boolean} Value.\n   * @template T,S\n   * @api\n   */\n  forEachSegment(callback) {\n    return forEachSegment(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n      callback\n    );\n  }\n\n  /**\n   * Returns the coordinate at `m` using linear interpolation, or `null` if no\n   * such coordinate exists.\n   *\n   * `opt_extrapolate` controls extrapolation beyond the range of Ms in the\n   * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first\n   * M will return the first coordinate and Ms greater than the last M will\n   * return the last coordinate.\n   *\n   * @param {number} m M.\n   * @param {boolean} [opt_extrapolate] Extrapolate. Default is `false`.\n   * @return {import(\"../coordinate.js\").Coordinate} Coordinate.\n   * @api\n   */\n  getCoordinateAtM(m, opt_extrapolate) {\n    if (\n      this.layout != GeometryLayout.XYM &&\n      this.layout != GeometryLayout.XYZM\n    ) {\n      return null;\n    }\n    const extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;\n    return lineStringCoordinateAtM(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n      m,\n      extrapolate\n    );\n  }\n\n  /**\n   * Return the coordinates of the linestring.\n   * @return {Array<import(\"../coordinate.js\").Coordinate>} Coordinates.\n   * @api\n   */\n  getCoordinates() {\n    return inflateCoordinates(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride\n    );\n  }\n\n  /**\n   * Return the coordinate at the provided fraction along the linestring.\n   * The `fraction` is a number between 0 and 1, where 0 is the start of the\n   * linestring and 1 is the end.\n   * @param {number} fraction Fraction.\n   * @param {import(\"../coordinate.js\").Coordinate} [opt_dest] Optional coordinate whose values will\n   *     be modified. If not provided, a new coordinate will be returned.\n   * @return {import(\"../coordinate.js\").Coordinate} Coordinate of the interpolated point.\n   * @api\n   */\n  getCoordinateAt(fraction, opt_dest) {\n    return interpolatePoint(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n      fraction,\n      opt_dest,\n      this.stride\n    );\n  }\n\n  /**\n   * Return the length of the linestring on projected plane.\n   * @return {number} Length (on projected plane).\n   * @api\n   */\n  getLength() {\n    return lineStringLength(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride\n    );\n  }\n\n  /**\n   * @return {Array<number>} Flat midpoint.\n   */\n  getFlatMidpoint() {\n    if (this.flatMidpointRevision_ != this.getRevision()) {\n      this.flatMidpoint_ = this.getCoordinateAt(0.5, this.flatMidpoint_);\n      this.flatMidpointRevision_ = this.getRevision();\n    }\n    return this.flatMidpoint_;\n  }\n\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {LineString} Simplified LineString.\n   * @protected\n   */\n  getSimplifiedGeometryInternal(squaredTolerance) {\n    const simplifiedFlatCoordinates = [];\n    simplifiedFlatCoordinates.length = douglasPeucker(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n      squaredTolerance,\n      simplifiedFlatCoordinates,\n      0\n    );\n    return new LineString(simplifiedFlatCoordinates, GeometryLayout.XY);\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./GeometryType.js\").default} Geometry type.\n   * @api\n   */\n  getType() {\n    return GeometryType.LINE_STRING;\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   */\n  intersectsExtent(extent) {\n    return intersectsLineString(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n      extent\n    );\n  }\n\n  /**\n   * Set the coordinates of the linestring.\n   * @param {!Array<import(\"../coordinate.js\").Coordinate>} coordinates Coordinates.\n   * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n   * @api\n   */\n  setCoordinates(coordinates, opt_layout) {\n    this.setLayout(opt_layout, coordinates, 1);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    this.flatCoordinates.length = deflateCoordinates(\n      this.flatCoordinates,\n      0,\n      coordinates,\n      this.stride\n    );\n    this.changed();\n  }\n}\n\nexport default LineString;\n","/**\n * @module ol/geom/flat/interpolate\n */\nimport {binarySearch} from '../../array.js';\nimport {lerp} from '../../math.js';\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} fraction Fraction.\n * @param {Array<number>} [opt_dest] Destination.\n * @param {number} [opt_dimension] Destination dimension (default is `2`)\n * @return {Array<number>} Destination.\n */\nexport function interpolatePoint(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  fraction,\n  opt_dest,\n  opt_dimension\n) {\n  let o, t;\n  const n = (end - offset) / stride;\n  if (n === 1) {\n    o = offset;\n  } else if (n === 2) {\n    o = offset;\n    t = fraction;\n  } else if (n !== 0) {\n    let x1 = flatCoordinates[offset];\n    let y1 = flatCoordinates[offset + 1];\n    let length = 0;\n    const cumulativeLengths = [0];\n    for (let i = offset + stride; i < end; i += stride) {\n      const x2 = flatCoordinates[i];\n      const y2 = flatCoordinates[i + 1];\n      length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n      cumulativeLengths.push(length);\n      x1 = x2;\n      y1 = y2;\n    }\n    const target = fraction * length;\n    const index = binarySearch(cumulativeLengths, target);\n    if (index < 0) {\n      t =\n        (target - cumulativeLengths[-index - 2]) /\n        (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);\n      o = offset + (-index - 2) * stride;\n    } else {\n      o = offset + index * stride;\n    }\n  }\n  const dimension = opt_dimension > 1 ? opt_dimension : 2;\n  const dest = opt_dest ? opt_dest : new Array(dimension);\n  for (let i = 0; i < dimension; ++i) {\n    dest[i] =\n      o === undefined\n        ? NaN\n        : t === undefined\n        ? flatCoordinates[o + i]\n        : lerp(flatCoordinates[o + i], flatCoordinates[o + stride + i], t);\n  }\n  return dest;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} m M.\n * @param {boolean} extrapolate Extrapolate.\n * @return {import(\"../../coordinate.js\").Coordinate} Coordinate.\n */\nexport function lineStringCoordinateAtM(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  m,\n  extrapolate\n) {\n  if (end == offset) {\n    return null;\n  }\n  let coordinate;\n  if (m < flatCoordinates[offset + stride - 1]) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(offset, offset + stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  } else if (flatCoordinates[end - 1] < m) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(end - stride, end);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  }\n  // FIXME use O(1) search\n  if (m == flatCoordinates[offset + stride - 1]) {\n    return flatCoordinates.slice(offset, offset + stride);\n  }\n  let lo = offset / stride;\n  let hi = end / stride;\n  while (lo < hi) {\n    const mid = (lo + hi) >> 1;\n    if (m < flatCoordinates[(mid + 1) * stride - 1]) {\n      hi = mid;\n    } else {\n      lo = mid + 1;\n    }\n  }\n  const m0 = flatCoordinates[lo * stride - 1];\n  if (m == m0) {\n    return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);\n  }\n  const m1 = flatCoordinates[(lo + 1) * stride - 1];\n  const t = (m - m0) / (m1 - m0);\n  coordinate = [];\n  for (let i = 0; i < stride - 1; ++i) {\n    coordinate.push(\n      lerp(\n        flatCoordinates[(lo - 1) * stride + i],\n        flatCoordinates[lo * stride + i],\n        t\n      )\n    );\n  }\n  coordinate.push(m);\n  return coordinate;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} m M.\n * @param {boolean} extrapolate Extrapolate.\n * @param {boolean} interpolate Interpolate.\n * @return {import(\"../../coordinate.js\").Coordinate} Coordinate.\n */\nexport function lineStringsCoordinateAtM(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  m,\n  extrapolate,\n  interpolate\n) {\n  if (interpolate) {\n    return lineStringCoordinateAtM(\n      flatCoordinates,\n      offset,\n      ends[ends.length - 1],\n      stride,\n      m,\n      extrapolate\n    );\n  }\n  let coordinate;\n  if (m < flatCoordinates[stride - 1]) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(0, stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  }\n  if (flatCoordinates[flatCoordinates.length - 1] < m) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(flatCoordinates.length - stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  }\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    if (offset == end) {\n      continue;\n    }\n    if (m < flatCoordinates[offset + stride - 1]) {\n      return null;\n    } else if (m <= flatCoordinates[end - 1]) {\n      return lineStringCoordinateAtM(\n        flatCoordinates,\n        offset,\n        end,\n        stride,\n        m,\n        false\n      );\n    }\n    offset = end;\n  }\n  return null;\n}\n","/**\n * @module ol/geom/MultiLineString\n */\nimport GeometryLayout from './GeometryLayout.js';\nimport GeometryType from './GeometryType.js';\nimport LineString from './LineString.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {arrayMaxSquaredDelta, assignClosestArrayPoint} from './flat/closest.js';\nimport {closestSquaredDistanceXY} from '../extent.js';\nimport {deflateCoordinatesArray} from './flat/deflate.js';\nimport {douglasPeuckerArray} from './flat/simplify.js';\nimport {extend} from '../array.js';\nimport {inflateCoordinatesArray} from './flat/inflate.js';\nimport {\n  interpolatePoint,\n  lineStringsCoordinateAtM,\n} from './flat/interpolate.js';\nimport {intersectsLineStringArray} from './flat/intersectsextent.js';\n\n/**\n * @classdesc\n * Multi-linestring geometry.\n *\n * @api\n */\nclass MultiLineString extends SimpleGeometry {\n  /**\n   * @param {Array<Array<import(\"../coordinate.js\").Coordinate>|LineString>|Array<number>} coordinates\n   *     Coordinates or LineString geometries. (For internal use, flat coordinates in\n   *     combination with `opt_layout` and `opt_ends` are also accepted.)\n   * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n   * @param {Array<number>} [opt_ends] Flat coordinate ends for internal use.\n   */\n  constructor(coordinates, opt_layout, opt_ends) {\n    super();\n\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n    this.ends_ = [];\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDeltaRevision_ = -1;\n\n    if (Array.isArray(coordinates[0])) {\n      this.setCoordinates(\n        /** @type {Array<Array<import(\"../coordinate.js\").Coordinate>>} */ (coordinates),\n        opt_layout\n      );\n    } else if (opt_layout !== undefined && opt_ends) {\n      this.setFlatCoordinates(\n        opt_layout,\n        /** @type {Array<number>} */ (coordinates)\n      );\n      this.ends_ = opt_ends;\n    } else {\n      let layout = this.getLayout();\n      const lineStrings = /** @type {Array<LineString>} */ (coordinates);\n      const flatCoordinates = [];\n      const ends = [];\n      for (let i = 0, ii = lineStrings.length; i < ii; ++i) {\n        const lineString = lineStrings[i];\n        if (i === 0) {\n          layout = lineString.getLayout();\n        }\n        extend(flatCoordinates, lineString.getFlatCoordinates());\n        ends.push(flatCoordinates.length);\n      }\n      this.setFlatCoordinates(layout, flatCoordinates);\n      this.ends_ = ends;\n    }\n  }\n\n  /**\n   * Append the passed linestring to the multilinestring.\n   * @param {LineString} lineString LineString.\n   * @api\n   */\n  appendLineString(lineString) {\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = lineString.getFlatCoordinates().slice();\n    } else {\n      extend(this.flatCoordinates, lineString.getFlatCoordinates().slice());\n    }\n    this.ends_.push(this.flatCoordinates.length);\n    this.changed();\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!MultiLineString} Clone.\n   * @api\n   */\n  clone() {\n    const multiLineString = new MultiLineString(\n      this.flatCoordinates.slice(),\n      this.layout,\n      this.ends_.slice()\n    );\n    multiLineString.applyProperties(this);\n    return multiLineString;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(\n        arrayMaxSquaredDelta(\n          this.flatCoordinates,\n          0,\n          this.ends_,\n          this.stride,\n          0\n        )\n      );\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return assignClosestArrayPoint(\n      this.flatCoordinates,\n      0,\n      this.ends_,\n      this.stride,\n      this.maxDelta_,\n      false,\n      x,\n      y,\n      closestPoint,\n      minSquaredDistance\n    );\n  }\n\n  /**\n   * Returns the coordinate at `m` using linear interpolation, or `null` if no\n   * such coordinate exists.\n   *\n   * `opt_extrapolate` controls extrapolation beyond the range of Ms in the\n   * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first\n   * M will return the first coordinate and Ms greater than the last M will\n   * return the last coordinate.\n   *\n   * `opt_interpolate` controls interpolation between consecutive LineStrings\n   * within the MultiLineString. If `opt_interpolate` is `true` the coordinates\n   * will be linearly interpolated between the last coordinate of one LineString\n   * and the first coordinate of the next LineString.  If `opt_interpolate` is\n   * `false` then the function will return `null` for Ms falling between\n   * LineStrings.\n   *\n   * @param {number} m M.\n   * @param {boolean} [opt_extrapolate] Extrapolate. Default is `false`.\n   * @param {boolean} [opt_interpolate] Interpolate. Default is `false`.\n   * @return {import(\"../coordinate.js\").Coordinate} Coordinate.\n   * @api\n   */\n  getCoordinateAtM(m, opt_extrapolate, opt_interpolate) {\n    if (\n      (this.layout != GeometryLayout.XYM &&\n        this.layout != GeometryLayout.XYZM) ||\n      this.flatCoordinates.length === 0\n    ) {\n      return null;\n    }\n    const extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;\n    const interpolate = opt_interpolate !== undefined ? opt_interpolate : false;\n    return lineStringsCoordinateAtM(\n      this.flatCoordinates,\n      0,\n      this.ends_,\n      this.stride,\n      m,\n      extrapolate,\n      interpolate\n    );\n  }\n\n  /**\n   * Return the coordinates of the multilinestring.\n   * @return {Array<Array<import(\"../coordinate.js\").Coordinate>>} Coordinates.\n   * @api\n   */\n  getCoordinates() {\n    return inflateCoordinatesArray(\n      this.flatCoordinates,\n      0,\n      this.ends_,\n      this.stride\n    );\n  }\n\n  /**\n   * @return {Array<number>} Ends.\n   */\n  getEnds() {\n    return this.ends_;\n  }\n\n  /**\n   * Return the linestring at the specified index.\n   * @param {number} index Index.\n   * @return {LineString} LineString.\n   * @api\n   */\n  getLineString(index) {\n    if (index < 0 || this.ends_.length <= index) {\n      return null;\n    }\n    return new LineString(\n      this.flatCoordinates.slice(\n        index === 0 ? 0 : this.ends_[index - 1],\n        this.ends_[index]\n      ),\n      this.layout\n    );\n  }\n\n  /**\n   * Return the linestrings of this multilinestring.\n   * @return {Array<LineString>} LineStrings.\n   * @api\n   */\n  getLineStrings() {\n    const flatCoordinates = this.flatCoordinates;\n    const ends = this.ends_;\n    const layout = this.layout;\n    /** @type {Array<LineString>} */\n    const lineStrings = [];\n    let offset = 0;\n    for (let i = 0, ii = ends.length; i < ii; ++i) {\n      const end = ends[i];\n      const lineString = new LineString(\n        flatCoordinates.slice(offset, end),\n        layout\n      );\n      lineStrings.push(lineString);\n      offset = end;\n    }\n    return lineStrings;\n  }\n\n  /**\n   * @return {Array<number>} Flat midpoints.\n   */\n  getFlatMidpoints() {\n    const midpoints = [];\n    const flatCoordinates = this.flatCoordinates;\n    let offset = 0;\n    const ends = this.ends_;\n    const stride = this.stride;\n    for (let i = 0, ii = ends.length; i < ii; ++i) {\n      const end = ends[i];\n      const midpoint = interpolatePoint(\n        flatCoordinates,\n        offset,\n        end,\n        stride,\n        0.5\n      );\n      extend(midpoints, midpoint);\n      offset = end;\n    }\n    return midpoints;\n  }\n\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {MultiLineString} Simplified MultiLineString.\n   * @protected\n   */\n  getSimplifiedGeometryInternal(squaredTolerance) {\n    const simplifiedFlatCoordinates = [];\n    const simplifiedEnds = [];\n    simplifiedFlatCoordinates.length = douglasPeuckerArray(\n      this.flatCoordinates,\n      0,\n      this.ends_,\n      this.stride,\n      squaredTolerance,\n      simplifiedFlatCoordinates,\n      0,\n      simplifiedEnds\n    );\n    return new MultiLineString(\n      simplifiedFlatCoordinates,\n      GeometryLayout.XY,\n      simplifiedEnds\n    );\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./GeometryType.js\").default} Geometry type.\n   * @api\n   */\n  getType() {\n    return GeometryType.MULTI_LINE_STRING;\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   */\n  intersectsExtent(extent) {\n    return intersectsLineStringArray(\n      this.flatCoordinates,\n      0,\n      this.ends_,\n      this.stride,\n      extent\n    );\n  }\n\n  /**\n   * Set the coordinates of the multilinestring.\n   * @param {!Array<Array<import(\"../coordinate.js\").Coordinate>>} coordinates Coordinates.\n   * @param {GeometryLayout} [opt_layout] Layout.\n   * @api\n   */\n  setCoordinates(coordinates, opt_layout) {\n    this.setLayout(opt_layout, coordinates, 2);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    const ends = deflateCoordinatesArray(\n      this.flatCoordinates,\n      0,\n      coordinates,\n      this.stride,\n      this.ends_\n    );\n    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];\n    this.changed();\n  }\n}\n\nexport default MultiLineString;\n","/**\n * @module ol/format/XMLFeature\n */\nimport FeatureFormat from '../format/Feature.js';\nimport FormatType from '../format/FormatType.js';\nimport {abstract} from '../util.js';\nimport {extend} from '../array.js';\nimport {getXMLSerializer, isDocument, parse} from '../xml.js';\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for XML feature formats.\n *\n * @abstract\n */\nclass XMLFeature extends FeatureFormat {\n  constructor() {\n    super();\n\n    /**\n     * @type {XMLSerializer}\n     * @private\n     */\n    this.xmlSerializer_ = getXMLSerializer();\n  }\n\n  /**\n   * @return {import(\"./FormatType.js\").default} Format.\n   */\n  getType() {\n    return FormatType.XML;\n  }\n\n  /**\n   * Read a single feature.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Read options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   * @api\n   */\n  readFeature(source, opt_options) {\n    if (!source) {\n      return null;\n    } else if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readFeatureFromDocument(doc, opt_options);\n    } else if (isDocument(source)) {\n      return this.readFeatureFromDocument(\n        /** @type {Document} */ (source),\n        opt_options\n      );\n    } else {\n      return this.readFeatureFromNode(\n        /** @type {Element} */ (source),\n        opt_options\n      );\n    }\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   */\n  readFeatureFromDocument(doc, opt_options) {\n    const features = this.readFeaturesFromDocument(doc, opt_options);\n    if (features.length > 0) {\n      return features[0];\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   */\n  readFeatureFromNode(node, opt_options) {\n    return null; // not implemented\n  }\n\n  /**\n   * Read all features from a feature collection.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Options.\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   * @api\n   */\n  readFeatures(source, opt_options) {\n    if (!source) {\n      return [];\n    } else if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readFeaturesFromDocument(doc, opt_options);\n    } else if (isDocument(source)) {\n      return this.readFeaturesFromDocument(\n        /** @type {Document} */ (source),\n        opt_options\n      );\n    } else {\n      return this.readFeaturesFromNode(\n        /** @type {Element} */ (source),\n        opt_options\n      );\n    }\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Options.\n   * @protected\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   */\n  readFeaturesFromDocument(doc, opt_options) {\n    /** @type {Array<import(\"../Feature.js\").default>} */\n    const features = [];\n    for (let n = doc.firstChild; n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        extend(\n          features,\n          this.readFeaturesFromNode(/** @type {Element} */ (n), opt_options)\n        );\n      }\n    }\n    return features;\n  }\n\n  /**\n   * @abstract\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Options.\n   * @protected\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   */\n  readFeaturesFromNode(node, opt_options) {\n    return abstract();\n  }\n\n  /**\n   * Read a single geometry from a source.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Read options.\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n  readGeometry(source, opt_options) {\n    if (!source) {\n      return null;\n    } else if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readGeometryFromDocument(doc, opt_options);\n    } else if (isDocument(source)) {\n      return this.readGeometryFromDocument(\n        /** @type {Document} */ (source),\n        opt_options\n      );\n    } else {\n      return this.readGeometryFromNode(\n        /** @type {Element} */ (source),\n        opt_options\n      );\n    }\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Options.\n   * @protected\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n  readGeometryFromDocument(doc, opt_options) {\n    return null; // not implemented\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Options.\n   * @protected\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n  readGeometryFromNode(node, opt_options) {\n    return null; // not implemented\n  }\n\n  /**\n   * Read the projection from the source.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   * @api\n   */\n  readProjection(source) {\n    if (!source) {\n      return null;\n    } else if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readProjectionFromDocument(doc);\n    } else if (isDocument(source)) {\n      return this.readProjectionFromDocument(/** @type {Document} */ (source));\n    } else {\n      return this.readProjectionFromNode(/** @type {Element} */ (source));\n    }\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @protected\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   */\n  readProjectionFromDocument(doc) {\n    return this.dataProjection;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @protected\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   */\n  readProjectionFromNode(node) {\n    return this.dataProjection;\n  }\n\n  /**\n   * Encode a feature as string.\n   *\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Write options.\n   * @return {string} Encoded feature.\n   */\n  writeFeature(feature, opt_options) {\n    const node = this.writeFeatureNode(feature, opt_options);\n    return this.xmlSerializer_.serializeToString(node);\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Options.\n   * @protected\n   * @return {Node} Node.\n   */\n  writeFeatureNode(feature, opt_options) {\n    return null; // not implemented\n  }\n\n  /**\n   * Encode an array of features as string.\n   *\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Write options.\n   * @return {string} Result.\n   * @api\n   */\n  writeFeatures(features, opt_options) {\n    const node = this.writeFeaturesNode(features, opt_options);\n    return this.xmlSerializer_.serializeToString(node);\n  }\n\n  /**\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Options.\n   * @return {Node} Node.\n   */\n  writeFeaturesNode(features, opt_options) {\n    return null; // not implemented\n  }\n\n  /**\n   * Encode a geometry as string.\n   *\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Write options.\n   * @return {string} Encoded geometry.\n   */\n  writeGeometry(geometry, opt_options) {\n    const node = this.writeGeometryNode(geometry, opt_options);\n    return this.xmlSerializer_.serializeToString(node);\n  }\n\n  /**\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Options.\n   * @return {Node} Node.\n   */\n  writeGeometryNode(geometry, opt_options) {\n    return null; // not implemented\n  }\n}\n\nexport default XMLFeature;\n","/**\n * @module ol/format/Feature\n */\nimport Units from '../proj/Units.js';\nimport {abstract} from '../util.js';\nimport {assign} from '../obj.js';\nimport {\n  equivalent as equivalentProjection,\n  get as getProjection,\n  transformExtent,\n} from '../proj.js';\n\n/**\n * @typedef {Object} ReadOptions\n * @property {import(\"../proj.js\").ProjectionLike} [dataProjection] Projection of the data we are reading.\n * If not provided, the projection will be derived from the data (where possible) or\n * the `dataProjection` of the format is assigned (where set). If the projection\n * can not be derived from the data and if no `dataProjection` is set for a format,\n * the features will not be reprojected.\n * @property {import(\"../extent.js\").Extent} [extent] Tile extent in map units of the tile being read.\n * This is only required when reading data with tile pixels as geometry units. When configured,\n * a `dataProjection` with `TILE_PIXELS` as `units` and the tile's pixel extent as `extent` needs to be\n * provided.\n * @property {import(\"../proj.js\").ProjectionLike} [featureProjection] Projection of the feature geometries\n * created by the format reader. If not provided, features will be returned in the\n * `dataProjection`.\n */\n\n/**\n * @typedef {Object} WriteOptions\n * @property {import(\"../proj.js\").ProjectionLike} [dataProjection] Projection of the data we are writing.\n * If not provided, the `dataProjection` of the format is assigned (where set).\n * If no `dataProjection` is set for a format, the features will be returned\n * in the `featureProjection`.\n * @property {import(\"../proj.js\").ProjectionLike} [featureProjection] Projection of the feature geometries\n * that will be serialized by the format writer. If not provided, geometries are assumed\n * to be in the `dataProjection` if that is set; in other words, they are not transformed.\n * @property {boolean} [rightHanded] When writing geometries, follow the right-hand\n * rule for linear ring orientation.  This means that polygons will have counter-clockwise\n * exterior rings and clockwise interior rings.  By default, coordinates are serialized\n * as they are provided at construction.  If `true`, the right-hand rule will\n * be applied.  If `false`, the left-hand rule will be applied (clockwise for\n * exterior and counter-clockwise for interior rings).  Note that not all\n * formats support this.  The GeoJSON format does use this property when writing\n * geometries.\n * @property {number} [decimals] Maximum number of decimal places for coordinates.\n * Coordinates are stored internally as floats, but floating-point arithmetic can create\n * coordinates with a large number of decimal places, not generally wanted on output.\n * Set a number here to round coordinates. Can also be used to ensure that\n * coordinates read in can be written back out with the same number of decimals.\n * Default is no rounding.\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for feature formats.\n * {@link module:ol/format/Feature~FeatureFormat} subclasses provide the ability to decode and encode\n * {@link module:ol/Feature~Feature} objects from a variety of commonly used geospatial\n * file formats.  See the documentation for each format for more details.\n *\n * @abstract\n * @api\n */\nclass FeatureFormat {\n  constructor() {\n    /**\n     * @protected\n     * @type {import(\"../proj/Projection.js\").default|undefined}\n     */\n    this.dataProjection = undefined;\n\n    /**\n     * @protected\n     * @type {import(\"../proj/Projection.js\").default|undefined}\n     */\n    this.defaultFeatureProjection = undefined;\n  }\n\n  /**\n   * Adds the data projection to the read options.\n   * @param {Document|Element|Object|string} source Source.\n   * @param {ReadOptions} [opt_options] Options.\n   * @return {ReadOptions|undefined} Options.\n   * @protected\n   */\n  getReadOptions(source, opt_options) {\n    let options;\n    if (opt_options) {\n      let dataProjection = opt_options.dataProjection\n        ? getProjection(opt_options.dataProjection)\n        : this.readProjection(source);\n      if (\n        opt_options.extent &&\n        dataProjection &&\n        dataProjection.getUnits() === Units.TILE_PIXELS\n      ) {\n        dataProjection = getProjection(dataProjection);\n        dataProjection.setWorldExtent(opt_options.extent);\n      }\n      options = {\n        dataProjection: dataProjection,\n        featureProjection: opt_options.featureProjection,\n      };\n    }\n    return this.adaptOptions(options);\n  }\n\n  /**\n   * Sets the `dataProjection` on the options, if no `dataProjection`\n   * is set.\n   * @param {WriteOptions|ReadOptions|undefined} options\n   *     Options.\n   * @protected\n   * @return {WriteOptions|ReadOptions|undefined}\n   *     Updated options.\n   */\n  adaptOptions(options) {\n    return assign(\n      {\n        dataProjection: this.dataProjection,\n        featureProjection: this.defaultFeatureProjection,\n      },\n      options\n    );\n  }\n\n  /**\n   * @abstract\n   * @return {import(\"./FormatType.js\").default} Format.\n   */\n  getType() {\n    return abstract();\n  }\n\n  /**\n   * Read a single feature from a source.\n   *\n   * @abstract\n   * @param {Document|Element|Object|string} source Source.\n   * @param {ReadOptions} [opt_options] Read options.\n   * @return {import(\"../Feature.js\").FeatureLike} Feature.\n   */\n  readFeature(source, opt_options) {\n    return abstract();\n  }\n\n  /**\n   * Read all features from a source.\n   *\n   * @abstract\n   * @param {Document|Element|ArrayBuffer|Object|string} source Source.\n   * @param {ReadOptions} [opt_options] Read options.\n   * @return {Array<import(\"../Feature.js\").FeatureLike>} Features.\n   */\n  readFeatures(source, opt_options) {\n    return abstract();\n  }\n\n  /**\n   * Read a single geometry from a source.\n   *\n   * @abstract\n   * @param {Document|Element|Object|string} source Source.\n   * @param {ReadOptions} [opt_options] Read options.\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n  readGeometry(source, opt_options) {\n    return abstract();\n  }\n\n  /**\n   * Read the projection from a source.\n   *\n   * @abstract\n   * @param {Document|Element|Object|string} source Source.\n   * @return {import(\"../proj/Projection.js\").default|undefined} Projection.\n   */\n  readProjection(source) {\n    return abstract();\n  }\n\n  /**\n   * Encode a feature in this format.\n   *\n   * @abstract\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {WriteOptions} [opt_options] Write options.\n   * @return {string|ArrayBuffer} Result.\n   */\n  writeFeature(feature, opt_options) {\n    return abstract();\n  }\n\n  /**\n   * Encode an array of features in this format.\n   *\n   * @abstract\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {WriteOptions} [opt_options] Write options.\n   * @return {string|ArrayBuffer} Result.\n   */\n  writeFeatures(features, opt_options) {\n    return abstract();\n  }\n\n  /**\n   * Write a single geometry in this format.\n   *\n   * @abstract\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {WriteOptions} [opt_options] Write options.\n   * @return {string|ArrayBuffer} Result.\n   */\n  writeGeometry(geometry, opt_options) {\n    return abstract();\n  }\n}\n\nexport default FeatureFormat;\n\n/**\n * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n * @param {boolean} write Set to true for writing, false for reading.\n * @param {WriteOptions|ReadOptions} [opt_options] Options.\n * @return {import(\"../geom/Geometry.js\").default} Transformed geometry.\n */\nexport function transformGeometryWithOptions(geometry, write, opt_options) {\n  const featureProjection = opt_options\n    ? getProjection(opt_options.featureProjection)\n    : null;\n  const dataProjection = opt_options\n    ? getProjection(opt_options.dataProjection)\n    : null;\n\n  let transformed;\n  if (\n    featureProjection &&\n    dataProjection &&\n    !equivalentProjection(featureProjection, dataProjection)\n  ) {\n    transformed = (write ? geometry.clone() : geometry).transform(\n      write ? featureProjection : dataProjection,\n      write ? dataProjection : featureProjection\n    );\n  } else {\n    transformed = geometry;\n  }\n  if (\n    write &&\n    opt_options &&\n    /** @type {WriteOptions} */ (opt_options).decimals !== undefined\n  ) {\n    const power = Math.pow(\n      10,\n      /** @type {WriteOptions} */ (opt_options).decimals\n    );\n    // if decimals option on write, round each coordinate appropriately\n    /**\n     * @param {Array<number>} coordinates Coordinates.\n     * @return {Array<number>} Transformed coordinates.\n     */\n    const transform = function (coordinates) {\n      for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n        coordinates[i] = Math.round(coordinates[i] * power) / power;\n      }\n      return coordinates;\n    };\n    if (transformed === geometry) {\n      transformed = geometry.clone();\n    }\n    transformed.applyTransform(transform);\n  }\n  return transformed;\n}\n\n/**\n * @param {import(\"../extent.js\").Extent} extent Extent.\n * @param {ReadOptions} [opt_options] Read options.\n * @return {import(\"../extent.js\").Extent} Transformed extent.\n */\nexport function transformExtentWithOptions(extent, opt_options) {\n  const featureProjection = opt_options\n    ? getProjection(opt_options.featureProjection)\n    : null;\n  const dataProjection = opt_options\n    ? getProjection(opt_options.dataProjection)\n    : null;\n\n  if (\n    featureProjection &&\n    dataProjection &&\n    !equivalentProjection(featureProjection, dataProjection)\n  ) {\n    return transformExtent(extent, dataProjection, featureProjection);\n  } else {\n    return extent;\n  }\n}\n","/**\n * @module ol/xml\n */\nimport {extend} from './array.js';\n\n/**\n * When using {@link module:ol/xml~makeChildAppender} or\n * {@link module:ol/xml~makeSimpleNodeFactory}, the top `objectStack` item needs\n * to have this structure.\n * @typedef {Object} NodeStackItem\n * @property {Node} node Node.\n */\n\n/**\n * @typedef {function(Element, Array<*>): void} Parser\n */\n\n/**\n * @typedef {function(Element, *, Array<*>): void} Serializer\n */\n\n/**\n * @type {string}\n */\nexport const XML_SCHEMA_INSTANCE_URI =\n  'http://www.w3.org/2001/XMLSchema-instance';\n\n/**\n * @param {string} namespaceURI Namespace URI.\n * @param {string} qualifiedName Qualified name.\n * @return {Element} Node.\n */\nexport function createElementNS(namespaceURI, qualifiedName) {\n  return getDocument().createElementNS(namespaceURI, qualifiedName);\n}\n\n/**\n * Recursively grab all text content of child nodes into a single string.\n * @param {Node} node Node.\n * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line\n * breaks.\n * @return {string} All text content.\n * @api\n */\nexport function getAllTextContent(node, normalizeWhitespace) {\n  return getAllTextContent_(node, normalizeWhitespace, []).join('');\n}\n\n/**\n * Recursively grab all text content of child nodes into a single string.\n * @param {Node} node Node.\n * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line\n * breaks.\n * @param {Array<string>} accumulator Accumulator.\n * @private\n * @return {Array<string>} Accumulator.\n */\nexport function getAllTextContent_(node, normalizeWhitespace, accumulator) {\n  if (\n    node.nodeType == Node.CDATA_SECTION_NODE ||\n    node.nodeType == Node.TEXT_NODE\n  ) {\n    if (normalizeWhitespace) {\n      accumulator.push(String(node.nodeValue).replace(/(\\r\\n|\\r|\\n)/g, ''));\n    } else {\n      accumulator.push(node.nodeValue);\n    }\n  } else {\n    let n;\n    for (n = node.firstChild; n; n = n.nextSibling) {\n      getAllTextContent_(n, normalizeWhitespace, accumulator);\n    }\n  }\n  return accumulator;\n}\n\n/**\n * @param {Object} object Object.\n * @return {boolean} Is a document.\n */\nexport function isDocument(object) {\n  return 'documentElement' in object;\n}\n\n/**\n * @param {Element} node Node.\n * @param {?string} namespaceURI Namespace URI.\n * @param {string} name Attribute name.\n * @return {string} Value\n */\nexport function getAttributeNS(node, namespaceURI, name) {\n  return node.getAttributeNS(namespaceURI, name) || '';\n}\n\n/**\n * Parse an XML string to an XML Document.\n * @param {string} xml XML.\n * @return {Document} Document.\n * @api\n */\nexport function parse(xml) {\n  return new DOMParser().parseFromString(xml, 'application/xml');\n}\n\n/**\n * Make an array extender function for extending the array at the top of the\n * object stack.\n * @param {function(this: T, Node, Array<*>): (Array<*>|undefined)} valueReader Value reader.\n * @param {T} [opt_this] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeArrayExtender(valueReader, opt_this) {\n  return (\n    /**\n     * @param {Node} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function (node, objectStack) {\n      const value = valueReader.call(\n        opt_this !== undefined ? opt_this : this,\n        node,\n        objectStack\n      );\n      if (value !== undefined) {\n        const array = /** @type {Array<*>} */ (objectStack[\n          objectStack.length - 1\n        ]);\n        extend(array, value);\n      }\n    }\n  );\n}\n\n/**\n * Make an array pusher function for pushing to the array at the top of the\n * object stack.\n * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.\n * @param {T} [opt_this] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeArrayPusher(valueReader, opt_this) {\n  return (\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function (node, objectStack) {\n      const value = valueReader.call(\n        opt_this !== undefined ? opt_this : this,\n        node,\n        objectStack\n      );\n      if (value !== undefined) {\n        const array = /** @type {Array<*>} */ (objectStack[\n          objectStack.length - 1\n        ]);\n        array.push(value);\n      }\n    }\n  );\n}\n\n/**\n * Make an object stack replacer function for replacing the object at the\n * top of the stack.\n * @param {function(this: T, Node, Array<*>): *} valueReader Value reader.\n * @param {T} [opt_this] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeReplacer(valueReader, opt_this) {\n  return (\n    /**\n     * @param {Node} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function (node, objectStack) {\n      const value = valueReader.call(\n        opt_this !== undefined ? opt_this : this,\n        node,\n        objectStack\n      );\n      if (value !== undefined) {\n        objectStack[objectStack.length - 1] = value;\n      }\n    }\n  );\n}\n\n/**\n * Make an object property pusher function for adding a property to the\n * object at the top of the stack.\n * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.\n * @param {string} [opt_property] Property.\n * @param {T} [opt_this] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeObjectPropertyPusher(valueReader, opt_property, opt_this) {\n  return (\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function (node, objectStack) {\n      const value = valueReader.call(\n        opt_this !== undefined ? opt_this : this,\n        node,\n        objectStack\n      );\n      if (value !== undefined) {\n        const object = /** @type {!Object} */ (objectStack[\n          objectStack.length - 1\n        ]);\n        const property =\n          opt_property !== undefined ? opt_property : node.localName;\n        let array;\n        if (property in object) {\n          array = object[property];\n        } else {\n          array = [];\n          object[property] = array;\n        }\n        array.push(value);\n      }\n    }\n  );\n}\n\n/**\n * Make an object property setter function.\n * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.\n * @param {string} [opt_property] Property.\n * @param {T} [opt_this] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeObjectPropertySetter(valueReader, opt_property, opt_this) {\n  return (\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function (node, objectStack) {\n      const value = valueReader.call(\n        opt_this !== undefined ? opt_this : this,\n        node,\n        objectStack\n      );\n      if (value !== undefined) {\n        const object = /** @type {!Object} */ (objectStack[\n          objectStack.length - 1\n        ]);\n        const property =\n          opt_property !== undefined ? opt_property : node.localName;\n        object[property] = value;\n      }\n    }\n  );\n}\n\n/**\n * Create a serializer that appends nodes written by its `nodeWriter` to its\n * designated parent. The parent is the `node` of the\n * {@link module:ol/xml~NodeStackItem} at the top of the `objectStack`.\n * @param {function(this: T, Node, V, Array<*>): void} nodeWriter Node writer.\n * @param {T} [opt_this] The object to use as `this` in `nodeWriter`.\n * @return {Serializer} Serializer.\n * @template T, V\n */\nexport function makeChildAppender(nodeWriter, opt_this) {\n  return function (node, value, objectStack) {\n    nodeWriter.call(\n      opt_this !== undefined ? opt_this : this,\n      node,\n      value,\n      objectStack\n    );\n    const parent = /** @type {NodeStackItem} */ (objectStack[\n      objectStack.length - 1\n    ]);\n    const parentNode = parent.node;\n    parentNode.appendChild(node);\n  };\n}\n\n/**\n * Create a serializer that calls the provided `nodeWriter` from\n * {@link module:ol/xml~serialize}. This can be used by the parent writer to have the\n * 'nodeWriter' called with an array of values when the `nodeWriter` was\n * designed to serialize a single item. An example would be a LineString\n * geometry writer, which could be reused for writing MultiLineString\n * geometries.\n * @param {function(this: T, Element, V, Array<*>): void} nodeWriter Node writer.\n * @param {T} [opt_this] The object to use as `this` in `nodeWriter`.\n * @return {Serializer} Serializer.\n * @template T, V\n */\nexport function makeArraySerializer(nodeWriter, opt_this) {\n  let serializersNS, nodeFactory;\n  return function (node, value, objectStack) {\n    if (serializersNS === undefined) {\n      serializersNS = {};\n      const serializers = {};\n      serializers[node.localName] = nodeWriter;\n      serializersNS[node.namespaceURI] = serializers;\n      nodeFactory = makeSimpleNodeFactory(node.localName);\n    }\n    serialize(serializersNS, nodeFactory, value, objectStack);\n  };\n}\n\n/**\n * Create a node factory which can use the `opt_keys` passed to\n * {@link module:ol/xml~serialize} or {@link module:ol/xml~pushSerializeAndPop} as node names,\n * or a fixed node name. The namespace of the created nodes can either be fixed,\n * or the parent namespace will be used.\n * @param {string} [opt_nodeName] Fixed node name which will be used for all\n *     created nodes. If not provided, the 3rd argument to the resulting node\n *     factory needs to be provided and will be the nodeName.\n * @param {string} [opt_namespaceURI] Fixed namespace URI which will be used for\n *     all created nodes. If not provided, the namespace of the parent node will\n *     be used.\n * @return {function(*, Array<*>, string=): (Node|undefined)} Node factory.\n */\nexport function makeSimpleNodeFactory(opt_nodeName, opt_namespaceURI) {\n  const fixedNodeName = opt_nodeName;\n  return (\n    /**\n     * @param {*} value Value.\n     * @param {Array<*>} objectStack Object stack.\n     * @param {string} [opt_nodeName] Node name.\n     * @return {Node} Node.\n     */\n    function (value, objectStack, opt_nodeName) {\n      const context = /** @type {NodeStackItem} */ (objectStack[\n        objectStack.length - 1\n      ]);\n      const node = context.node;\n      let nodeName = fixedNodeName;\n      if (nodeName === undefined) {\n        nodeName = opt_nodeName;\n      }\n\n      const namespaceURI =\n        opt_namespaceURI !== undefined ? opt_namespaceURI : node.namespaceURI;\n      return createElementNS(namespaceURI, /** @type {string} */ (nodeName));\n    }\n  );\n}\n\n/**\n * A node factory that creates a node using the parent's `namespaceURI` and the\n * `nodeName` passed by {@link module:ol/xml~serialize} or\n * {@link module:ol/xml~pushSerializeAndPop} to the node factory.\n * @const\n * @type {function(*, Array<*>, string=): (Node|undefined)}\n */\nexport const OBJECT_PROPERTY_NODE_FACTORY = makeSimpleNodeFactory();\n\n/**\n * Create an array of `values` to be used with {@link module:ol/xml~serialize} or\n * {@link module:ol/xml~pushSerializeAndPop}, where `orderedKeys` has to be provided as\n * `opt_key` argument.\n * @param {Object<string, *>} object Key-value pairs for the sequence. Keys can\n *     be a subset of the `orderedKeys`.\n * @param {Array<string>} orderedKeys Keys in the order of the sequence.\n * @return {Array<*>} Values in the order of the sequence. The resulting array\n *     has the same length as the `orderedKeys` array. Values that are not\n *     present in `object` will be `undefined` in the resulting array.\n */\nexport function makeSequence(object, orderedKeys) {\n  const length = orderedKeys.length;\n  const sequence = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    sequence[i] = object[orderedKeys[i]];\n  }\n  return sequence;\n}\n\n/**\n * Create a namespaced structure, using the same values for each namespace.\n * This can be used as a starting point for versioned parsers, when only a few\n * values are version specific.\n * @param {Array<string>} namespaceURIs Namespace URIs.\n * @param {T} structure Structure.\n * @param {Object<string, T>} [opt_structureNS] Namespaced structure to add to.\n * @return {Object<string, T>} Namespaced structure.\n * @template T\n */\nexport function makeStructureNS(namespaceURIs, structure, opt_structureNS) {\n  /**\n   * @type {Object<string, T>}\n   */\n  const structureNS = opt_structureNS !== undefined ? opt_structureNS : {};\n  let i, ii;\n  for (i = 0, ii = namespaceURIs.length; i < ii; ++i) {\n    structureNS[namespaceURIs[i]] = structure;\n  }\n  return structureNS;\n}\n\n/**\n * Parse a node using the parsers and object stack.\n * @param {Object<string, Object<string, Parser>>} parsersNS\n *     Parsers by namespace.\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @param {*} [opt_this] The object to use as `this`.\n */\nexport function parseNode(parsersNS, node, objectStack, opt_this) {\n  let n;\n  for (n = node.firstElementChild; n; n = n.nextElementSibling) {\n    const parsers = parsersNS[n.namespaceURI];\n    if (parsers !== undefined) {\n      const parser = parsers[n.localName];\n      if (parser !== undefined) {\n        parser.call(opt_this, n, objectStack);\n      }\n    }\n  }\n}\n\n/**\n * Push an object on top of the stack, parse and return the popped object.\n * @param {T} object Object.\n * @param {Object<string, Object<string, Parser>>} parsersNS\n *     Parsers by namespace.\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @param {*} [opt_this] The object to use as `this`.\n * @return {T} Object.\n * @template T\n */\nexport function pushParseAndPop(\n  object,\n  parsersNS,\n  node,\n  objectStack,\n  opt_this\n) {\n  objectStack.push(object);\n  parseNode(parsersNS, node, objectStack, opt_this);\n  return /** @type {T} */ (objectStack.pop());\n}\n\n/**\n * Walk through an array of `values` and call a serializer for each value.\n * @param {Object<string, Object<string, Serializer>>} serializersNS\n *     Namespaced serializers.\n * @param {function(this: T, *, Array<*>, (string|undefined)): (Node|undefined)} nodeFactory\n *     Node factory. The `nodeFactory` creates the node whose namespace and name\n *     will be used to choose a node writer from `serializersNS`. This\n *     separation allows us to decide what kind of node to create, depending on\n *     the value we want to serialize. An example for this would be different\n *     geometry writers based on the geometry type.\n * @param {Array<*>} values Values to serialize. An example would be an array\n *     of {@link module:ol/Feature~Feature} instances.\n * @param {Array<*>} objectStack Node stack.\n * @param {Array<string>} [opt_keys] Keys of the `values`. Will be passed to the\n *     `nodeFactory`. This is used for serializing object literals where the\n *     node name relates to the property key. The array length of `opt_keys` has\n *     to match the length of `values`. For serializing a sequence, `opt_keys`\n *     determines the order of the sequence.\n * @param {T} [opt_this] The object to use as `this` for the node factory and\n *     serializers.\n * @template T\n */\nexport function serialize(\n  serializersNS,\n  nodeFactory,\n  values,\n  objectStack,\n  opt_keys,\n  opt_this\n) {\n  const length = (opt_keys !== undefined ? opt_keys : values).length;\n  let value, node;\n  for (let i = 0; i < length; ++i) {\n    value = values[i];\n    if (value !== undefined) {\n      node = nodeFactory.call(\n        opt_this !== undefined ? opt_this : this,\n        value,\n        objectStack,\n        opt_keys !== undefined ? opt_keys[i] : undefined\n      );\n      if (node !== undefined) {\n        serializersNS[node.namespaceURI][node.localName].call(\n          opt_this,\n          node,\n          value,\n          objectStack\n        );\n      }\n    }\n  }\n}\n\n/**\n * @param {O} object Object.\n * @param {Object<string, Object<string, Serializer>>} serializersNS\n *     Namespaced serializers.\n * @param {function(this: T, *, Array<*>, (string|undefined)): (Node|undefined)} nodeFactory\n *     Node factory. The `nodeFactory` creates the node whose namespace and name\n *     will be used to choose a node writer from `serializersNS`. This\n *     separation allows us to decide what kind of node to create, depending on\n *     the value we want to serialize. An example for this would be different\n *     geometry writers based on the geometry type.\n * @param {Array<*>} values Values to serialize. An example would be an array\n *     of {@link module:ol/Feature~Feature} instances.\n * @param {Array<*>} objectStack Node stack.\n * @param {Array<string>} [opt_keys] Keys of the `values`. Will be passed to the\n *     `nodeFactory`. This is used for serializing object literals where the\n *     node name relates to the property key. The array length of `opt_keys` has\n *     to match the length of `values`. For serializing a sequence, `opt_keys`\n *     determines the order of the sequence.\n * @param {T} [opt_this] The object to use as `this` for the node factory and\n *     serializers.\n * @return {O|undefined} Object.\n * @template O, T\n */\nexport function pushSerializeAndPop(\n  object,\n  serializersNS,\n  nodeFactory,\n  values,\n  objectStack,\n  opt_keys,\n  opt_this\n) {\n  objectStack.push(object);\n  serialize(\n    serializersNS,\n    nodeFactory,\n    values,\n    objectStack,\n    opt_keys,\n    opt_this\n  );\n  return /** @type {O|undefined} */ (objectStack.pop());\n}\n\nlet xmlSerializer_ = undefined;\n\n/**\n * Register a XMLSerializer. Can be used  to inject a XMLSerializer\n * where there is no globally available implementation.\n *\n * @param {XMLSerializer} xmlSerializer A XMLSerializer.\n * @api\n */\nexport function registerXMLSerializer(xmlSerializer) {\n  xmlSerializer_ = xmlSerializer;\n}\n\n/**\n * @return {XMLSerializer} The XMLSerializer.\n */\nexport function getXMLSerializer() {\n  if (xmlSerializer_ === undefined && typeof XMLSerializer !== 'undefined') {\n    xmlSerializer_ = new XMLSerializer();\n  }\n  return xmlSerializer_;\n}\n\nlet document_ = undefined;\n\n/**\n * Register a Document to use when creating nodes for XML serializations. Can be used\n * to inject a Document where there is no globally available implementation.\n *\n * @param {Document} document A Document.\n * @api\n */\nexport function registerDocument(document) {\n  document_ = document;\n}\n\n/**\n * Get a document that should be used when creating nodes for XML serializations.\n * @return {Document} The document.\n */\nexport function getDocument() {\n  if (document_ === undefined && typeof document !== 'undefined') {\n    document_ = document.implementation.createDocument('', '', null);\n  }\n  return document_;\n}\n","/**\n * @module ol/format/xsd\n */\nimport {getAllTextContent, getDocument} from '../xml.js';\nimport {padNumber} from '../string.js';\n\n/**\n * @param {Node} node Node.\n * @return {boolean|undefined} Boolean.\n */\nexport function readBoolean(node) {\n  const s = getAllTextContent(node, false);\n  return readBooleanString(s);\n}\n\n/**\n * @param {string} string String.\n * @return {boolean|undefined} Boolean.\n */\nexport function readBooleanString(string) {\n  const m = /^\\s*(true|1)|(false|0)\\s*$/.exec(string);\n  if (m) {\n    return m[1] !== undefined || false;\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * @param {Node} node Node.\n * @return {number|undefined} DateTime in seconds.\n */\nexport function readDateTime(node) {\n  const s = getAllTextContent(node, false);\n  const dateTime = Date.parse(s);\n  return isNaN(dateTime) ? undefined : dateTime / 1000;\n}\n\n/**\n * @param {Node} node Node.\n * @return {number|undefined} Decimal.\n */\nexport function readDecimal(node) {\n  const s = getAllTextContent(node, false);\n  return readDecimalString(s);\n}\n\n/**\n * @param {string} string String.\n * @return {number|undefined} Decimal.\n */\nexport function readDecimalString(string) {\n  // FIXME check spec\n  const m = /^\\s*([+\\-]?\\d*\\.?\\d+(?:e[+\\-]?\\d+)?)\\s*$/i.exec(string);\n  if (m) {\n    return parseFloat(m[1]);\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * @param {Node} node Node.\n * @return {number|undefined} Non negative integer.\n */\nexport function readNonNegativeInteger(node) {\n  const s = getAllTextContent(node, false);\n  return readNonNegativeIntegerString(s);\n}\n\n/**\n * @param {string} string String.\n * @return {number|undefined} Non negative integer.\n */\nexport function readNonNegativeIntegerString(string) {\n  const m = /^\\s*(\\d+)\\s*$/.exec(string);\n  if (m) {\n    return parseInt(m[1], 10);\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * @param {Node} node Node.\n * @return {string|undefined} String.\n */\nexport function readString(node) {\n  return getAllTextContent(node, false).trim();\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the boolean to.\n * @param {boolean} bool Boolean.\n */\nexport function writeBooleanTextNode(node, bool) {\n  writeStringTextNode(node, bool ? '1' : '0');\n}\n\n/**\n * @param {Node} node Node to append a CDATA Section with the string to.\n * @param {string} string String.\n */\nexport function writeCDATASection(node, string) {\n  node.appendChild(getDocument().createCDATASection(string));\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the dateTime to.\n * @param {number} dateTime DateTime in seconds.\n */\nexport function writeDateTimeTextNode(node, dateTime) {\n  const date = new Date(dateTime * 1000);\n  const string =\n    date.getUTCFullYear() +\n    '-' +\n    padNumber(date.getUTCMonth() + 1, 2) +\n    '-' +\n    padNumber(date.getUTCDate(), 2) +\n    'T' +\n    padNumber(date.getUTCHours(), 2) +\n    ':' +\n    padNumber(date.getUTCMinutes(), 2) +\n    ':' +\n    padNumber(date.getUTCSeconds(), 2) +\n    'Z';\n  node.appendChild(getDocument().createTextNode(string));\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the decimal to.\n * @param {number} decimal Decimal.\n */\nexport function writeDecimalTextNode(node, decimal) {\n  const string = decimal.toPrecision();\n  node.appendChild(getDocument().createTextNode(string));\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the decimal to.\n * @param {number} nonNegativeInteger Non negative integer.\n */\nexport function writeNonNegativeIntegerTextNode(node, nonNegativeInteger) {\n  const string = nonNegativeInteger.toString();\n  node.appendChild(getDocument().createTextNode(string));\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the string to.\n * @param {string} string String.\n */\nexport function writeStringTextNode(node, string) {\n  node.appendChild(getDocument().createTextNode(string));\n}\n","/**\n * @module ol/geom/GeometryCollection\n */\nimport EventType from '../events/EventType.js';\nimport Geometry from './Geometry.js';\nimport GeometryType from './GeometryType.js';\nimport {\n  closestSquaredDistanceXY,\n  createOrUpdateEmpty,\n  extend,\n  getCenter,\n} from '../extent.js';\nimport {listen, unlistenByKey} from '../events.js';\n\n/**\n * @classdesc\n * An array of {@link module:ol/geom/Geometry} objects.\n *\n * @api\n */\nclass GeometryCollection extends Geometry {\n  /**\n   * @param {Array<Geometry>} [opt_geometries] Geometries.\n   */\n  constructor(opt_geometries) {\n    super();\n\n    /**\n     * @private\n     * @type {Array<Geometry>}\n     */\n    this.geometries_ = opt_geometries ? opt_geometries : null;\n\n    /**\n     * @type {Array<import(\"../events.js\").EventsKey>}\n     */\n    this.changeEventsKeys_ = [];\n\n    this.listenGeometriesChange_();\n  }\n\n  /**\n   * @private\n   */\n  unlistenGeometriesChange_() {\n    this.changeEventsKeys_.forEach(unlistenByKey);\n    this.changeEventsKeys_.length = 0;\n  }\n\n  /**\n   * @private\n   */\n  listenGeometriesChange_() {\n    if (!this.geometries_) {\n      return;\n    }\n    for (let i = 0, ii = this.geometries_.length; i < ii; ++i) {\n      this.changeEventsKeys_.push(\n        listen(this.geometries_[i], EventType.CHANGE, this.changed, this)\n      );\n    }\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!GeometryCollection} Clone.\n   * @api\n   */\n  clone() {\n    const geometryCollection = new GeometryCollection(null);\n    geometryCollection.setGeometries(this.geometries_);\n    geometryCollection.applyProperties(this);\n    return geometryCollection;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      minSquaredDistance = geometries[i].closestPointXY(\n        x,\n        y,\n        closestPoint,\n        minSquaredDistance\n      );\n    }\n    return minSquaredDistance;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @return {boolean} Contains (x, y).\n   */\n  containsXY(x, y) {\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      if (geometries[i].containsXY(x, y)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @protected\n   * @return {import(\"../extent.js\").Extent} extent Extent.\n   */\n  computeExtent(extent) {\n    createOrUpdateEmpty(extent);\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      extend(extent, geometries[i].getExtent());\n    }\n    return extent;\n  }\n\n  /**\n   * Return the geometries that make up this geometry collection.\n   * @return {Array<Geometry>} Geometries.\n   * @api\n   */\n  getGeometries() {\n    return cloneGeometries(this.geometries_);\n  }\n\n  /**\n   * @return {Array<Geometry>} Geometries.\n   */\n  getGeometriesArray() {\n    return this.geometries_;\n  }\n\n  /**\n   * @return {Array<Geometry>} Geometries.\n   */\n  getGeometriesArrayRecursive() {\n    /** @type {Array<Geometry>} */\n    let geometriesArray = [];\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      if (geometries[i].getType() === this.getType()) {\n        geometriesArray = geometriesArray.concat(\n          /** @type {GeometryCollection} */ (geometries[\n            i\n          ]).getGeometriesArrayRecursive()\n        );\n      } else {\n        geometriesArray.push(geometries[i]);\n      }\n    }\n    return geometriesArray;\n  }\n\n  /**\n   * Create a simplified version of this geometry using the Douglas Peucker algorithm.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {GeometryCollection} Simplified GeometryCollection.\n   */\n  getSimplifiedGeometry(squaredTolerance) {\n    if (this.simplifiedGeometryRevision !== this.getRevision()) {\n      this.simplifiedGeometryMaxMinSquaredTolerance = 0;\n      this.simplifiedGeometryRevision = this.getRevision();\n    }\n    if (\n      squaredTolerance < 0 ||\n      (this.simplifiedGeometryMaxMinSquaredTolerance !== 0 &&\n        squaredTolerance < this.simplifiedGeometryMaxMinSquaredTolerance)\n    ) {\n      return this;\n    }\n\n    const simplifiedGeometries = [];\n    const geometries = this.geometries_;\n    let simplified = false;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      const geometry = geometries[i];\n      const simplifiedGeometry = geometry.getSimplifiedGeometry(\n        squaredTolerance\n      );\n      simplifiedGeometries.push(simplifiedGeometry);\n      if (simplifiedGeometry !== geometry) {\n        simplified = true;\n      }\n    }\n    if (simplified) {\n      const simplifiedGeometryCollection = new GeometryCollection(null);\n      simplifiedGeometryCollection.setGeometriesArray(simplifiedGeometries);\n      return simplifiedGeometryCollection;\n    } else {\n      this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;\n      return this;\n    }\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./GeometryType.js\").default} Geometry type.\n   * @api\n   */\n  getType() {\n    return GeometryType.GEOMETRY_COLLECTION;\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   */\n  intersectsExtent(extent) {\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      if (geometries[i].intersectsExtent(extent)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @return {boolean} Is empty.\n   */\n  isEmpty() {\n    return this.geometries_.length === 0;\n  }\n\n  /**\n   * Rotate the geometry around a given coordinate. This modifies the geometry\n   * coordinates in place.\n   * @param {number} angle Rotation angle in radians.\n   * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\n   * @api\n   */\n  rotate(angle, anchor) {\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      geometries[i].rotate(angle, anchor);\n    }\n    this.changed();\n  }\n\n  /**\n   * Scale the geometry (with an optional origin).  This modifies the geometry\n   * coordinates in place.\n   * @abstract\n   * @param {number} sx The scaling factor in the x-direction.\n   * @param {number} [opt_sy] The scaling factor in the y-direction (defaults to sx).\n   * @param {import(\"../coordinate.js\").Coordinate} [opt_anchor] The scale origin (defaults to the center\n   *     of the geometry extent).\n   * @api\n   */\n  scale(sx, opt_sy, opt_anchor) {\n    let anchor = opt_anchor;\n    if (!anchor) {\n      anchor = getCenter(this.getExtent());\n    }\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      geometries[i].scale(sx, opt_sy, anchor);\n    }\n    this.changed();\n  }\n\n  /**\n   * Set the geometries that make up this geometry collection.\n   * @param {Array<Geometry>} geometries Geometries.\n   * @api\n   */\n  setGeometries(geometries) {\n    this.setGeometriesArray(cloneGeometries(geometries));\n  }\n\n  /**\n   * @param {Array<Geometry>} geometries Geometries.\n   */\n  setGeometriesArray(geometries) {\n    this.unlistenGeometriesChange_();\n    this.geometries_ = geometries;\n    this.listenGeometriesChange_();\n    this.changed();\n  }\n\n  /**\n   * Apply a transform function to the coordinates of the geometry.\n   * The geometry is modified in place.\n   * If you do not want the geometry modified in place, first `clone()` it and\n   * then use this function on the clone.\n   * @param {import(\"../proj.js\").TransformFunction} transformFn Transform function.\n   * Called with a flat array of geometry coordinates.\n   * @api\n   */\n  applyTransform(transformFn) {\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      geometries[i].applyTransform(transformFn);\n    }\n    this.changed();\n  }\n\n  /**\n   * Translate the geometry.  This modifies the geometry coordinates in place.  If\n   * instead you want a new geometry, first `clone()` this geometry.\n   * @param {number} deltaX Delta X.\n   * @param {number} deltaY Delta Y.\n   * @api\n   */\n  translate(deltaX, deltaY) {\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      geometries[i].translate(deltaX, deltaY);\n    }\n    this.changed();\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    this.unlistenGeometriesChange_();\n    super.disposeInternal();\n  }\n}\n\n/**\n * @param {Array<Geometry>} geometries Geometries.\n * @return {Array<Geometry>} Cloned geometries.\n */\nfunction cloneGeometries(geometries) {\n  const clonedGeometries = [];\n  for (let i = 0, ii = geometries.length; i < ii; ++i) {\n    clonedGeometries.push(geometries[i].clone());\n  }\n  return clonedGeometries;\n}\n\nexport default GeometryCollection;\n"],"names":["$76e99b295c09c7c5e340e251e89879b1$export$e3e368afaf9a4fc7","_super","VectorSourceEvent","type","opt_feature","opt_features","_this","call","this","feature","features","$76e99b295c09c7c5e340e251e89879b1$var$__extends","$0qSof","default","$76e99b295c09c7c5e340e251e89879b1$export$9099ad97b570f7c","VectorSource","opt_options","options","attributions","projection","undefined","state","$4atwc","READY","wrapX","loader_","$4nF2G","VOID","format_","format","overlaps_","overlaps","url_","url","loader","$1mHUI","assert","$1qBP9","xhr","strategy_","strategy","$1b3V9","all","collection","useSpatialIndex","featuresRtree_","$6Utth","loadedExtentsRtree_","loadingExtentsCount_","nullGeometryFeatures_","idIndex_","uidIndex_","featureChangeKeys_","featuresCollection_","Array","isArray","getArray","$71dVn","addFeaturesInternal","bindFeaturesCollection_","prototype","addFeature","addFeatureInternal","changed","featureKey","$6fegY","getUid","addToIndex_","setupChangeEvents_","geometry","getGeometry","extent","getExtent","insert","dispatchEvent","$2irPz","ADDFEATURE","remove","$3H2uZ","listen","$65ADj","CHANGE","handleFeatureChange_","$5PWvX","PROPERTYCHANGE","valid","id","getId","toString","addFeatures","extents","newFeatures","geometryFeatures","i","length_1","length","push","length_2","load","length_3","modifyingCollection","addEventListener","evt","REMOVEFEATURE","$4FhyO","ADD","element","bind","REMOVE","removeFeature","clear","opt_fast","featureId","forEach","unlistenByKey","removeFeatureInternal","clearEvent","CLEAR","forEachFeature","callback","forEachFeatureAtCoordinateDirect","coordinate","forEachFeatureInExtent","intersectsCoordinate","forEachInExtent","forEachFeatureIntersectingExtent","intersectsExtent","result","getFeaturesCollection","getFeatures","slice","getAll","$6RQ94","isEmpty","$3MevS","extend","getValues","getFeaturesAtCoordinate","getFeaturesInExtent","getInExtent","getClosestFeatureToCoordinate","opt_filter","x","y","closestFeature","closestPoint","NaN","minSquaredDistance","Infinity","filter","TRUE","previousMinSquaredDistance","closestPointXY","minDistance","Math","sqrt","opt_extent","getFeatureById","getFeatureByUid","uid","getFormat","getOverlaps","getUrl","event","target","update","sid","removeFromIdIndex_","CHANGEFEATURE","hasFeature","loadFeatures","resolution","loadedExtentsRtree","extentsToLoad","ii","extentToLoad","object","$4lmw7","containsExtent","this_1","FEATURESLOADSTART","FEATURESLOADEND","FEATURESLOADERROR","loading","refresh","removeLoadedExtent","obj","equals","removed","setLoader","setUrl","$3f7LD","$e311f93de68f58225dfc37d89d1dcffc$export$9099ad97b570f7c","RBush","opt_maxEntries","rbush_","$parcel$interopDefault","$51t4G","items_","value","item","minX","minY","maxX","maxY","values","items","l","bbox","map","search","forEach_","data","toJSON","createOrUpdate","concat","rbush","$4b7d9e079415657c49d05e16783d2ed4$export$9099ad97b570f7c","$26b846260444bc742bddf88d96721338$export$8dbdea330bbd6b3c","$2ef5772bb5b0926a9ba82fc2a88f3163$var$withCredentials","$2ef5772bb5b0926a9ba82fc2a88f3163$export$52988233cf090939","success","failure","source","XMLHttpRequest","open","getType","$6SnQ2","ARRAY_BUFFER","responseType","withCredentials","onload","status","JSON","TEXT","responseText","XML","responseXML","DOMParser","parseFromString","response","readFeatures","featureProjection","readProjection","onerror","send","$2ef5772bb5b0926a9ba82fc2a88f3163$export$4355fa6d12274ca5","dataProjection","$e1f6506982452a68a8aaa230bb78068a$export$9099ad97b570f7c","$fe05caf5f991aea82bd67c9bebabc467$export$7cf753b6a6534915","styles_1","getZIndex","$fe05caf5f991aea82bd67c9bebabc467$export$9099ad97b570f7c","Feature","opt_geometryOrProperties","id_","geometryName_","style_","styleFunction_","geometryChangeKey_","$4ZHam","getChangeEventType","handleGeometryChanged_","getSimplifiedGeometry","setGeometry","properties","setProperties","$fe05caf5f991aea82bd67c9bebabc467$var$__extends","clone","hasProperties","getProperties","setGeometryName","getGeometryName","style","getStyle","setStyle","get","getStyleFunction","handleGeometryChange_","set","opt_style","setId","name","removeEventListener","$f3208b74dbadea817236410092d4ed69$export$9099ad97b570f7c","LineString","coordinates","opt_layout","flatMidpoint_","flatMidpointRevision_","maxDelta_","maxDeltaRevision_","setCoordinates","setFlatCoordinates","$f3208b74dbadea817236410092d4ed69$var$__extends","appendCoordinate","flatCoordinates","lineString","layout","applyProperties","closestSquaredDistanceXY","getRevision","$3QyYH","maxSquaredDelta","stride","assignClosestPoint","forEachSegment","$1ZN49","getCoordinateAtM","m","opt_extrapolate","$3dG11","XYM","XYZM","extrapolate","$GvdFY","lineStringCoordinateAtM","getCoordinates","$5X4hW","inflateCoordinates","getCoordinateAt","fraction","opt_dest","interpolatePoint","getLength","$5QB2H","lineStringLength","getFlatMidpoint","getSimplifiedGeometryInternal","squaredTolerance","simplifiedFlatCoordinates","$4YdW9","douglasPeucker","XY","$1gVIf","LINE_STRING","$1xC0k","intersectsLineString","setLayout","$6X6IT","deflateCoordinates","$2FGG8","$168654b72fccbd53f77518b62ff915e1$export$55be7a9e3fef4787","offset","end","opt_dimension","o","t","n","x1","y1","cumulativeLengths","x2","y2","index","binarySearch","dimension","dest","$4qq0p","lerp","$168654b72fccbd53f77518b62ff915e1$export$1a804b04fa5a0253","lo","hi","mid","m0","$168654b72fccbd53f77518b62ff915e1$export$8958f67b085a89b1","ends","interpolate","$9cc45ed4bf6c6f99d7b74c7015645e2b$export$9099ad97b570f7c","MultiLineString","opt_ends","ends_","getLayout","lineStrings","getFlatCoordinates","$9cc45ed4bf6c6f99d7b74c7015645e2b$var$__extends","appendLineString","multiLineString","arrayMaxSquaredDelta","assignClosestArrayPoint","opt_interpolate","lineStringsCoordinateAtM","inflateCoordinatesArray","getEnds","getLineString","$7oM0w","getLineStrings","getFlatMidpoints","midpoints","midpoint","simplifiedEnds","douglasPeuckerArray","MULTI_LINE_STRING","intersectsLineStringArray","deflateCoordinatesArray","$dec84ce654dad439cc55f11914ce0714$export$9099ad97b570f7c","XMLFeature","xmlSerializer_","$6u7wO","getXMLSerializer","$dec84ce654dad439cc55f11914ce0714$var$__extends","readFeature","doc","parse","readFeatureFromDocument","isDocument","readFeatureFromNode","readFeaturesFromDocument","node","readFeaturesFromNode","firstChild","nextSibling","nodeType","Node","ELEMENT_NODE","abstract","readGeometry","readGeometryFromDocument","readGeometryFromNode","readProjectionFromDocument","readProjectionFromNode","writeFeature","writeFeatureNode","serializeToString","writeFeatures","writeFeaturesNode","writeGeometry","writeGeometryNode","$2rUWQ","$508255911b6472d9d16e9a97599ab01e$export$9099ad97b570f7c","FeatureFormat","defaultFeatureProjection","getReadOptions","$2vjin","getUnits","$6MSva","TILE_PIXELS","setWorldExtent","adaptOptions","assign","$508255911b6472d9d16e9a97599ab01e$export$534b7b915a5ec453","write","transformed","equivalent","transform","decimals","power_1","pow","applyTransform","round","$d51a9db7ffbc5351b0298bfe2864dc58$export$f6c9fc7378d5d6a6","$d51a9db7ffbc5351b0298bfe2864dc58$export$a5039740b67a9c","namespaceURI","qualifiedName","$d51a9db7ffbc5351b0298bfe2864dc58$export$46d2d1e7bcdd99a3","createElementNS","$d51a9db7ffbc5351b0298bfe2864dc58$export$4131dc4da57aa0c8","normalizeWhitespace","$d51a9db7ffbc5351b0298bfe2864dc58$export$970c25ea2962a3d2","join","accumulator","CDATA_SECTION_NODE","TEXT_NODE","String","nodeValue","replace","$d51a9db7ffbc5351b0298bfe2864dc58$export$77e37c6e8311f1ce","$d51a9db7ffbc5351b0298bfe2864dc58$export$a43e9d683f52ab7c","xml","$d51a9db7ffbc5351b0298bfe2864dc58$export$c9b84e3d2c8a2745","valueReader","opt_this","objectStack","array","$d51a9db7ffbc5351b0298bfe2864dc58$export$5a6c4415b7f496d8","$d51a9db7ffbc5351b0298bfe2864dc58$export$a228533eec35683a","$d51a9db7ffbc5351b0298bfe2864dc58$export$73d853215f0c71e8","opt_property","localName","$d51a9db7ffbc5351b0298bfe2864dc58$export$2deb56b7ae029e3","nodeWriter","appendChild","$d51a9db7ffbc5351b0298bfe2864dc58$export$3a8407fea04ebe5f","serializersNS","nodeFactory","serializers","$d51a9db7ffbc5351b0298bfe2864dc58$export$8ebe38e76aa85d36","$d51a9db7ffbc5351b0298bfe2864dc58$export$2e67c97dae900dc9","opt_nodeName","opt_namespaceURI","fixedNodeName","opt_nodeName1","nodeName","$d51a9db7ffbc5351b0298bfe2864dc58$export$81a68ea3ed99d298","$d51a9db7ffbc5351b0298bfe2864dc58$export$56f187f00ba8a12b","orderedKeys","sequence","$d51a9db7ffbc5351b0298bfe2864dc58$export$7567597de432f7e7","namespaceURIs","structure","opt_structureNS","structureNS","$d51a9db7ffbc5351b0298bfe2864dc58$export$d2d9da5f39026f12","parsersNS","firstElementChild","nextElementSibling","parsers","parser","$d51a9db7ffbc5351b0298bfe2864dc58$export$606fcd4c4e16fe20","pop","opt_keys","$d51a9db7ffbc5351b0298bfe2864dc58$export$cfa8ff2fe3336fdf","$d51a9db7ffbc5351b0298bfe2864dc58$var$xmlSerializer_","$d51a9db7ffbc5351b0298bfe2864dc58$export$9dbe9ee05a7dfce3","XMLSerializer","$d51a9db7ffbc5351b0298bfe2864dc58$var$document_","document","implementation","createDocument","$90d80a364a39de433c7f5cd490d4f896$export$2d9b5243090e006a","s","getAllTextContent","exec","$90d80a364a39de433c7f5cd490d4f896$export$e677ee4949375ba1","dateTime","Date","isNaN","$90d80a364a39de433c7f5cd490d4f896$export$39fa0db44f151f9d","parseFloat","$90d80a364a39de433c7f5cd490d4f896$export$1840c252c524643f","parseInt","$90d80a364a39de433c7f5cd490d4f896$export$286b7b22a1a791c7","trim","$90d80a364a39de433c7f5cd490d4f896$export$bbbe78f39d89b09c","bool","$90d80a364a39de433c7f5cd490d4f896$export$8546427d900bb9d0","$90d80a364a39de433c7f5cd490d4f896$export$53afd9ae5847fbf6","string","getDocument","createCDATASection","$90d80a364a39de433c7f5cd490d4f896$export$f902c1d17808b7b1","date","getUTCFullYear","$4MLc1","padNumber","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","createTextNode","$90d80a364a39de433c7f5cd490d4f896$export$3ff1a647d173b6de","decimal","toPrecision","$90d80a364a39de433c7f5cd490d4f896$export$ba7d4076978bd372","nonNegativeInteger","$8af1af76f23419d9d724a1b0182ffb00$var$cloneGeometries","geometries","clonedGeometries","$8af1af76f23419d9d724a1b0182ffb00$export$9099ad97b570f7c","GeometryCollection","opt_geometries","geometries_","changeEventsKeys_","listenGeometriesChange_","$8af1af76f23419d9d724a1b0182ffb00$var$__extends","unlistenGeometriesChange_","geometryCollection","setGeometries","containsXY","computeExtent","createOrUpdateEmpty","getGeometries","getGeometriesArray","getGeometriesArrayRecursive","geometriesArray","simplifiedGeometryRevision","simplifiedGeometryMaxMinSquaredTolerance","simplifiedGeometries","simplified","simplifiedGeometry","simplifiedGeometryCollection","setGeometriesArray","GEOMETRY_COLLECTION","rotate","angle","anchor","scale","sx","opt_sy","opt_anchor","getCenter","transformFn","translate","deltaX","deltaY","disposeInternal","$4UIww"],"version":3,"file":"mixed-renderers.88cf3e0b.js.map"}