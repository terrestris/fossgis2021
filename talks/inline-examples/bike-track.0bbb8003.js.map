{"mappings":"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","sources":["node_modules/@parcel/runtime-js/lib/bundle-manifest.js","node_modules/@parcel/runtime-js/lib/runtime-a05ed794474cb8167fbedb1b64395228.js","node_modules/ol/src/format/GPX.js","node_modules/ol/src/layer/TileProperty.js","node_modules/ol/src/layer/BaseTile.js","node_modules/ol/src/TileRange.js","node_modules/ol/src/renderer/canvas/TileLayer.js","node_modules/ol/src/layer/Tile.js","node_modules/ol/src/Tile.js","node_modules/ol/src/ImageTile.js","node_modules/ol/src/reproj.js","node_modules/ol/src/reproj/Triangulation.js","node_modules/ol/src/source/common.js","node_modules/ol/src/reproj/Tile.js","node_modules/ol/src/reproj/common.js","node_modules/ol/src/structs/LRUCache.js","node_modules/ol/src/tilecoord.js","node_modules/ol/src/TileCache.js","node_modules/ol/src/source/TileEventType.js","node_modules/ol/src/tilegrid/TileGrid.js","node_modules/ol/src/tilegrid.js","node_modules/ol/src/source/Tile.js","node_modules/ol/src/tileurlfunction.js","node_modules/ol/src/source/UrlTile.js","node_modules/ol/src/source/TileImage.js","node_modules/ol/src/source/XYZ.js","node_modules/ol/src/source/OSM.js","node_modules/@parcel/runtime-js/lib/bundle-url.js","node_modules/@parcel/runtime-js/lib/relative-path.js","node_modules/@parcel/runtime-js/lib/runtime-16d2dfb7f907fe6a1af8faa8e93126a0.js","src/bike-track.js","node_modules/ol/src/render.js"],"sourcesContent":["\"use strict\";\n\nvar mapping = {};\n\nfunction register(pairs) {\n  var keys = Object.keys(pairs);\n\n  for (var i = 0; i < keys.length; i++) {\n    mapping[keys[i]] = pairs[keys[i]];\n  }\n}\n\nfunction resolve(id) {\n  var resolved = mapping[id];\n\n  if (resolved == null) {\n    throw new Error('Could not resolve bundle with id ' + id);\n  }\n\n  return resolved;\n}\n\nmodule.exports.register = register;\nmodule.exports.resolve = resolve;","require('./bundle-manifest').register(JSON.parse(\"{\\\"6dNpu\\\":\\\"bike-track.0bbb8003.js\\\",\\\"54TNJ\\\":\\\"backhendl.fad54c65.gpx\\\",\\\"0acRd\\\":\\\"mixed-renderers.7620afdc.css\\\",\\\"39l4W\\\":\\\"mixed-renderers.88cf3e0b.js\\\"}\"));","/**\n * @module ol/format/GPX\n */\nimport Feature from '../Feature.js';\nimport GeometryLayout from '../geom/GeometryLayout.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport Point from '../geom/Point.js';\nimport XMLFeature from './XMLFeature.js';\nimport {\n  OBJECT_PROPERTY_NODE_FACTORY,\n  XML_SCHEMA_INSTANCE_URI,\n  createElementNS,\n  makeArrayPusher,\n  makeArraySerializer,\n  makeChildAppender,\n  makeObjectPropertySetter,\n  makeSequence,\n  makeSimpleNodeFactory,\n  makeStructureNS,\n  parseNode,\n  pushParseAndPop,\n  pushSerializeAndPop,\n} from '../xml.js';\nimport {get as getProjection} from '../proj.js';\nimport {includes} from '../array.js';\nimport {\n  readDateTime,\n  readDecimal,\n  readNonNegativeInteger,\n  readString,\n  writeDateTimeTextNode,\n  writeDecimalTextNode,\n  writeNonNegativeIntegerTextNode,\n  writeStringTextNode,\n} from './xsd.js';\nimport {transformGeometryWithOptions} from './Feature.js';\n\n/**\n * @const\n * @type {Array<null|string>}\n */\nconst NAMESPACE_URIS = [\n  null,\n  'http://www.topografix.com/GPX/1/0',\n  'http://www.topografix.com/GPX/1/1',\n];\n\n/**\n * @const\n * @type {string}\n */\nconst SCHEMA_LOCATION =\n  'http://www.topografix.com/GPX/1/1 ' +\n  'http://www.topografix.com/GPX/1/1/gpx.xsd';\n\n/**\n * @const\n * @type {Object<string, function(Node, Array<*>): (Feature|undefined)>}\n */\nconst FEATURE_READER = {\n  'rte': readRte,\n  'trk': readTrk,\n  'wpt': readWpt,\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst GPX_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'rte': makeArrayPusher(readRte),\n  'trk': makeArrayPusher(readTrk),\n  'wpt': makeArrayPusher(readWpt),\n});\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst LINK_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'text': makeObjectPropertySetter(readString, 'linkText'),\n  'type': makeObjectPropertySetter(readString, 'linkType'),\n});\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst GPX_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'rte': makeChildAppender(writeRte),\n  'trk': makeChildAppender(writeTrk),\n  'wpt': makeChildAppender(writeWpt),\n});\n\n/**\n * @typedef {Object} Options\n * @property {function(Feature, Node):void} [readExtensions] Callback function\n * to process `extensions` nodes. To prevent memory leaks, this callback function must\n * not store any references to the node. Note that the `extensions`\n * node is not allowed in GPX 1.0. Moreover, only `extensions`\n * nodes from `wpt`, `rte` and `trk` can be processed, as those are\n * directly mapped to a feature.\n */\n\n/**\n * @typedef {Object} LayoutOptions\n * @property {boolean} [hasZ] HasZ.\n * @property {boolean} [hasM] HasM.\n */\n\n/**\n * @classdesc\n * Feature format for reading and writing data in the GPX format.\n *\n * Note that {@link module:ol/format/GPX~GPX#readFeature} only reads the first\n * feature of the source.\n *\n * When reading, routes (`<rte>`) are converted into LineString geometries, and\n * tracks (`<trk>`) into MultiLineString. Any properties on route and track\n * waypoints are ignored.\n *\n * When writing, LineString geometries are output as routes (`<rte>`), and\n * MultiLineString as tracks (`<trk>`).\n *\n * @api\n */\nclass GPX extends XMLFeature {\n  /**\n   * @param {Options} [opt_options] Options.\n   */\n  constructor(opt_options) {\n    super();\n\n    const options = opt_options ? opt_options : {};\n\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     */\n    this.dataProjection = getProjection('EPSG:4326');\n\n    /**\n     * @type {function(Feature, Node): void|undefined}\n     * @private\n     */\n    this.readExtensions_ = options.readExtensions;\n  }\n\n  /**\n   * @param {Array<Feature>} features List of features.\n   * @private\n   */\n  handleReadExtensions_(features) {\n    if (!features) {\n      features = [];\n    }\n    for (let i = 0, ii = features.length; i < ii; ++i) {\n      const feature = features[i];\n      if (this.readExtensions_) {\n        const extensionsNode = feature.get('extensionsNode_') || null;\n        this.readExtensions_(feature, extensionsNode);\n      }\n      feature.set('extensionsNode_', undefined);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   */\n  readFeatureFromNode(node, opt_options) {\n    if (!includes(NAMESPACE_URIS, node.namespaceURI)) {\n      return null;\n    }\n    const featureReader = FEATURE_READER[node.localName];\n    if (!featureReader) {\n      return null;\n    }\n    const feature = featureReader(node, [\n      this.getReadOptions(node, opt_options),\n    ]);\n    if (!feature) {\n      return null;\n    }\n    this.handleReadExtensions_([feature]);\n    return feature;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Options.\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   */\n  readFeaturesFromNode(node, opt_options) {\n    if (!includes(NAMESPACE_URIS, node.namespaceURI)) {\n      return [];\n    }\n    if (node.localName == 'gpx') {\n      /** @type {Array<Feature>} */\n      const features = pushParseAndPop([], GPX_PARSERS, node, [\n        this.getReadOptions(node, opt_options),\n      ]);\n      if (features) {\n        this.handleReadExtensions_(features);\n        return features;\n      } else {\n        return [];\n      }\n    }\n    return [];\n  }\n\n  /**\n   * Encode an array of features in the GPX format as an XML node.\n   * LineString geometries are output as routes (`<rte>`), and MultiLineString\n   * as tracks (`<trk>`).\n   *\n   * @param {Array<Feature>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Options.\n   * @return {Node} Node.\n   * @api\n   */\n  writeFeaturesNode(features, opt_options) {\n    opt_options = this.adaptOptions(opt_options);\n    //FIXME Serialize metadata\n    const gpx = createElementNS('http://www.topografix.com/GPX/1/1', 'gpx');\n    const xmlnsUri = 'http://www.w3.org/2000/xmlns/';\n    gpx.setAttributeNS(xmlnsUri, 'xmlns:xsi', XML_SCHEMA_INSTANCE_URI);\n    gpx.setAttributeNS(\n      XML_SCHEMA_INSTANCE_URI,\n      'xsi:schemaLocation',\n      SCHEMA_LOCATION\n    );\n    gpx.setAttribute('version', '1.1');\n    gpx.setAttribute('creator', 'OpenLayers');\n\n    pushSerializeAndPop(\n      /** @type {import(\"../xml.js\").NodeStackItem} */\n      ({node: gpx}),\n      GPX_SERIALIZERS,\n      GPX_NODE_FACTORY,\n      features,\n      [opt_options]\n    );\n    return gpx;\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst RTE_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'name': makeObjectPropertySetter(readString),\n  'cmt': makeObjectPropertySetter(readString),\n  'desc': makeObjectPropertySetter(readString),\n  'src': makeObjectPropertySetter(readString),\n  'link': parseLink,\n  'number': makeObjectPropertySetter(readNonNegativeInteger),\n  'extensions': parseExtensions,\n  'type': makeObjectPropertySetter(readString),\n  'rtept': parseRtePt,\n});\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst RTEPT_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'ele': makeObjectPropertySetter(readDecimal),\n  'time': makeObjectPropertySetter(readDateTime),\n});\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst TRK_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'name': makeObjectPropertySetter(readString),\n  'cmt': makeObjectPropertySetter(readString),\n  'desc': makeObjectPropertySetter(readString),\n  'src': makeObjectPropertySetter(readString),\n  'link': parseLink,\n  'number': makeObjectPropertySetter(readNonNegativeInteger),\n  'type': makeObjectPropertySetter(readString),\n  'extensions': parseExtensions,\n  'trkseg': parseTrkSeg,\n});\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst TRKSEG_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'trkpt': parseTrkPt,\n});\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst TRKPT_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'ele': makeObjectPropertySetter(readDecimal),\n  'time': makeObjectPropertySetter(readDateTime),\n});\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst WPT_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'ele': makeObjectPropertySetter(readDecimal),\n  'time': makeObjectPropertySetter(readDateTime),\n  'magvar': makeObjectPropertySetter(readDecimal),\n  'geoidheight': makeObjectPropertySetter(readDecimal),\n  'name': makeObjectPropertySetter(readString),\n  'cmt': makeObjectPropertySetter(readString),\n  'desc': makeObjectPropertySetter(readString),\n  'src': makeObjectPropertySetter(readString),\n  'link': parseLink,\n  'sym': makeObjectPropertySetter(readString),\n  'type': makeObjectPropertySetter(readString),\n  'fix': makeObjectPropertySetter(readString),\n  'sat': makeObjectPropertySetter(readNonNegativeInteger),\n  'hdop': makeObjectPropertySetter(readDecimal),\n  'vdop': makeObjectPropertySetter(readDecimal),\n  'pdop': makeObjectPropertySetter(readDecimal),\n  'ageofdgpsdata': makeObjectPropertySetter(readDecimal),\n  'dgpsid': makeObjectPropertySetter(readNonNegativeInteger),\n  'extensions': parseExtensions,\n});\n\n/**\n * @const\n * @type {Array<string>}\n */\nconst LINK_SEQUENCE = ['text', 'type'];\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst LINK_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'text': makeChildAppender(writeStringTextNode),\n  'type': makeChildAppender(writeStringTextNode),\n});\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nconst RTE_SEQUENCE = makeStructureNS(NAMESPACE_URIS, [\n  'name',\n  'cmt',\n  'desc',\n  'src',\n  'link',\n  'number',\n  'type',\n  'rtept',\n]);\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst RTE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'name': makeChildAppender(writeStringTextNode),\n  'cmt': makeChildAppender(writeStringTextNode),\n  'desc': makeChildAppender(writeStringTextNode),\n  'src': makeChildAppender(writeStringTextNode),\n  'link': makeChildAppender(writeLink),\n  'number': makeChildAppender(writeNonNegativeIntegerTextNode),\n  'type': makeChildAppender(writeStringTextNode),\n  'rtept': makeArraySerializer(makeChildAppender(writeWptType)),\n});\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nconst RTEPT_TYPE_SEQUENCE = makeStructureNS(NAMESPACE_URIS, ['ele', 'time']);\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nconst TRK_SEQUENCE = makeStructureNS(NAMESPACE_URIS, [\n  'name',\n  'cmt',\n  'desc',\n  'src',\n  'link',\n  'number',\n  'type',\n  'trkseg',\n]);\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst TRK_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'name': makeChildAppender(writeStringTextNode),\n  'cmt': makeChildAppender(writeStringTextNode),\n  'desc': makeChildAppender(writeStringTextNode),\n  'src': makeChildAppender(writeStringTextNode),\n  'link': makeChildAppender(writeLink),\n  'number': makeChildAppender(writeNonNegativeIntegerTextNode),\n  'type': makeChildAppender(writeStringTextNode),\n  'trkseg': makeArraySerializer(makeChildAppender(writeTrkSeg)),\n});\n\n/**\n * @const\n * @type {function(*, Array<*>, string=): (Node|undefined)}\n */\nconst TRKSEG_NODE_FACTORY = makeSimpleNodeFactory('trkpt');\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst TRKSEG_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'trkpt': makeChildAppender(writeWptType),\n});\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nconst WPT_TYPE_SEQUENCE = makeStructureNS(NAMESPACE_URIS, [\n  'ele',\n  'time',\n  'magvar',\n  'geoidheight',\n  'name',\n  'cmt',\n  'desc',\n  'src',\n  'link',\n  'sym',\n  'type',\n  'fix',\n  'sat',\n  'hdop',\n  'vdop',\n  'pdop',\n  'ageofdgpsdata',\n  'dgpsid',\n]);\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst WPT_TYPE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'ele': makeChildAppender(writeDecimalTextNode),\n  'time': makeChildAppender(writeDateTimeTextNode),\n  'magvar': makeChildAppender(writeDecimalTextNode),\n  'geoidheight': makeChildAppender(writeDecimalTextNode),\n  'name': makeChildAppender(writeStringTextNode),\n  'cmt': makeChildAppender(writeStringTextNode),\n  'desc': makeChildAppender(writeStringTextNode),\n  'src': makeChildAppender(writeStringTextNode),\n  'link': makeChildAppender(writeLink),\n  'sym': makeChildAppender(writeStringTextNode),\n  'type': makeChildAppender(writeStringTextNode),\n  'fix': makeChildAppender(writeStringTextNode),\n  'sat': makeChildAppender(writeNonNegativeIntegerTextNode),\n  'hdop': makeChildAppender(writeDecimalTextNode),\n  'vdop': makeChildAppender(writeDecimalTextNode),\n  'pdop': makeChildAppender(writeDecimalTextNode),\n  'ageofdgpsdata': makeChildAppender(writeDecimalTextNode),\n  'dgpsid': makeChildAppender(writeNonNegativeIntegerTextNode),\n});\n\n/**\n * @const\n * @type {Object<string, string>}\n */\nconst GEOMETRY_TYPE_TO_NODENAME = {\n  'Point': 'wpt',\n  'LineString': 'rte',\n  'MultiLineString': 'trk',\n};\n\n/**\n * @param {*} value Value.\n * @param {Array<*>} objectStack Object stack.\n * @param {string} [opt_nodeName] Node name.\n * @return {Node|undefined} Node.\n */\nfunction GPX_NODE_FACTORY(value, objectStack, opt_nodeName) {\n  const geometry = /** @type {Feature} */ (value).getGeometry();\n  if (geometry) {\n    const nodeName = GEOMETRY_TYPE_TO_NODENAME[geometry.getType()];\n    if (nodeName) {\n      const parentNode = objectStack[objectStack.length - 1].node;\n      return createElementNS(parentNode.namespaceURI, nodeName);\n    }\n  }\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {LayoutOptions} layoutOptions Layout options.\n * @param {Element} node Node.\n * @param {!Object} values Values.\n * @return {Array<number>} Flat coordinates.\n */\nfunction appendCoordinate(flatCoordinates, layoutOptions, node, values) {\n  flatCoordinates.push(\n    parseFloat(node.getAttribute('lon')),\n    parseFloat(node.getAttribute('lat'))\n  );\n  if ('ele' in values) {\n    flatCoordinates.push(/** @type {number} */ (values['ele']));\n    delete values['ele'];\n    layoutOptions.hasZ = true;\n  } else {\n    flatCoordinates.push(0);\n  }\n  if ('time' in values) {\n    flatCoordinates.push(/** @type {number} */ (values['time']));\n    delete values['time'];\n    layoutOptions.hasM = true;\n  } else {\n    flatCoordinates.push(0);\n  }\n  return flatCoordinates;\n}\n\n/**\n * Choose GeometryLayout based on flags in layoutOptions and adjust flatCoordinates\n * and ends arrays by shrinking them accordingly (removing unused zero entries).\n *\n * @param {LayoutOptions} layoutOptions Layout options.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {Array<number>} [ends] Ends.\n * @return {import(\"../geom/GeometryLayout.js\").default} Layout.\n */\nfunction applyLayoutOptions(layoutOptions, flatCoordinates, ends) {\n  let layout = GeometryLayout.XY;\n  let stride = 2;\n  if (layoutOptions.hasZ && layoutOptions.hasM) {\n    layout = GeometryLayout.XYZM;\n    stride = 4;\n  } else if (layoutOptions.hasZ) {\n    layout = GeometryLayout.XYZ;\n    stride = 3;\n  } else if (layoutOptions.hasM) {\n    layout = GeometryLayout.XYM;\n    stride = 3;\n  }\n  if (stride !== 4) {\n    for (let i = 0, ii = flatCoordinates.length / 4; i < ii; i++) {\n      flatCoordinates[i * stride] = flatCoordinates[i * 4];\n      flatCoordinates[i * stride + 1] = flatCoordinates[i * 4 + 1];\n      if (layoutOptions.hasZ) {\n        flatCoordinates[i * stride + 2] = flatCoordinates[i * 4 + 2];\n      }\n      if (layoutOptions.hasM) {\n        flatCoordinates[i * stride + 2] = flatCoordinates[i * 4 + 3];\n      }\n    }\n    flatCoordinates.length = (flatCoordinates.length / 4) * stride;\n    if (ends) {\n      for (let i = 0, ii = ends.length; i < ii; i++) {\n        ends[i] = (ends[i] / 4) * stride;\n      }\n    }\n  }\n  return layout;\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction parseLink(node, objectStack) {\n  const values = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  const href = node.getAttribute('href');\n  if (href !== null) {\n    values['link'] = href;\n  }\n  parseNode(LINK_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Node} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction parseExtensions(node, objectStack) {\n  const values = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  values['extensionsNode_'] = node;\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction parseRtePt(node, objectStack) {\n  const values = pushParseAndPop({}, RTEPT_PARSERS, node, objectStack);\n  if (values) {\n    const rteValues = /** @type {!Object} */ (objectStack[\n      objectStack.length - 1\n    ]);\n    const flatCoordinates = /** @type {Array<number>} */ (rteValues[\n      'flatCoordinates'\n    ]);\n    const layoutOptions = /** @type {LayoutOptions} */ (rteValues[\n      'layoutOptions'\n    ]);\n    appendCoordinate(flatCoordinates, layoutOptions, node, values);\n  }\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction parseTrkPt(node, objectStack) {\n  const values = pushParseAndPop({}, TRKPT_PARSERS, node, objectStack);\n  if (values) {\n    const trkValues = /** @type {!Object} */ (objectStack[\n      objectStack.length - 1\n    ]);\n    const flatCoordinates = /** @type {Array<number>} */ (trkValues[\n      'flatCoordinates'\n    ]);\n    const layoutOptions = /** @type {LayoutOptions} */ (trkValues[\n      'layoutOptions'\n    ]);\n    appendCoordinate(flatCoordinates, layoutOptions, node, values);\n  }\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction parseTrkSeg(node, objectStack) {\n  const values = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  parseNode(TRKSEG_PARSERS, node, objectStack);\n  const flatCoordinates =\n    /** @type {Array<number>} */\n    (values['flatCoordinates']);\n  const ends = /** @type {Array<number>} */ (values['ends']);\n  ends.push(flatCoordinates.length);\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Feature|undefined} Track.\n */\nfunction readRte(node, objectStack) {\n  const options = /** @type {import(\"./Feature.js\").ReadOptions} */ (objectStack[0]);\n  const values = pushParseAndPop(\n    {\n      'flatCoordinates': [],\n      'layoutOptions': {},\n    },\n    RTE_PARSERS,\n    node,\n    objectStack\n  );\n  if (!values) {\n    return undefined;\n  }\n  const flatCoordinates =\n    /** @type {Array<number>} */\n    (values['flatCoordinates']);\n  delete values['flatCoordinates'];\n  const layoutOptions = /** @type {LayoutOptions} */ (values['layoutOptions']);\n  delete values['layoutOptions'];\n  const layout = applyLayoutOptions(layoutOptions, flatCoordinates);\n  const geometry = new LineString(flatCoordinates, layout);\n  transformGeometryWithOptions(geometry, false, options);\n  const feature = new Feature(geometry);\n  feature.setProperties(values, true);\n  return feature;\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Feature|undefined} Track.\n */\nfunction readTrk(node, objectStack) {\n  const options = /** @type {import(\"./Feature.js\").ReadOptions} */ (objectStack[0]);\n  const values = pushParseAndPop(\n    {\n      'flatCoordinates': [],\n      'ends': [],\n      'layoutOptions': {},\n    },\n    TRK_PARSERS,\n    node,\n    objectStack\n  );\n  if (!values) {\n    return undefined;\n  }\n  const flatCoordinates =\n    /** @type {Array<number>} */\n    (values['flatCoordinates']);\n  delete values['flatCoordinates'];\n  const ends = /** @type {Array<number>} */ (values['ends']);\n  delete values['ends'];\n  const layoutOptions = /** @type {LayoutOptions} */ (values['layoutOptions']);\n  delete values['layoutOptions'];\n  const layout = applyLayoutOptions(layoutOptions, flatCoordinates, ends);\n  const geometry = new MultiLineString(flatCoordinates, layout, ends);\n  transformGeometryWithOptions(geometry, false, options);\n  const feature = new Feature(geometry);\n  feature.setProperties(values, true);\n  return feature;\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Feature|undefined} Waypoint.\n */\nfunction readWpt(node, objectStack) {\n  const options = /** @type {import(\"./Feature.js\").ReadOptions} */ (objectStack[0]);\n  const values = pushParseAndPop({}, WPT_PARSERS, node, objectStack);\n  if (!values) {\n    return undefined;\n  }\n  const layoutOptions = /** @type {LayoutOptions} */ ({});\n  const coordinates = appendCoordinate([], layoutOptions, node, values);\n  const layout = applyLayoutOptions(layoutOptions, coordinates);\n  const geometry = new Point(coordinates, layout);\n  transformGeometryWithOptions(geometry, false, options);\n  const feature = new Feature(geometry);\n  feature.setProperties(values, true);\n  return feature;\n}\n\n/**\n * @param {Element} node Node.\n * @param {string} value Value for the link's `href` attribute.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeLink(node, value, objectStack) {\n  node.setAttribute('href', value);\n  const context = objectStack[objectStack.length - 1];\n  const properties = context['properties'];\n  const link = [properties['linkText'], properties['linkType']];\n  pushSerializeAndPop(\n    /** @type {import(\"../xml.js\").NodeStackItem} */ ({node: node}),\n    LINK_SERIALIZERS,\n    OBJECT_PROPERTY_NODE_FACTORY,\n    link,\n    objectStack,\n    LINK_SEQUENCE\n  );\n}\n\n/**\n * @param {Element} node Node.\n * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeWptType(node, coordinate, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  const parentNode = context.node;\n  const namespaceURI = parentNode.namespaceURI;\n  const properties = context['properties'];\n  //FIXME Projection handling\n  node.setAttributeNS(null, 'lat', String(coordinate[1]));\n  node.setAttributeNS(null, 'lon', String(coordinate[0]));\n  const geometryLayout = context['geometryLayout'];\n  switch (geometryLayout) {\n    case GeometryLayout.XYZM:\n      if (coordinate[3] !== 0) {\n        properties['time'] = coordinate[3];\n      }\n    // fall through\n    case GeometryLayout.XYZ:\n      if (coordinate[2] !== 0) {\n        properties['ele'] = coordinate[2];\n      }\n      break;\n    case GeometryLayout.XYM:\n      if (coordinate[2] !== 0) {\n        properties['time'] = coordinate[2];\n      }\n      break;\n    default:\n    // pass\n  }\n  const orderedKeys =\n    node.nodeName == 'rtept'\n      ? RTEPT_TYPE_SEQUENCE[namespaceURI]\n      : WPT_TYPE_SEQUENCE[namespaceURI];\n  const values = makeSequence(properties, orderedKeys);\n  pushSerializeAndPop(\n    /** @type {import(\"../xml.js\").NodeStackItem} */\n    ({node: node, 'properties': properties}),\n    WPT_TYPE_SERIALIZERS,\n    OBJECT_PROPERTY_NODE_FACTORY,\n    values,\n    objectStack,\n    orderedKeys\n  );\n}\n\n/**\n * @param {Node} node Node.\n * @param {Feature} feature Feature.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeRte(node, feature, objectStack) {\n  const options = /** @type {import(\"./Feature.js\").WriteOptions} */ (objectStack[0]);\n  const properties = feature.getProperties();\n  const context = {node: node};\n  context['properties'] = properties;\n  const geometry = feature.getGeometry();\n  if (geometry.getType() == GeometryType.LINE_STRING) {\n    const lineString = /** @type {LineString} */ (transformGeometryWithOptions(\n      geometry,\n      true,\n      options\n    ));\n    context['geometryLayout'] = lineString.getLayout();\n    properties['rtept'] = lineString.getCoordinates();\n  }\n  const parentNode = objectStack[objectStack.length - 1].node;\n  const orderedKeys = RTE_SEQUENCE[parentNode.namespaceURI];\n  const values = makeSequence(properties, orderedKeys);\n  pushSerializeAndPop(\n    context,\n    RTE_SERIALIZERS,\n    OBJECT_PROPERTY_NODE_FACTORY,\n    values,\n    objectStack,\n    orderedKeys\n  );\n}\n\n/**\n * @param {Node} node Node.\n * @param {Feature} feature Feature.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeTrk(node, feature, objectStack) {\n  const options = /** @type {import(\"./Feature.js\").WriteOptions} */ (objectStack[0]);\n  const properties = feature.getProperties();\n  /** @type {import(\"../xml.js\").NodeStackItem} */\n  const context = {node: node};\n  context['properties'] = properties;\n  const geometry = feature.getGeometry();\n  if (geometry.getType() == GeometryType.MULTI_LINE_STRING) {\n    const multiLineString = /** @type {MultiLineString} */ (transformGeometryWithOptions(\n      geometry,\n      true,\n      options\n    ));\n    properties['trkseg'] = multiLineString.getLineStrings();\n  }\n  const parentNode = objectStack[objectStack.length - 1].node;\n  const orderedKeys = TRK_SEQUENCE[parentNode.namespaceURI];\n  const values = makeSequence(properties, orderedKeys);\n  pushSerializeAndPop(\n    context,\n    TRK_SERIALIZERS,\n    OBJECT_PROPERTY_NODE_FACTORY,\n    values,\n    objectStack,\n    orderedKeys\n  );\n}\n\n/**\n * @param {Node} node Node.\n * @param {LineString} lineString LineString.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeTrkSeg(node, lineString, objectStack) {\n  /** @type {import(\"../xml.js\").NodeStackItem} */\n  const context = {node: node};\n  context['geometryLayout'] = lineString.getLayout();\n  context['properties'] = {};\n  pushSerializeAndPop(\n    context,\n    TRKSEG_SERIALIZERS,\n    TRKSEG_NODE_FACTORY,\n    lineString.getCoordinates(),\n    objectStack\n  );\n}\n\n/**\n * @param {Element} node Node.\n * @param {Feature} feature Feature.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeWpt(node, feature, objectStack) {\n  const options = /** @type {import(\"./Feature.js\").WriteOptions} */ (objectStack[0]);\n  const context = objectStack[objectStack.length - 1];\n  context['properties'] = feature.getProperties();\n  const geometry = feature.getGeometry();\n  if (geometry.getType() == GeometryType.POINT) {\n    const point = /** @type {Point} */ (transformGeometryWithOptions(\n      geometry,\n      true,\n      options\n    ));\n    context['geometryLayout'] = point.getLayout();\n    writeWptType(node, point.getCoordinates(), objectStack);\n  }\n}\n\nexport default GPX;\n","/**\n * @module ol/layer/TileProperty\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  PRELOAD: 'preload',\n  USE_INTERIM_TILES_ON_ERROR: 'useInterimTilesOnError',\n};\n","/**\n * @module ol/layer/BaseTile\n */\nimport Layer from './Layer.js';\nimport TileProperty from './TileProperty.js';\nimport {assign} from '../obj.js';\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`\n * means no preloading.\n * @property {import(\"../source/Tile.js\").default} [source] Source for this layer.\n * @property {import(\"../PluggableMap.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\n * use {@link module:ol/Map#addLayer}.\n * @property {boolean} [useInterimTilesOnError=true] Use interim tiles on error.\n */\n\n/**\n * @classdesc\n * For layer sources that provide pre-rendered, tiled images in grids that are\n * organized by zoom levels for specific resolutions.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @template {import(\"../source/Tile.js\").default} TileSourceType\n * @extends {Layer<TileSourceType>}\n * @api\n */\nclass BaseTileLayer extends Layer {\n  /**\n   * @param {Options} [opt_options] Tile layer options.\n   */\n  constructor(opt_options) {\n    const options = opt_options ? opt_options : {};\n\n    const baseOptions = assign({}, options);\n\n    delete baseOptions.preload;\n    delete baseOptions.useInterimTilesOnError;\n    super(baseOptions);\n\n    this.setPreload(options.preload !== undefined ? options.preload : 0);\n    this.setUseInterimTilesOnError(\n      options.useInterimTilesOnError !== undefined\n        ? options.useInterimTilesOnError\n        : true\n    );\n  }\n\n  /**\n   * Return the level as number to which we will preload tiles up to.\n   * @return {number} The level to preload tiles up to.\n   * @observable\n   * @api\n   */\n  getPreload() {\n    return /** @type {number} */ (this.get(TileProperty.PRELOAD));\n  }\n\n  /**\n   * Set the level as number to which we will preload tiles up to.\n   * @param {number} preload The level to preload tiles up to.\n   * @observable\n   * @api\n   */\n  setPreload(preload) {\n    this.set(TileProperty.PRELOAD, preload);\n  }\n\n  /**\n   * Whether we use interim tiles on error.\n   * @return {boolean} Use interim tiles on error.\n   * @observable\n   * @api\n   */\n  getUseInterimTilesOnError() {\n    return /** @type {boolean} */ (this.get(\n      TileProperty.USE_INTERIM_TILES_ON_ERROR\n    ));\n  }\n\n  /**\n   * Set whether we use interim tiles on error.\n   * @param {boolean} useInterimTilesOnError Use interim tiles on error.\n   * @observable\n   * @api\n   */\n  setUseInterimTilesOnError(useInterimTilesOnError) {\n    this.set(TileProperty.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);\n  }\n}\n\nexport default BaseTileLayer;\n","/**\n * @module ol/TileRange\n */\n\n/**\n * A representation of a contiguous block of tiles.  A tile range is specified\n * by its min/max tile coordinates and is inclusive of coordinates.\n */\nclass TileRange {\n  /**\n   * @param {number} minX Minimum X.\n   * @param {number} maxX Maximum X.\n   * @param {number} minY Minimum Y.\n   * @param {number} maxY Maximum Y.\n   */\n  constructor(minX, maxX, minY, maxY) {\n    /**\n     * @type {number}\n     */\n    this.minX = minX;\n\n    /**\n     * @type {number}\n     */\n    this.maxX = maxX;\n\n    /**\n     * @type {number}\n     */\n    this.minY = minY;\n\n    /**\n     * @type {number}\n     */\n    this.maxY = maxY;\n  }\n\n  /**\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @return {boolean} Contains tile coordinate.\n   */\n  contains(tileCoord) {\n    return this.containsXY(tileCoord[1], tileCoord[2]);\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   * @return {boolean} Contains.\n   */\n  containsTileRange(tileRange) {\n    return (\n      this.minX <= tileRange.minX &&\n      tileRange.maxX <= this.maxX &&\n      this.minY <= tileRange.minY &&\n      tileRange.maxY <= this.maxY\n    );\n  }\n\n  /**\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @return {boolean} Contains coordinate.\n   */\n  containsXY(x, y) {\n    return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   * @return {boolean} Equals.\n   */\n  equals(tileRange) {\n    return (\n      this.minX == tileRange.minX &&\n      this.minY == tileRange.minY &&\n      this.maxX == tileRange.maxX &&\n      this.maxY == tileRange.maxY\n    );\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   */\n  extend(tileRange) {\n    if (tileRange.minX < this.minX) {\n      this.minX = tileRange.minX;\n    }\n    if (tileRange.maxX > this.maxX) {\n      this.maxX = tileRange.maxX;\n    }\n    if (tileRange.minY < this.minY) {\n      this.minY = tileRange.minY;\n    }\n    if (tileRange.maxY > this.maxY) {\n      this.maxY = tileRange.maxY;\n    }\n  }\n\n  /**\n   * @return {number} Height.\n   */\n  getHeight() {\n    return this.maxY - this.minY + 1;\n  }\n\n  /**\n   * @return {import(\"./size.js\").Size} Size.\n   */\n  getSize() {\n    return [this.getWidth(), this.getHeight()];\n  }\n\n  /**\n   * @return {number} Width.\n   */\n  getWidth() {\n    return this.maxX - this.minX + 1;\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   * @return {boolean} Intersects.\n   */\n  intersects(tileRange) {\n    return (\n      this.minX <= tileRange.maxX &&\n      this.maxX >= tileRange.minX &&\n      this.minY <= tileRange.maxY &&\n      this.maxY >= tileRange.minY\n    );\n  }\n}\n\n/**\n * @param {number} minX Minimum X.\n * @param {number} maxX Maximum X.\n * @param {number} minY Minimum Y.\n * @param {number} maxY Maximum Y.\n * @param {TileRange} [tileRange] TileRange.\n * @return {TileRange} Tile range.\n */\nexport function createOrUpdate(minX, maxX, minY, maxY, tileRange) {\n  if (tileRange !== undefined) {\n    tileRange.minX = minX;\n    tileRange.maxX = maxX;\n    tileRange.minY = minY;\n    tileRange.maxY = maxY;\n    return tileRange;\n  } else {\n    return new TileRange(minX, maxX, minY, maxY);\n  }\n}\n\nexport default TileRange;\n","/**\n * @module ol/renderer/canvas/TileLayer\n */\nimport CanvasLayerRenderer from './Layer.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport {\n  apply as applyTransform,\n  compose as composeTransform,\n  makeInverse,\n} from '../../transform.js';\nimport {assign} from '../../obj.js';\nimport {\n  createEmpty,\n  equals,\n  getIntersection,\n  getTopLeft,\n} from '../../extent.js';\nimport {fromUserExtent} from '../../proj.js';\nimport {getUid} from '../../util.js';\nimport {numberSafeCompareFunction} from '../../array.js';\nimport {toString as toTransformString} from '../../transform.js';\n\n/**\n * @classdesc\n * Canvas renderer for tile layers.\n * @api\n */\nclass CanvasTileLayerRenderer extends CanvasLayerRenderer {\n  /**\n   * @param {import(\"../../layer/Tile.js\").default|import(\"../../layer/VectorTile.js\").default} tileLayer Tile layer.\n   */\n  constructor(tileLayer) {\n    super(tileLayer);\n\n    /**\n     * Rendered extent has changed since the previous `renderFrame()` call\n     * @type {boolean}\n     */\n    this.extentChanged = true;\n\n    /**\n     * @private\n     * @type {?import(\"../../extent.js\").Extent}\n     */\n    this.renderedExtent_ = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedPixelRatio;\n\n    /**\n     * @protected\n     * @type {import(\"../../proj/Projection.js\").default}\n     */\n    this.renderedProjection = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedRevision;\n\n    /**\n     * @protected\n     * @type {!Array<import(\"../../Tile.js\").default>}\n     */\n    this.renderedTiles = [];\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.newTiles_ = false;\n\n    /**\n     * @protected\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.tmpExtent = createEmpty();\n\n    /**\n     * @private\n     * @type {import(\"../../TileRange.js\").default}\n     */\n    this.tmpTileRange_ = new TileRange(0, 0, 0, 0);\n  }\n\n  /**\n   * @protected\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @return {boolean} Tile is drawable.\n   */\n  isDrawableTile(tile) {\n    const tileLayer = this.getLayer();\n    const tileState = tile.getState();\n    const useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();\n    return (\n      tileState == TileState.LOADED ||\n      tileState == TileState.EMPTY ||\n      (tileState == TileState.ERROR && !useInterimTilesOnError)\n    );\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @return {!import(\"../../Tile.js\").default} Tile.\n   */\n  getTile(z, x, y, frameState) {\n    const pixelRatio = frameState.pixelRatio;\n    const projection = frameState.viewState.projection;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    let tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n    if (tile.getState() == TileState.ERROR) {\n      if (!tileLayer.getUseInterimTilesOnError()) {\n        // When useInterimTilesOnError is false, we consider the error tile as loaded.\n        tile.setState(TileState.LOADED);\n      } else if (tileLayer.getPreload() > 0) {\n        // Preloaded tiles for lower resolutions might have finished loading.\n        this.newTiles_ = true;\n      }\n    }\n    if (!this.isDrawableTile(tile)) {\n      tile = tile.getInterimTile();\n    }\n    return tile;\n  }\n\n  /**\n   * @param {Object<number, Object<string, import(\"../../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\n   * @param {number} zoom Zoom level.\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @return {boolean|void} If `false`, the tile will not be considered loaded.\n   */\n  loadedTileCallback(tiles, zoom, tile) {\n    if (this.isDrawableTile(tile)) {\n      return super.loadedTileCallback(tiles, zoom, tile);\n    }\n    return false;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    return !!this.getLayer().getSource();\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   */\n  renderFrame(frameState, target) {\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const viewResolution = viewState.resolution;\n    const viewCenter = viewState.center;\n    const rotation = viewState.rotation;\n    const pixelRatio = frameState.pixelRatio;\n\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    const sourceRevision = tileSource.getRevision();\n    const tileGrid = tileSource.getTileGridForProjection(projection);\n    const z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);\n    const tileResolution = tileGrid.getResolution(z);\n\n    let extent = frameState.extent;\n    const layerExtent =\n      layerState.extent && fromUserExtent(layerState.extent, projection);\n    if (layerExtent) {\n      extent = getIntersection(\n        extent,\n        fromUserExtent(layerState.extent, projection)\n      );\n    }\n\n    const tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\n\n    // desired dimensions of the canvas in pixels\n    let width = Math.round(frameState.size[0] * tilePixelRatio);\n    let height = Math.round(frameState.size[1] * tilePixelRatio);\n\n    if (rotation) {\n      const size = Math.round(Math.sqrt(width * width + height * height));\n      width = size;\n      height = size;\n    }\n\n    const dx = (tileResolution * width) / 2 / tilePixelRatio;\n    const dy = (tileResolution * height) / 2 / tilePixelRatio;\n    const canvasExtent = [\n      viewCenter[0] - dx,\n      viewCenter[1] - dy,\n      viewCenter[0] + dx,\n      viewCenter[1] + dy,\n    ];\n\n    const tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);\n\n    /**\n     * @type {Object<number, Object<string, import(\"../../Tile.js\").default>>}\n     */\n    const tilesToDrawByZ = {};\n    tilesToDrawByZ[z] = {};\n\n    const findLoadedTiles = this.createLoadedTileFinder(\n      tileSource,\n      projection,\n      tilesToDrawByZ\n    );\n\n    const tmpExtent = this.tmpExtent;\n    const tmpTileRange = this.tmpTileRange_;\n    this.newTiles_ = false;\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        const tile = this.getTile(z, x, y, frameState);\n        if (this.isDrawableTile(tile)) {\n          const uid = getUid(this);\n          if (tile.getState() == TileState.LOADED) {\n            tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;\n            const inTransition = tile.inTransition(uid);\n            if (\n              !this.newTiles_ &&\n              (inTransition || this.renderedTiles.indexOf(tile) === -1)\n            ) {\n              this.newTiles_ = true;\n            }\n          }\n          if (tile.getAlpha(uid, frameState.time) === 1) {\n            // don't look for alt tiles if alpha is 1\n            continue;\n          }\n        }\n\n        const childTileRange = tileGrid.getTileCoordChildTileRange(\n          tile.tileCoord,\n          tmpTileRange,\n          tmpExtent\n        );\n\n        let covered = false;\n        if (childTileRange) {\n          covered = findLoadedTiles(z + 1, childTileRange);\n        }\n        if (!covered) {\n          tileGrid.forEachTileCoordParentTileRange(\n            tile.tileCoord,\n            findLoadedTiles,\n            tmpTileRange,\n            tmpExtent\n          );\n        }\n      }\n    }\n\n    const canvasScale = tileResolution / viewResolution;\n\n    // set forward and inverse pixel transforms\n    composeTransform(\n      this.pixelTransform,\n      frameState.size[0] / 2,\n      frameState.size[1] / 2,\n      1 / tilePixelRatio,\n      1 / tilePixelRatio,\n      rotation,\n      -width / 2,\n      -height / 2\n    );\n\n    const canvasTransform = toTransformString(this.pixelTransform);\n\n    this.useContainer(target, canvasTransform, layerState.opacity);\n    const context = this.context;\n    const canvas = context.canvas;\n\n    makeInverse(this.inversePixelTransform, this.pixelTransform);\n\n    // set scale transform for calculating tile positions on the canvas\n    composeTransform(\n      this.tempTransform,\n      width / 2,\n      height / 2,\n      canvasScale,\n      canvasScale,\n      0,\n      -width / 2,\n      -height / 2\n    );\n\n    if (canvas.width != width || canvas.height != height) {\n      canvas.width = width;\n      canvas.height = height;\n    } else if (!this.containerReused) {\n      context.clearRect(0, 0, width, height);\n    }\n\n    if (layerExtent) {\n      this.clipUnrotated(context, frameState, layerExtent);\n    }\n\n    assign(context, tileSource.getContextOptions());\n    this.preRender(context, frameState);\n\n    this.renderedTiles.length = 0;\n    /** @type {Array<number>} */\n    let zs = Object.keys(tilesToDrawByZ).map(Number);\n    zs.sort(numberSafeCompareFunction);\n\n    let clips, clipZs, currentClip;\n    if (\n      layerState.opacity === 1 &&\n      (!this.containerReused ||\n        tileSource.getOpaque(frameState.viewState.projection))\n    ) {\n      zs = zs.reverse();\n    } else {\n      clips = [];\n      clipZs = [];\n    }\n    for (let i = zs.length - 1; i >= 0; --i) {\n      const currentZ = zs[i];\n      const currentTilePixelSize = tileSource.getTilePixelSize(\n        currentZ,\n        pixelRatio,\n        projection\n      );\n      const currentResolution = tileGrid.getResolution(currentZ);\n      const currentScale = currentResolution / tileResolution;\n      const dx = currentTilePixelSize[0] * currentScale * canvasScale;\n      const dy = currentTilePixelSize[1] * currentScale * canvasScale;\n      const originTileCoord = tileGrid.getTileCoordForCoordAndZ(\n        getTopLeft(canvasExtent),\n        currentZ\n      );\n      const originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);\n      const origin = applyTransform(this.tempTransform, [\n        (tilePixelRatio * (originTileExtent[0] - canvasExtent[0])) /\n          tileResolution,\n        (tilePixelRatio * (canvasExtent[3] - originTileExtent[3])) /\n          tileResolution,\n      ]);\n      const tileGutter =\n        tilePixelRatio * tileSource.getGutterForProjection(projection);\n      const tilesToDraw = tilesToDrawByZ[currentZ];\n      for (const tileCoordKey in tilesToDraw) {\n        const tile = /** @type {import(\"../../ImageTile.js\").default} */ (tilesToDraw[\n          tileCoordKey\n        ]);\n        const tileCoord = tile.tileCoord;\n\n        // Calculate integer positions and sizes so that tiles align\n        const floatX = origin[0] - (originTileCoord[1] - tileCoord[1]) * dx;\n        const nextX = Math.round(floatX + dx);\n        const floatY = origin[1] - (originTileCoord[2] - tileCoord[2]) * dy;\n        const nextY = Math.round(floatY + dy);\n        const x = Math.round(floatX);\n        const y = Math.round(floatY);\n        const w = nextX - x;\n        const h = nextY - y;\n        const transition = z === currentZ;\n\n        const inTransition =\n          transition && tile.getAlpha(getUid(this), frameState.time) !== 1;\n        if (!inTransition) {\n          if (clips) {\n            // Clip mask for regions in this tile that already filled by a higher z tile\n            context.save();\n            currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];\n            for (let i = 0, ii = clips.length; i < ii; ++i) {\n              if (z !== currentZ && currentZ < clipZs[i]) {\n                const clip = clips[i];\n                context.beginPath();\n                // counter-clockwise (outer ring) for current tile\n                context.moveTo(currentClip[0], currentClip[1]);\n                context.lineTo(currentClip[2], currentClip[3]);\n                context.lineTo(currentClip[4], currentClip[5]);\n                context.lineTo(currentClip[6], currentClip[7]);\n                // clockwise (inner ring) for higher z tile\n                context.moveTo(clip[6], clip[7]);\n                context.lineTo(clip[4], clip[5]);\n                context.lineTo(clip[2], clip[3]);\n                context.lineTo(clip[0], clip[1]);\n                context.clip();\n              }\n            }\n            clips.push(currentClip);\n            clipZs.push(currentZ);\n          } else {\n            context.clearRect(x, y, w, h);\n          }\n        }\n        this.drawTileImage(\n          tile,\n          frameState,\n          x,\n          y,\n          w,\n          h,\n          tileGutter,\n          transition,\n          layerState.opacity\n        );\n        if (clips && !inTransition) {\n          context.restore();\n          this.renderedTiles.unshift(tile);\n        } else {\n          this.renderedTiles.push(tile);\n        }\n        this.updateUsedTiles(frameState.usedTiles, tileSource, tile);\n      }\n    }\n\n    this.renderedRevision = sourceRevision;\n    this.renderedResolution = tileResolution;\n    this.extentChanged =\n      !this.renderedExtent_ || !equals(this.renderedExtent_, canvasExtent);\n    this.renderedExtent_ = canvasExtent;\n    this.renderedPixelRatio = pixelRatio;\n    this.renderedProjection = projection;\n\n    this.manageTilePyramid(\n      frameState,\n      tileSource,\n      tileGrid,\n      pixelRatio,\n      projection,\n      extent,\n      z,\n      tileLayer.getPreload()\n    );\n    this.scheduleExpireCache(frameState, tileSource);\n\n    this.postRender(context, frameState);\n\n    if (layerState.extent) {\n      context.restore();\n    }\n\n    if (canvasTransform !== canvas.style.transform) {\n      canvas.style.transform = canvasTransform;\n    }\n\n    return this.container;\n  }\n\n  /**\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {number} x Left of the tile.\n   * @param {number} y Top of the tile.\n   * @param {number} w Width of the tile.\n   * @param {number} h Height of the tile.\n   * @param {number} gutter Tile gutter.\n   * @param {boolean} transition Apply an alpha transition.\n   * @param {number} opacity Opacity.\n   */\n  drawTileImage(tile, frameState, x, y, w, h, gutter, transition, opacity) {\n    const image = this.getTileImage(tile);\n    if (!image) {\n      return;\n    }\n    const uid = getUid(this);\n    const tileAlpha = transition ? tile.getAlpha(uid, frameState.time) : 1;\n    const alpha = opacity * tileAlpha;\n    const alphaChanged = alpha !== this.context.globalAlpha;\n    if (alphaChanged) {\n      this.context.save();\n      this.context.globalAlpha = alpha;\n    }\n    this.context.drawImage(\n      image,\n      gutter,\n      gutter,\n      image.width - 2 * gutter,\n      image.height - 2 * gutter,\n      x,\n      y,\n      w,\n      h\n    );\n\n    if (alphaChanged) {\n      this.context.restore();\n    }\n    if (tileAlpha !== 1) {\n      frameState.animate = true;\n    } else if (transition) {\n      tile.endTransition(uid);\n    }\n  }\n\n  /**\n   * @return {HTMLCanvasElement} Image\n   */\n  getImage() {\n    const context = this.context;\n    return context ? context.canvas : null;\n  }\n\n  /**\n   * Get the image from a tile.\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @protected\n   */\n  getTileImage(tile) {\n    return tile.getImage();\n  }\n\n  /**\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @protected\n   */\n  scheduleExpireCache(frameState, tileSource) {\n    if (tileSource.canExpireCache()) {\n      /**\n       * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n       * @param {import(\"../../PluggableMap.js\").default} map Map.\n       * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n       */\n      const postRenderFunction = function (tileSource, map, frameState) {\n        const tileSourceKey = getUid(tileSource);\n        if (tileSourceKey in frameState.usedTiles) {\n          tileSource.expireCache(\n            frameState.viewState.projection,\n            frameState.usedTiles[tileSourceKey]\n          );\n        }\n      }.bind(null, tileSource);\n\n      frameState.postRenderFunctions.push(\n        /** @type {import(\"../../PluggableMap.js\").PostRenderFunction} */ (postRenderFunction)\n      );\n    }\n  }\n\n  /**\n   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import('../../Tile.js').default} tile Tile.\n   * @protected\n   */\n  updateUsedTiles(usedTiles, tileSource, tile) {\n    // FIXME should we use tilesToDrawByZ instead?\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in usedTiles)) {\n      usedTiles[tileSourceKey] = {};\n    }\n    usedTiles[tileSourceKey][tile.getKey()] = true;\n  }\n\n  /**\n   * Manage tile pyramid.\n   * This function performs a number of functions related to the tiles at the\n   * current zoom and lower zoom levels:\n   * - registers idle tiles in frameState.wantedTiles so that they are not\n   *   discarded by the tile queue\n   * - enqueues missing tiles\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @param {import(\"../../extent.js\").Extent} extent Extent.\n   * @param {number} currentZ Current Z.\n   * @param {number} preload Load low resolution tiles up to 'preload' levels.\n   * @param {function(import(\"../../Tile.js\").default):void} [opt_tileCallback] Tile callback.\n   * @protected\n   */\n  manageTilePyramid(\n    frameState,\n    tileSource,\n    tileGrid,\n    pixelRatio,\n    projection,\n    extent,\n    currentZ,\n    preload,\n    opt_tileCallback\n  ) {\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n    const wantedTiles = frameState.wantedTiles[tileSourceKey];\n    const tileQueue = frameState.tileQueue;\n    const minZoom = tileGrid.getMinZoom();\n    let tileCount = 0;\n    let tile, tileRange, tileResolution, x, y, z;\n    for (z = minZoom; z <= currentZ; ++z) {\n      tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);\n      tileResolution = tileGrid.getResolution(z);\n      for (x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          if (currentZ - z <= preload) {\n            ++tileCount;\n            tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n            if (tile.getState() == TileState.IDLE) {\n              wantedTiles[tile.getKey()] = true;\n              if (!tileQueue.isKeyQueued(tile.getKey())) {\n                tileQueue.enqueue([\n                  tile,\n                  tileSourceKey,\n                  tileGrid.getTileCoordCenter(tile.tileCoord),\n                  tileResolution,\n                ]);\n              }\n            }\n            if (opt_tileCallback !== undefined) {\n              opt_tileCallback(tile);\n            }\n          } else {\n            tileSource.useTile(z, x, y, projection);\n          }\n        }\n      }\n    }\n    tileSource.updateCacheSize(tileCount, projection);\n  }\n}\n\n/**\n * @function\n * @return {import(\"../../layer/Tile.js\").default|import(\"../../layer/VectorTile.js\").default}\n */\nCanvasTileLayerRenderer.prototype.getLayer;\n\nexport default CanvasTileLayerRenderer;\n","/**\n * @module ol/layer/Tile\n */\nimport BaseTileLayer from './BaseTile.js';\nimport CanvasTileLayerRenderer from '../renderer/canvas/TileLayer.js';\n\n/**\n * @classdesc\n * For layer sources that provide pre-rendered, tiled images in grids that are\n * organized by zoom levels for specific resolutions.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @template {import(\"../source/Tile.js\").default} TileSourceType\n * @extends {BaseTileLayer<TileSourceType>}\n * @api\n */\nclass TileLayer extends BaseTileLayer {\n  /**\n   * @param {import(\"./BaseTile.js\").Options} [opt_options] Tile layer options.\n   */\n  constructor(opt_options) {\n    super(opt_options);\n  }\n\n  /**\n   * Create a renderer for this layer.\n   * @return {import(\"../renderer/Layer.js\").default} A layer renderer.\n   * @protected\n   */\n  createRenderer() {\n    return new CanvasTileLayerRenderer(this);\n  }\n}\n\nexport default TileLayer;\n","/**\n * @module ol/Tile\n */\nimport EventTarget from './events/Target.js';\nimport EventType from './events/EventType.js';\nimport TileState from './TileState.js';\nimport {abstract} from './util.js';\nimport {easeIn} from './easing.js';\n\n/**\n * A function that takes an {@link module:ol/Tile} for the tile and a\n * `{string}` for the url as arguments. The default is\n * ```js\n * source.setTileLoadFunction(function(tile, src) {\n *   tile.getImage().src = src;\n * });\n * ```\n * For more fine grained control, the load function can use fetch or XMLHttpRequest and involve\n * error handling:\n *\n * ```js\n * import TileState from 'ol/TileState';\n *\n * source.setTileLoadFunction(function(tile, src) {\n *   var xhr = new XMLHttpRequest();\n *   xhr.responseType = 'blob';\n *   xhr.addEventListener('loadend', function (evt) {\n *     var data = this.response;\n *     if (data !== undefined) {\n *       tile.getImage().src = URL.createObjectURL(data);\n *     } else {\n *       tile.setState(TileState.ERROR);\n *     }\n *   });\n *   xhr.addEventListener('error', function () {\n *     tile.setState(TileState.ERROR);\n *   });\n *   xhr.open('GET', src);\n *   xhr.send();\n * });\n * ```\n *\n * @typedef {function(Tile, string): void} LoadFunction\n * @api\n */\n\n/**\n * {@link module:ol/source/Tile~Tile} sources use a function of this type to get\n * the url that provides a tile for a given tile coordinate.\n *\n * This function takes an {@link module:ol/tilecoord~TileCoord} for the tile\n * coordinate, a `{number}` representing the pixel ratio and a\n * {@link module:ol/proj/Projection} for the projection  as arguments\n * and returns a `{string}` representing the tile URL, or undefined if no tile\n * should be requested for the passed tile coordinate.\n *\n * @typedef {function(import(\"./tilecoord.js\").TileCoord, number,\n *           import(\"./proj/Projection.js\").default): (string|undefined)} UrlFunction\n * @api\n */\n\n/**\n * @typedef {Object} Options\n * @property {number} [transition=250] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @api\n */\n\n/**\n * @classdesc\n * Base class for tiles.\n *\n * @abstract\n */\nclass Tile extends EventTarget {\n  /**\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"./TileState.js\").default} state State.\n   * @param {Options} [opt_options] Tile options.\n   */\n  constructor(tileCoord, state, opt_options) {\n    super();\n\n    const options = opt_options ? opt_options : {};\n\n    /**\n     * @type {import(\"./tilecoord.js\").TileCoord}\n     */\n    this.tileCoord = tileCoord;\n\n    /**\n     * @protected\n     * @type {import(\"./TileState.js\").default}\n     */\n    this.state = state;\n\n    /**\n     * An \"interim\" tile for this tile. The interim tile may be used while this\n     * one is loading, for \"smooth\" transitions when changing params/dimensions\n     * on the source.\n     * @type {Tile}\n     */\n    this.interimTile = null;\n\n    /**\n     * The tile is available at the highest possible resolution. Subclasses can\n     * set this to `false` initially. Tile load listeners will not be\n     * unregistered before this is set to `true` and a `#changed()` is called.\n     * @type {boolean}\n     */\n    this.hifi = true;\n\n    /**\n     * A key assigned to the tile. This is used by the tile source to determine\n     * if this tile can effectively be used, or if a new tile should be created\n     * and this one be used as an interim tile for this new tile.\n     * @type {string}\n     */\n    this.key = '';\n\n    /**\n     * The duration for the opacity transition.\n     * @type {number}\n     */\n    this.transition_ =\n      options.transition === undefined ? 250 : options.transition;\n\n    /**\n     * Lookup of start times for rendering transitions.  If the start time is\n     * equal to -1, the transition is complete.\n     * @type {Object<string, number>}\n     */\n    this.transitionStarts_ = {};\n  }\n\n  /**\n   * @protected\n   */\n  changed() {\n    this.dispatchEvent(EventType.CHANGE);\n  }\n\n  /**\n   * Called by the tile cache when the tile is removed from the cache due to expiry\n   */\n  release() {}\n\n  /**\n   * @return {string} Key.\n   */\n  getKey() {\n    return this.key + '/' + this.tileCoord;\n  }\n\n  /**\n   * Get the interim tile most suitable for rendering using the chain of interim\n   * tiles. This corresponds to the  most recent tile that has been loaded, if no\n   * such tile exists, the original tile is returned.\n   * @return {!Tile} Best tile for rendering.\n   */\n  getInterimTile() {\n    if (!this.interimTile) {\n      //empty chain\n      return this;\n    }\n    let tile = this.interimTile;\n\n    // find the first loaded tile and return it. Since the chain is sorted in\n    // decreasing order of creation time, there is no need to search the remainder\n    // of the list (all those tiles correspond to older requests and will be\n    // cleaned up by refreshInterimChain)\n    do {\n      if (tile.getState() == TileState.LOADED) {\n        // Show tile immediately instead of fading it in after loading, because\n        // the interim tile is in place already\n        this.transition_ = 0;\n        return tile;\n      }\n      tile = tile.interimTile;\n    } while (tile);\n\n    // we can not find a better tile\n    return this;\n  }\n\n  /**\n   * Goes through the chain of interim tiles and discards sections of the chain\n   * that are no longer relevant.\n   */\n  refreshInterimChain() {\n    if (!this.interimTile) {\n      return;\n    }\n\n    let tile = this.interimTile;\n    let prev = /** @type {Tile} */ (this);\n\n    do {\n      if (tile.getState() == TileState.LOADED) {\n        //we have a loaded tile, we can discard the rest of the list\n        //we would could abort any LOADING tile request\n        //older than this tile (i.e. any LOADING tile following this entry in the chain)\n        tile.interimTile = null;\n        break;\n      } else if (tile.getState() == TileState.LOADING) {\n        //keep this LOADING tile any loaded tiles later in the chain are\n        //older than this tile, so we're still interested in the request\n        prev = tile;\n      } else if (tile.getState() == TileState.IDLE) {\n        //the head of the list is the most current tile, we don't need\n        //to start any other requests for this chain\n        prev.interimTile = tile.interimTile;\n      } else {\n        prev = tile;\n      }\n      tile = prev.interimTile;\n    } while (tile);\n  }\n\n  /**\n   * Get the tile coordinate for this tile.\n   * @return {import(\"./tilecoord.js\").TileCoord} The tile coordinate.\n   * @api\n   */\n  getTileCoord() {\n    return this.tileCoord;\n  }\n\n  /**\n   * @return {import(\"./TileState.js\").default} State.\n   */\n  getState() {\n    return this.state;\n  }\n\n  /**\n   * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,\n   * it is important to set the state correctly to {@link module:ol/TileState~ERROR}\n   * when the tile cannot be loaded. Otherwise the tile cannot be removed from\n   * the tile queue and will block other requests.\n   * @param {import(\"./TileState.js\").default} state State.\n   * @api\n   */\n  setState(state) {\n    if (this.state !== TileState.ERROR && this.state > state) {\n      throw new Error('Tile load sequence violation');\n    }\n    this.state = state;\n    this.changed();\n  }\n\n  /**\n   * Load the image or retry if loading previously failed.\n   * Loading is taken care of by the tile queue, and calling this method is\n   * only needed for preloading or for reloading in case of an error.\n   * @abstract\n   * @api\n   */\n  load() {\n    abstract();\n  }\n\n  /**\n   * Get the alpha value for rendering.\n   * @param {string} id An id for the renderer.\n   * @param {number} time The render frame time.\n   * @return {number} A number between 0 and 1.\n   */\n  getAlpha(id, time) {\n    if (!this.transition_) {\n      return 1;\n    }\n\n    let start = this.transitionStarts_[id];\n    if (!start) {\n      start = time;\n      this.transitionStarts_[id] = start;\n    } else if (start === -1) {\n      return 1;\n    }\n\n    const delta = time - start + 1000 / 60; // avoid rendering at 0\n    if (delta >= this.transition_) {\n      return 1;\n    }\n    return easeIn(delta / this.transition_);\n  }\n\n  /**\n   * Determine if a tile is in an alpha transition.  A tile is considered in\n   * transition if tile.getAlpha() has not yet been called or has been called\n   * and returned 1.\n   * @param {string} id An id for the renderer.\n   * @return {boolean} The tile is in transition.\n   */\n  inTransition(id) {\n    if (!this.transition_) {\n      return false;\n    }\n    return this.transitionStarts_[id] !== -1;\n  }\n\n  /**\n   * Mark a transition as complete.\n   * @param {string} id An id for the renderer.\n   */\n  endTransition(id) {\n    if (this.transition_) {\n      this.transitionStarts_[id] = -1;\n    }\n  }\n}\n\nexport default Tile;\n","/**\n * @module ol/ImageTile\n */\nimport Tile from './Tile.js';\nimport TileState from './TileState.js';\nimport {createCanvasContext2D} from './dom.js';\nimport {listenImage} from './Image.js';\n\nclass ImageTile extends Tile {\n  /**\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"./TileState.js\").default} state State.\n   * @param {string} src Image source URI.\n   * @param {?string} crossOrigin Cross origin.\n   * @param {import(\"./Tile.js\").LoadFunction} tileLoadFunction Tile load function.\n   * @param {import(\"./Tile.js\").Options} [opt_options] Tile options.\n   */\n  constructor(\n    tileCoord,\n    state,\n    src,\n    crossOrigin,\n    tileLoadFunction,\n    opt_options\n  ) {\n    super(tileCoord, state, opt_options);\n\n    /**\n     * @private\n     * @type {?string}\n     */\n    this.crossOrigin_ = crossOrigin;\n\n    /**\n     * Image URI\n     *\n     * @private\n     * @type {string}\n     */\n    this.src_ = src;\n\n    this.key = src;\n\n    /**\n     * @private\n     * @type {HTMLImageElement|HTMLCanvasElement}\n     */\n    this.image_ = new Image();\n    if (crossOrigin !== null) {\n      this.image_.crossOrigin = crossOrigin;\n    }\n\n    /**\n     * @private\n     * @type {?function():void}\n     */\n    this.unlisten_ = null;\n\n    /**\n     * @private\n     * @type {import(\"./Tile.js\").LoadFunction}\n     */\n    this.tileLoadFunction_ = tileLoadFunction;\n  }\n\n  /**\n   * Get the HTML image element for this tile (may be a Canvas, Image, or Video).\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @api\n   */\n  getImage() {\n    return this.image_;\n  }\n\n  /**\n   * Tracks loading or read errors.\n   *\n   * @private\n   */\n  handleImageError_() {\n    this.state = TileState.ERROR;\n    this.unlistenImage_();\n    this.image_ = getBlankImage();\n    this.changed();\n  }\n\n  /**\n   * Tracks successful image load.\n   *\n   * @private\n   */\n  handleImageLoad_() {\n    const image = /** @type {HTMLImageElement} */ (this.image_);\n    if (image.naturalWidth && image.naturalHeight) {\n      this.state = TileState.LOADED;\n    } else {\n      this.state = TileState.EMPTY;\n    }\n    this.unlistenImage_();\n    this.changed();\n  }\n\n  /**\n   * Load not yet loaded URI.\n   * @api\n   */\n  load() {\n    if (this.state == TileState.ERROR) {\n      this.state = TileState.IDLE;\n      this.image_ = new Image();\n      if (this.crossOrigin_ !== null) {\n        this.image_.crossOrigin = this.crossOrigin_;\n      }\n    }\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      this.changed();\n      this.tileLoadFunction_(this, this.src_);\n      this.unlisten_ = listenImage(\n        this.image_,\n        this.handleImageLoad_.bind(this),\n        this.handleImageError_.bind(this)\n      );\n    }\n  }\n\n  /**\n   * Discards event handlers which listen for load completion or errors.\n   *\n   * @private\n   */\n  unlistenImage_() {\n    if (this.unlisten_) {\n      this.unlisten_();\n      this.unlisten_ = null;\n    }\n  }\n}\n\n/**\n * Get a 1-pixel blank image.\n * @return {HTMLCanvasElement} Blank image.\n */\nfunction getBlankImage() {\n  const ctx = createCanvasContext2D(1, 1);\n  ctx.fillStyle = 'rgba(0,0,0,0)';\n  ctx.fillRect(0, 0, 1, 1);\n  return ctx.canvas;\n}\n\nexport default ImageTile;\n","/**\n * @module ol/reproj\n */\nimport {IMAGE_SMOOTHING_DISABLED} from './source/common.js';\nimport {assign} from './obj.js';\nimport {\n  containsCoordinate,\n  createEmpty,\n  extend,\n  forEachCorner,\n  getCenter,\n  getHeight,\n  getTopLeft,\n  getWidth,\n} from './extent.js';\nimport {createCanvasContext2D} from './dom.js';\nimport {getPointResolution, transform} from './proj.js';\nimport {solveLinearSystem} from './math.js';\n\nlet brokenDiagonalRendering_;\n\n/**\n * This draws a small triangle into a canvas by setting the triangle as the clip region\n * and then drawing a (too large) rectangle\n *\n * @param {CanvasRenderingContext2D} ctx The context in which to draw the triangle\n * @param {number} u1 The x-coordinate of the second point. The first point is 0,0.\n * @param {number} v1 The y-coordinate of the second point.\n * @param {number} u2 The x-coordinate of the third point.\n * @param {number} v2 The y-coordinate of the third point.\n */\nfunction drawTestTriangle(ctx, u1, v1, u2, v2) {\n  ctx.beginPath();\n  ctx.moveTo(0, 0);\n  ctx.lineTo(u1, v1);\n  ctx.lineTo(u2, v2);\n  ctx.closePath();\n  ctx.save();\n  ctx.clip();\n  ctx.fillRect(0, 0, Math.max(u1, u2) + 1, Math.max(v1, v2));\n  ctx.restore();\n}\n\n/**\n * Given the data from getImageData, see if the right values appear at the provided offset.\n * Returns true if either the color or transparency is off\n *\n * @param {Uint8ClampedArray} data The data returned from getImageData\n * @param {number} offset The pixel offset from the start of data.\n * @return {boolean} true if the diagonal rendering is broken\n */\nfunction verifyBrokenDiagonalRendering(data, offset) {\n  // the values ought to be close to the rgba(210, 0, 0, 0.75)\n  return (\n    Math.abs(data[offset * 4] - 210) > 2 ||\n    Math.abs(data[offset * 4 + 3] - 0.75 * 255) > 2\n  );\n}\n\n/**\n * Determines if the current browser configuration can render triangular clip regions correctly.\n * This value is cached so the function is only expensive the first time called.\n * Firefox on Windows (as of now) does not if HWA is enabled. See https://bugzilla.mozilla.org/show_bug.cgi?id=1606976\n * IE also doesn't. Chrome works, and everything seems to work on OSX and Android. This function caches the\n * result. I suppose that it is conceivably possible that a browser might flip modes while the app is\n * running, but lets hope not.\n *\n * @return {boolean} true if the Diagonal Rendering is broken.\n */\nfunction isBrokenDiagonalRendering() {\n  if (brokenDiagonalRendering_ === undefined) {\n    const ctx = document.createElement('canvas').getContext('2d');\n    ctx.globalCompositeOperation = 'lighter';\n    ctx.fillStyle = 'rgba(210, 0, 0, 0.75)';\n    drawTestTriangle(ctx, 4, 5, 4, 0);\n    drawTestTriangle(ctx, 4, 5, 0, 5);\n    const data = ctx.getImageData(0, 0, 3, 3).data;\n    brokenDiagonalRendering_ =\n      verifyBrokenDiagonalRendering(data, 0) ||\n      verifyBrokenDiagonalRendering(data, 4) ||\n      verifyBrokenDiagonalRendering(data, 8);\n  }\n\n  return brokenDiagonalRendering_;\n}\n\n/**\n * Calculates ideal resolution to use from the source in order to achieve\n * pixel mapping as close as possible to 1:1 during reprojection.\n * The resolution is calculated regardless of what resolutions\n * are actually available in the dataset (TileGrid, Image, ...).\n *\n * @param {import(\"./proj/Projection.js\").default} sourceProj Source projection.\n * @param {import(\"./proj/Projection.js\").default} targetProj Target projection.\n * @param {import(\"./coordinate.js\").Coordinate} targetCenter Target center.\n * @param {number} targetResolution Target resolution.\n * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.\n */\nexport function calculateSourceResolution(\n  sourceProj,\n  targetProj,\n  targetCenter,\n  targetResolution\n) {\n  const sourceCenter = transform(targetCenter, targetProj, sourceProj);\n\n  // calculate the ideal resolution of the source data\n  let sourceResolution = getPointResolution(\n    targetProj,\n    targetResolution,\n    targetCenter\n  );\n\n  const targetMetersPerUnit = targetProj.getMetersPerUnit();\n  if (targetMetersPerUnit !== undefined) {\n    sourceResolution *= targetMetersPerUnit;\n  }\n  const sourceMetersPerUnit = sourceProj.getMetersPerUnit();\n  if (sourceMetersPerUnit !== undefined) {\n    sourceResolution /= sourceMetersPerUnit;\n  }\n\n  // Based on the projection properties, the point resolution at the specified\n  // coordinates may be slightly different. We need to reverse-compensate this\n  // in order to achieve optimal results.\n\n  const sourceExtent = sourceProj.getExtent();\n  if (!sourceExtent || containsCoordinate(sourceExtent, sourceCenter)) {\n    const compensationFactor =\n      getPointResolution(sourceProj, sourceResolution, sourceCenter) /\n      sourceResolution;\n    if (isFinite(compensationFactor) && compensationFactor > 0) {\n      sourceResolution /= compensationFactor;\n    }\n  }\n\n  return sourceResolution;\n}\n\n/**\n * Calculates ideal resolution to use from the source in order to achieve\n * pixel mapping as close as possible to 1:1 during reprojection.\n * The resolution is calculated regardless of what resolutions\n * are actually available in the dataset (TileGrid, Image, ...).\n *\n * @param {import(\"./proj/Projection.js\").default} sourceProj Source projection.\n * @param {import(\"./proj/Projection.js\").default} targetProj Target projection.\n * @param {import(\"./extent.js\").Extent} targetExtent Target extent\n * @param {number} targetResolution Target resolution.\n * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.\n */\nexport function calculateSourceExtentResolution(\n  sourceProj,\n  targetProj,\n  targetExtent,\n  targetResolution\n) {\n  const targetCenter = getCenter(targetExtent);\n  let sourceResolution = calculateSourceResolution(\n    sourceProj,\n    targetProj,\n    targetCenter,\n    targetResolution\n  );\n\n  if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n    forEachCorner(targetExtent, function (corner) {\n      sourceResolution = calculateSourceResolution(\n        sourceProj,\n        targetProj,\n        corner,\n        targetResolution\n      );\n      return isFinite(sourceResolution) && sourceResolution > 0;\n    });\n  }\n\n  return sourceResolution;\n}\n\n/**\n * @typedef {Object} ImageExtent\n * @property {import(\"./extent.js\").Extent} extent Extent.\n * @property {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image.\n */\n\n/**\n * Renders the source data into new canvas based on the triangulation.\n *\n * @param {number} width Width of the canvas.\n * @param {number} height Height of the canvas.\n * @param {number} pixelRatio Pixel ratio.\n * @param {number} sourceResolution Source resolution.\n * @param {import(\"./extent.js\").Extent} sourceExtent Extent of the data source.\n * @param {number} targetResolution Target resolution.\n * @param {import(\"./extent.js\").Extent} targetExtent Target extent.\n * @param {import(\"./reproj/Triangulation.js\").default} triangulation Calculated triangulation.\n * @param {Array<ImageExtent>} sources Array of sources.\n * @param {number} gutter Gutter of the sources.\n * @param {boolean} [opt_renderEdges] Render reprojection edges.\n * @param {object} [opt_contextOptions] Properties to set on the canvas context.\n * @return {HTMLCanvasElement} Canvas with reprojected data.\n */\nexport function render(\n  width,\n  height,\n  pixelRatio,\n  sourceResolution,\n  sourceExtent,\n  targetResolution,\n  targetExtent,\n  triangulation,\n  sources,\n  gutter,\n  opt_renderEdges,\n  opt_contextOptions\n) {\n  const context = createCanvasContext2D(\n    Math.round(pixelRatio * width),\n    Math.round(pixelRatio * height)\n  );\n  assign(context, opt_contextOptions);\n\n  if (sources.length === 0) {\n    return context.canvas;\n  }\n\n  context.scale(pixelRatio, pixelRatio);\n\n  function pixelRound(value) {\n    return Math.round(value * pixelRatio) / pixelRatio;\n  }\n\n  context.globalCompositeOperation = 'lighter';\n\n  const sourceDataExtent = createEmpty();\n  sources.forEach(function (src, i, arr) {\n    extend(sourceDataExtent, src.extent);\n  });\n\n  const canvasWidthInUnits = getWidth(sourceDataExtent);\n  const canvasHeightInUnits = getHeight(sourceDataExtent);\n  const stitchContext = createCanvasContext2D(\n    Math.round((pixelRatio * canvasWidthInUnits) / sourceResolution),\n    Math.round((pixelRatio * canvasHeightInUnits) / sourceResolution)\n  );\n  assign(stitchContext, opt_contextOptions);\n\n  const stitchScale = pixelRatio / sourceResolution;\n\n  sources.forEach(function (src, i, arr) {\n    const xPos = src.extent[0] - sourceDataExtent[0];\n    const yPos = -(src.extent[3] - sourceDataExtent[3]);\n    const srcWidth = getWidth(src.extent);\n    const srcHeight = getHeight(src.extent);\n\n    // This test should never fail -- but it does. Need to find a fix the upstream condition\n    if (src.image.width > 0 && src.image.height > 0) {\n      stitchContext.drawImage(\n        src.image,\n        gutter,\n        gutter,\n        src.image.width - 2 * gutter,\n        src.image.height - 2 * gutter,\n        xPos * stitchScale,\n        yPos * stitchScale,\n        srcWidth * stitchScale,\n        srcHeight * stitchScale\n      );\n    }\n  });\n\n  const targetTopLeft = getTopLeft(targetExtent);\n\n  triangulation.getTriangles().forEach(function (triangle, i, arr) {\n    /* Calculate affine transform (src -> dst)\n     * Resulting matrix can be used to transform coordinate\n     * from `sourceProjection` to destination pixels.\n     *\n     * To optimize number of context calls and increase numerical stability,\n     * we also do the following operations:\n     * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)\n     * here before solving the linear system so [ui, vi] are pixel coordinates.\n     *\n     * Src points: xi, yi\n     * Dst points: ui, vi\n     * Affine coefficients: aij\n     *\n     * | x0 y0 1  0  0 0 |   |a00|   |u0|\n     * | x1 y1 1  0  0 0 |   |a01|   |u1|\n     * | x2 y2 1  0  0 0 | x |a02| = |u2|\n     * |  0  0 0 x0 y0 1 |   |a10|   |v0|\n     * |  0  0 0 x1 y1 1 |   |a11|   |v1|\n     * |  0  0 0 x2 y2 1 |   |a12|   |v2|\n     */\n    const source = triangle.source;\n    const target = triangle.target;\n    let x0 = source[0][0],\n      y0 = source[0][1];\n    let x1 = source[1][0],\n      y1 = source[1][1];\n    let x2 = source[2][0],\n      y2 = source[2][1];\n    // Make sure that everything is on pixel boundaries\n    const u0 = pixelRound((target[0][0] - targetTopLeft[0]) / targetResolution);\n    const v0 = pixelRound(\n      -(target[0][1] - targetTopLeft[1]) / targetResolution\n    );\n    const u1 = pixelRound((target[1][0] - targetTopLeft[0]) / targetResolution);\n    const v1 = pixelRound(\n      -(target[1][1] - targetTopLeft[1]) / targetResolution\n    );\n    const u2 = pixelRound((target[2][0] - targetTopLeft[0]) / targetResolution);\n    const v2 = pixelRound(\n      -(target[2][1] - targetTopLeft[1]) / targetResolution\n    );\n\n    // Shift all the source points to improve numerical stability\n    // of all the subsequent calculations. The [x0, y0] is used here.\n    // This is also used to simplify the linear system.\n    const sourceNumericalShiftX = x0;\n    const sourceNumericalShiftY = y0;\n    x0 = 0;\n    y0 = 0;\n    x1 -= sourceNumericalShiftX;\n    y1 -= sourceNumericalShiftY;\n    x2 -= sourceNumericalShiftX;\n    y2 -= sourceNumericalShiftY;\n\n    const augmentedMatrix = [\n      [x1, y1, 0, 0, u1 - u0],\n      [x2, y2, 0, 0, u2 - u0],\n      [0, 0, x1, y1, v1 - v0],\n      [0, 0, x2, y2, v2 - v0],\n    ];\n    const affineCoefs = solveLinearSystem(augmentedMatrix);\n    if (!affineCoefs) {\n      return;\n    }\n\n    context.save();\n    context.beginPath();\n\n    if (\n      isBrokenDiagonalRendering() ||\n      opt_contextOptions === IMAGE_SMOOTHING_DISABLED\n    ) {\n      // Make sure that all lines are horizontal or vertical\n      context.moveTo(u1, v1);\n      // This is the diagonal line. Do it in 4 steps\n      const steps = 4;\n      const ud = u0 - u1;\n      const vd = v0 - v1;\n      for (let step = 0; step < steps; step++) {\n        // Go horizontally\n        context.lineTo(\n          u1 + pixelRound(((step + 1) * ud) / steps),\n          v1 + pixelRound((step * vd) / (steps - 1))\n        );\n        // Go vertically\n        if (step != steps - 1) {\n          context.lineTo(\n            u1 + pixelRound(((step + 1) * ud) / steps),\n            v1 + pixelRound(((step + 1) * vd) / (steps - 1))\n          );\n        }\n      }\n      // We are almost at u0r, v0r\n      context.lineTo(u2, v2);\n    } else {\n      context.moveTo(u1, v1);\n      context.lineTo(u0, v0);\n      context.lineTo(u2, v2);\n    }\n\n    context.clip();\n\n    context.transform(\n      affineCoefs[0],\n      affineCoefs[2],\n      affineCoefs[1],\n      affineCoefs[3],\n      u0,\n      v0\n    );\n\n    context.translate(\n      sourceDataExtent[0] - sourceNumericalShiftX,\n      sourceDataExtent[3] - sourceNumericalShiftY\n    );\n\n    context.scale(\n      sourceResolution / pixelRatio,\n      -sourceResolution / pixelRatio\n    );\n\n    context.drawImage(stitchContext.canvas, 0, 0);\n    context.restore();\n  });\n\n  if (opt_renderEdges) {\n    context.save();\n\n    context.globalCompositeOperation = 'source-over';\n    context.strokeStyle = 'black';\n    context.lineWidth = 1;\n\n    triangulation.getTriangles().forEach(function (triangle, i, arr) {\n      const target = triangle.target;\n      const u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;\n      const v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;\n      const u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;\n      const v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;\n      const u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;\n      const v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;\n\n      context.beginPath();\n      context.moveTo(u1, v1);\n      context.lineTo(u0, v0);\n      context.lineTo(u2, v2);\n      context.closePath();\n      context.stroke();\n    });\n\n    context.restore();\n  }\n  return context.canvas;\n}\n","/**\n * @module ol/reproj/Triangulation\n */\nimport {\n  boundingExtent,\n  createEmpty,\n  extendCoordinate,\n  getArea,\n  getBottomLeft,\n  getBottomRight,\n  getTopLeft,\n  getTopRight,\n  getWidth,\n  intersects,\n} from '../extent.js';\nimport {getTransform} from '../proj.js';\nimport {log2, modulo} from '../math.js';\n\n/**\n * Single triangle; consists of 3 source points and 3 target points.\n * @typedef {Object} Triangle\n * @property {Array<import(\"../coordinate.js\").Coordinate>} source Source.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} target Target.\n */\n\n/**\n * Maximum number of subdivision steps during raster reprojection triangulation.\n * Prevents high memory usage and large number of proj4 calls (for certain\n * transformations and areas). At most `2*(2^this)` triangles are created for\n * each triangulated extent (tile/image).\n * @type {number}\n */\nconst MAX_SUBDIVISION = 10;\n\n/**\n * Maximum allowed size of triangle relative to world width. When transforming\n * corners of world extent between certain projections, the resulting\n * triangulation seems to have zero error and no subdivision is performed. If\n * the triangle width is more than this (relative to world width; 0-1),\n * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.\n * @type {number}\n */\nconst MAX_TRIANGLE_WIDTH = 0.25;\n\n/**\n * @classdesc\n * Class containing triangulation of the given target extent.\n * Used for determining source data and the reprojection itself.\n */\nclass Triangulation {\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../extent.js\").Extent} targetExtent Target extent to triangulate.\n   * @param {import(\"../extent.js\").Extent} maxSourceExtent Maximal source extent that can be used.\n   * @param {number} errorThreshold Acceptable error (in source units).\n   * @param {?number} opt_destinationResolution The (optional) resolution of the destination.\n   */\n  constructor(\n    sourceProj,\n    targetProj,\n    targetExtent,\n    maxSourceExtent,\n    errorThreshold,\n    opt_destinationResolution\n  ) {\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     * @private\n     */\n    this.sourceProj_ = sourceProj;\n\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     * @private\n     */\n    this.targetProj_ = targetProj;\n\n    /** @type {!Object<string, import(\"../coordinate.js\").Coordinate>} */\n    let transformInvCache = {};\n    const transformInv = getTransform(this.targetProj_, this.sourceProj_);\n\n    /**\n     * @param {import(\"../coordinate.js\").Coordinate} c A coordinate.\n     * @return {import(\"../coordinate.js\").Coordinate} Transformed coordinate.\n     * @private\n     */\n    this.transformInv_ = function (c) {\n      const key = c[0] + '/' + c[1];\n      if (!transformInvCache[key]) {\n        transformInvCache[key] = transformInv(c);\n      }\n      return transformInvCache[key];\n    };\n\n    /**\n     * @type {import(\"../extent.js\").Extent}\n     * @private\n     */\n    this.maxSourceExtent_ = maxSourceExtent;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.errorThresholdSquared_ = errorThreshold * errorThreshold;\n\n    /**\n     * @type {Array<Triangle>}\n     * @private\n     */\n    this.triangles_ = [];\n\n    /**\n     * Indicates that the triangulation crosses edge of the source projection.\n     * @type {boolean}\n     * @private\n     */\n    this.wrapsXInSource_ = false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.canWrapXInSource_ =\n      this.sourceProj_.canWrapX() &&\n      !!maxSourceExtent &&\n      !!this.sourceProj_.getExtent() &&\n      getWidth(maxSourceExtent) == getWidth(this.sourceProj_.getExtent());\n\n    /**\n     * @type {?number}\n     * @private\n     */\n    this.sourceWorldWidth_ = this.sourceProj_.getExtent()\n      ? getWidth(this.sourceProj_.getExtent())\n      : null;\n\n    /**\n     * @type {?number}\n     * @private\n     */\n    this.targetWorldWidth_ = this.targetProj_.getExtent()\n      ? getWidth(this.targetProj_.getExtent())\n      : null;\n\n    const destinationTopLeft = getTopLeft(targetExtent);\n    const destinationTopRight = getTopRight(targetExtent);\n    const destinationBottomRight = getBottomRight(targetExtent);\n    const destinationBottomLeft = getBottomLeft(targetExtent);\n    const sourceTopLeft = this.transformInv_(destinationTopLeft);\n    const sourceTopRight = this.transformInv_(destinationTopRight);\n    const sourceBottomRight = this.transformInv_(destinationBottomRight);\n    const sourceBottomLeft = this.transformInv_(destinationBottomLeft);\n\n    /*\n     * The maxSubdivision controls how many splittings of the target area can\n     * be done. The idea here is to do a linear mapping of the target areas\n     * but the actual overal reprojection (can be) extremely non-linear. The\n     * default value of MAX_SUBDIVISION was chosen based on mapping a 256x256\n     * tile size. However this function is also called to remap canvas rendered\n     * layers which can be much larger. This calculation increases the maxSubdivision\n     * value by the right factor so that each 256x256 pixel area has\n     * MAX_SUBDIVISION divisions.\n     */\n    const maxSubdivision =\n      MAX_SUBDIVISION +\n      (opt_destinationResolution\n        ? Math.max(\n            0,\n            Math.ceil(\n              log2(\n                getArea(targetExtent) /\n                  (opt_destinationResolution *\n                    opt_destinationResolution *\n                    256 *\n                    256)\n              )\n            )\n          )\n        : 0);\n\n    this.addQuad_(\n      destinationTopLeft,\n      destinationTopRight,\n      destinationBottomRight,\n      destinationBottomLeft,\n      sourceTopLeft,\n      sourceTopRight,\n      sourceBottomRight,\n      sourceBottomLeft,\n      maxSubdivision\n    );\n\n    if (this.wrapsXInSource_) {\n      let leftBound = Infinity;\n      this.triangles_.forEach(function (triangle, i, arr) {\n        leftBound = Math.min(\n          leftBound,\n          triangle.source[0][0],\n          triangle.source[1][0],\n          triangle.source[2][0]\n        );\n      });\n\n      // Shift triangles to be as close to `leftBound` as possible\n      // (if the distance is more than `worldWidth / 2` it can be closer.\n      this.triangles_.forEach(\n        function (triangle) {\n          if (\n            Math.max(\n              triangle.source[0][0],\n              triangle.source[1][0],\n              triangle.source[2][0]\n            ) -\n              leftBound >\n            this.sourceWorldWidth_ / 2\n          ) {\n            const newTriangle = [\n              [triangle.source[0][0], triangle.source[0][1]],\n              [triangle.source[1][0], triangle.source[1][1]],\n              [triangle.source[2][0], triangle.source[2][1]],\n            ];\n            if (newTriangle[0][0] - leftBound > this.sourceWorldWidth_ / 2) {\n              newTriangle[0][0] -= this.sourceWorldWidth_;\n            }\n            if (newTriangle[1][0] - leftBound > this.sourceWorldWidth_ / 2) {\n              newTriangle[1][0] -= this.sourceWorldWidth_;\n            }\n            if (newTriangle[2][0] - leftBound > this.sourceWorldWidth_ / 2) {\n              newTriangle[2][0] -= this.sourceWorldWidth_;\n            }\n\n            // Rarely (if the extent contains both the dateline and prime meridian)\n            // the shift can in turn break some triangles.\n            // Detect this here and don't shift in such cases.\n            const minX = Math.min(\n              newTriangle[0][0],\n              newTriangle[1][0],\n              newTriangle[2][0]\n            );\n            const maxX = Math.max(\n              newTriangle[0][0],\n              newTriangle[1][0],\n              newTriangle[2][0]\n            );\n            if (maxX - minX < this.sourceWorldWidth_ / 2) {\n              triangle.source = newTriangle;\n            }\n          }\n        }.bind(this)\n      );\n    }\n\n    transformInvCache = {};\n  }\n\n  /**\n   * Adds triangle to the triangulation.\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n   * @private\n   */\n  addTriangle_(a, b, c, aSrc, bSrc, cSrc) {\n    this.triangles_.push({\n      source: [aSrc, bSrc, cSrc],\n      target: [a, b, c],\n    });\n  }\n\n  /**\n   * Adds quad (points in clock-wise order) to the triangulation\n   * (and reprojects the vertices) if valid.\n   * Performs quad subdivision if needed to increase precision.\n   *\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} d The target d coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} dSrc The source d coordinate.\n   * @param {number} maxSubdivision Maximal allowed subdivision of the quad.\n   * @private\n   */\n  addQuad_(a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {\n    const sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);\n    const sourceCoverageX = this.sourceWorldWidth_\n      ? getWidth(sourceQuadExtent) / this.sourceWorldWidth_\n      : null;\n    const sourceWorldWidth = /** @type {number} */ (this.sourceWorldWidth_);\n\n    // when the quad is wrapped in the source projection\n    // it covers most of the projection extent, but not fully\n    const wrapsX =\n      this.sourceProj_.canWrapX() &&\n      sourceCoverageX > 0.5 &&\n      sourceCoverageX < 1;\n\n    let needsSubdivision = false;\n\n    if (maxSubdivision > 0) {\n      if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {\n        const targetQuadExtent = boundingExtent([a, b, c, d]);\n        const targetCoverageX =\n          getWidth(targetQuadExtent) / this.targetWorldWidth_;\n        needsSubdivision =\n          targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n      }\n      if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {\n        needsSubdivision =\n          sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n      }\n    }\n\n    if (!needsSubdivision && this.maxSourceExtent_) {\n      if (\n        isFinite(sourceQuadExtent[0]) &&\n        isFinite(sourceQuadExtent[1]) &&\n        isFinite(sourceQuadExtent[2]) &&\n        isFinite(sourceQuadExtent[3])\n      ) {\n        if (!intersects(sourceQuadExtent, this.maxSourceExtent_)) {\n          // whole quad outside source projection extent -> ignore\n          return;\n        }\n      }\n    }\n\n    let isNotFinite = 0;\n\n    if (!needsSubdivision) {\n      if (\n        !isFinite(aSrc[0]) ||\n        !isFinite(aSrc[1]) ||\n        !isFinite(bSrc[0]) ||\n        !isFinite(bSrc[1]) ||\n        !isFinite(cSrc[0]) ||\n        !isFinite(cSrc[1]) ||\n        !isFinite(dSrc[0]) ||\n        !isFinite(dSrc[1])\n      ) {\n        if (maxSubdivision > 0) {\n          needsSubdivision = true;\n        } else {\n          // It might be the case that only 1 of the points is infinite. In this case\n          // we can draw a single triangle with the other three points\n          isNotFinite =\n            (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) +\n            (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) +\n            (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) +\n            (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);\n          if (\n            isNotFinite != 1 &&\n            isNotFinite != 2 &&\n            isNotFinite != 4 &&\n            isNotFinite != 8\n          ) {\n            return;\n          }\n        }\n      }\n    }\n\n    if (maxSubdivision > 0) {\n      if (!needsSubdivision) {\n        const center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];\n        const centerSrc = this.transformInv_(center);\n\n        let dx;\n        if (wrapsX) {\n          const centerSrcEstimX =\n            (modulo(aSrc[0], sourceWorldWidth) +\n              modulo(cSrc[0], sourceWorldWidth)) /\n            2;\n          dx = centerSrcEstimX - modulo(centerSrc[0], sourceWorldWidth);\n        } else {\n          dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];\n        }\n        const dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];\n        const centerSrcErrorSquared = dx * dx + dy * dy;\n        needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;\n      }\n      if (needsSubdivision) {\n        if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {\n          // split horizontally (top & bottom)\n          const bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];\n          const bcSrc = this.transformInv_(bc);\n          const da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];\n          const daSrc = this.transformInv_(da);\n\n          this.addQuad_(\n            a,\n            b,\n            bc,\n            da,\n            aSrc,\n            bSrc,\n            bcSrc,\n            daSrc,\n            maxSubdivision - 1\n          );\n          this.addQuad_(\n            da,\n            bc,\n            c,\n            d,\n            daSrc,\n            bcSrc,\n            cSrc,\n            dSrc,\n            maxSubdivision - 1\n          );\n        } else {\n          // split vertically (left & right)\n          const ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];\n          const abSrc = this.transformInv_(ab);\n          const cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];\n          const cdSrc = this.transformInv_(cd);\n\n          this.addQuad_(\n            a,\n            ab,\n            cd,\n            d,\n            aSrc,\n            abSrc,\n            cdSrc,\n            dSrc,\n            maxSubdivision - 1\n          );\n          this.addQuad_(\n            ab,\n            b,\n            c,\n            cd,\n            abSrc,\n            bSrc,\n            cSrc,\n            cdSrc,\n            maxSubdivision - 1\n          );\n        }\n        return;\n      }\n    }\n\n    if (wrapsX) {\n      if (!this.canWrapXInSource_) {\n        return;\n      }\n      this.wrapsXInSource_ = true;\n    }\n\n    // Exactly zero or one of *Src is not finite\n    // The triangles must have the diagonal line as the first side\n    // This is to allow easy code in reproj.s to make it straight for broken\n    // browsers that can't handle diagonal clipping\n    if ((isNotFinite & 0xb) == 0) {\n      this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);\n    }\n    if ((isNotFinite & 0xe) == 0) {\n      this.addTriangle_(a, c, b, aSrc, cSrc, bSrc);\n    }\n    if (isNotFinite) {\n      // Try the other two triangles\n      if ((isNotFinite & 0xd) == 0) {\n        this.addTriangle_(b, d, a, bSrc, dSrc, aSrc);\n      }\n      if ((isNotFinite & 0x7) == 0) {\n        this.addTriangle_(b, d, c, bSrc, dSrc, cSrc);\n      }\n    }\n  }\n\n  /**\n   * Calculates extent of the 'source' coordinates from all the triangles.\n   *\n   * @return {import(\"../extent.js\").Extent} Calculated extent.\n   */\n  calculateSourceExtent() {\n    const extent = createEmpty();\n\n    this.triangles_.forEach(function (triangle, i, arr) {\n      const src = triangle.source;\n      extendCoordinate(extent, src[0]);\n      extendCoordinate(extent, src[1]);\n      extendCoordinate(extent, src[2]);\n    });\n\n    return extent;\n  }\n\n  /**\n   * @return {Array<Triangle>} Array of the calculated triangles.\n   */\n  getTriangles() {\n    return this.triangles_;\n  }\n}\n\nexport default Triangulation;\n","/**\n * @module ol/source/common\n */\n\n/**\n * Default WMS version.\n * @type {string}\n */\nexport const DEFAULT_WMS_VERSION = '1.3.0';\n\n/**\n * Context options to disable image smoothing.\n * @type {Object}\n */\nexport const IMAGE_SMOOTHING_DISABLED = {\n  imageSmoothingEnabled: false,\n  msImageSmoothingEnabled: false,\n};\n","/**\n * @module ol/reproj/Tile\n */\nimport {ERROR_THRESHOLD} from './common.js';\n\nimport EventType from '../events/EventType.js';\nimport Tile from '../Tile.js';\nimport TileState from '../TileState.js';\nimport Triangulation from './Triangulation.js';\nimport {\n  calculateSourceExtentResolution,\n  render as renderReprojected,\n} from '../reproj.js';\nimport {clamp} from '../math.js';\nimport {getArea, getIntersection} from '../extent.js';\nimport {listen, unlistenByKey} from '../events.js';\n\n/**\n * @typedef {function(number, number, number, number) : import(\"../Tile.js\").default} FunctionType\n */\n\n/**\n * @classdesc\n * Class encapsulating single reprojected tile.\n * See {@link module:ol/source/TileImage~TileImage}.\n *\n */\nclass ReprojTile extends Tile {\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\n   * @param {import(\"../tilecoord.js\").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {number} gutter Gutter of the source tiles.\n   * @param {FunctionType} getTileFunction\n   *     Function returning source tiles (z, x, y, pixelRatio).\n   * @param {number} [opt_errorThreshold] Acceptable reprojection error (in px).\n   * @param {boolean} [opt_renderEdges] Render reprojection edges.\n   * @param {object} [opt_contextOptions] Properties to set on the canvas context.\n   */\n  constructor(\n    sourceProj,\n    sourceTileGrid,\n    targetProj,\n    targetTileGrid,\n    tileCoord,\n    wrappedTileCoord,\n    pixelRatio,\n    gutter,\n    getTileFunction,\n    opt_errorThreshold,\n    opt_renderEdges,\n    opt_contextOptions\n  ) {\n    super(tileCoord, TileState.IDLE);\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.renderEdges_ = opt_renderEdges !== undefined ? opt_renderEdges : false;\n\n    /**\n     * @private\n     * @type {object}\n     */\n    this.contextOptions_ = opt_contextOptions;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = pixelRatio;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.gutter_ = gutter;\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.canvas_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.sourceTileGrid_ = sourceTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.targetTileGrid_ = targetTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilecoord.js\").TileCoord}\n     */\n    this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;\n\n    /**\n     * @private\n     * @type {!Array<import(\"../Tile.js\").default>}\n     */\n    this.sourceTiles_ = [];\n\n    /**\n     * @private\n     * @type {?Array<import(\"../events.js\").EventsKey>}\n     */\n    this.sourcesListenerKeys_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.sourceZ_ = 0;\n\n    const targetExtent = targetTileGrid.getTileCoordExtent(\n      this.wrappedTileCoord_\n    );\n    const maxTargetExtent = this.targetTileGrid_.getExtent();\n    let maxSourceExtent = this.sourceTileGrid_.getExtent();\n\n    const limitedTargetExtent = maxTargetExtent\n      ? getIntersection(targetExtent, maxTargetExtent)\n      : targetExtent;\n\n    if (getArea(limitedTargetExtent) === 0) {\n      // Tile is completely outside range -> EMPTY\n      // TODO: is it actually correct that the source even creates the tile ?\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const sourceProjExtent = sourceProj.getExtent();\n    if (sourceProjExtent) {\n      if (!maxSourceExtent) {\n        maxSourceExtent = sourceProjExtent;\n      } else {\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n      }\n    }\n\n    const targetResolution = targetTileGrid.getResolution(\n      this.wrappedTileCoord_[0]\n    );\n\n    const sourceResolution = calculateSourceExtentResolution(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      targetResolution\n    );\n\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n      // invalid sourceResolution -> EMPTY\n      // probably edges of the projections when no extent is defined\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const errorThresholdInPixels =\n      opt_errorThreshold !== undefined ? opt_errorThreshold : ERROR_THRESHOLD;\n\n    /**\n     * @private\n     * @type {!import(\"./Triangulation.js\").default}\n     */\n    this.triangulation_ = new Triangulation(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      maxSourceExtent,\n      sourceResolution * errorThresholdInPixels,\n      targetResolution\n    );\n\n    if (this.triangulation_.getTriangles().length === 0) {\n      // no valid triangles -> EMPTY\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);\n    let sourceExtent = this.triangulation_.calculateSourceExtent();\n\n    if (maxSourceExtent) {\n      if (sourceProj.canWrapX()) {\n        sourceExtent[1] = clamp(\n          sourceExtent[1],\n          maxSourceExtent[1],\n          maxSourceExtent[3]\n        );\n        sourceExtent[3] = clamp(\n          sourceExtent[3],\n          maxSourceExtent[1],\n          maxSourceExtent[3]\n        );\n      } else {\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n      }\n    }\n\n    if (!getArea(sourceExtent)) {\n      this.state = TileState.EMPTY;\n    } else {\n      const sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(\n        sourceExtent,\n        this.sourceZ_\n      );\n\n      for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n        for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n          const tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);\n          if (tile) {\n            this.sourceTiles_.push(tile);\n          }\n        }\n      }\n\n      if (this.sourceTiles_.length === 0) {\n        this.state = TileState.EMPTY;\n      }\n    }\n  }\n\n  /**\n   * Get the HTML Canvas element for this tile.\n   * @return {HTMLCanvasElement} Canvas.\n   */\n  getImage() {\n    return this.canvas_;\n  }\n\n  /**\n   * @private\n   */\n  reproject_() {\n    const sources = [];\n    this.sourceTiles_.forEach(\n      function (tile, i, arr) {\n        if (tile && tile.getState() == TileState.LOADED) {\n          sources.push({\n            extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),\n            image: tile.getImage(),\n          });\n        }\n      }.bind(this)\n    );\n    this.sourceTiles_.length = 0;\n\n    if (sources.length === 0) {\n      this.state = TileState.ERROR;\n    } else {\n      const z = this.wrappedTileCoord_[0];\n      const size = this.targetTileGrid_.getTileSize(z);\n      const width = typeof size === 'number' ? size : size[0];\n      const height = typeof size === 'number' ? size : size[1];\n      const targetResolution = this.targetTileGrid_.getResolution(z);\n      const sourceResolution = this.sourceTileGrid_.getResolution(\n        this.sourceZ_\n      );\n\n      const targetExtent = this.targetTileGrid_.getTileCoordExtent(\n        this.wrappedTileCoord_\n      );\n      this.canvas_ = renderReprojected(\n        width,\n        height,\n        this.pixelRatio_,\n        sourceResolution,\n        this.sourceTileGrid_.getExtent(),\n        targetResolution,\n        targetExtent,\n        this.triangulation_,\n        sources,\n        this.gutter_,\n        this.renderEdges_,\n        this.contextOptions_\n      );\n\n      this.state = TileState.LOADED;\n    }\n    this.changed();\n  }\n\n  /**\n   * Load not yet loaded URI.\n   */\n  load() {\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      this.changed();\n\n      let leftToLoad = 0;\n\n      this.sourcesListenerKeys_ = [];\n      this.sourceTiles_.forEach(\n        function (tile, i, arr) {\n          const state = tile.getState();\n          if (state == TileState.IDLE || state == TileState.LOADING) {\n            leftToLoad++;\n\n            const sourceListenKey = listen(\n              tile,\n              EventType.CHANGE,\n              function (e) {\n                const state = tile.getState();\n                if (\n                  state == TileState.LOADED ||\n                  state == TileState.ERROR ||\n                  state == TileState.EMPTY\n                ) {\n                  unlistenByKey(sourceListenKey);\n                  leftToLoad--;\n                  if (leftToLoad === 0) {\n                    this.unlistenSources_();\n                    this.reproject_();\n                  }\n                }\n              },\n              this\n            );\n            this.sourcesListenerKeys_.push(sourceListenKey);\n          }\n        }.bind(this)\n      );\n\n      this.sourceTiles_.forEach(function (tile, i, arr) {\n        const state = tile.getState();\n        if (state == TileState.IDLE) {\n          tile.load();\n        }\n      });\n\n      if (leftToLoad === 0) {\n        setTimeout(this.reproject_.bind(this), 0);\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  unlistenSources_() {\n    this.sourcesListenerKeys_.forEach(unlistenByKey);\n    this.sourcesListenerKeys_ = null;\n  }\n}\n\nexport default ReprojTile;\n","/**\n * @module ol/reproj/common\n */\n\n/**\n * Default maximum allowed threshold  (in pixels) for reprojection\n * triangulation.\n * @type {number}\n */\nexport const ERROR_THRESHOLD = 0.5;\n\n/**\n * Enable automatic reprojection of raster sources. Default is `true`.\n * TODO: decide if we want to expose this as a build flag or remove it\n * @type {boolean}\n */\nexport const ENABLE_RASTER_REPROJECTION = true;\n","/**\n * @module ol/structs/LRUCache\n */\n\nimport {assert} from '../asserts.js';\n\n/**\n * @typedef {Object} Entry\n * @property {string} key_ Key.\n * @property {Object} newer Newer.\n * @property {Object} older Older.\n * @property {*} value_ Value.\n */\n\n/**\n * @classdesc\n * Implements a Least-Recently-Used cache where the keys do not conflict with\n * Object's properties (e.g. 'hasOwnProperty' is not allowed as a key). Expiring\n * items from the cache is the responsibility of the user.\n *\n * @fires import(\"../events/Event.js\").default\n * @template T\n */\nclass LRUCache {\n  /**\n   * @param {number} [opt_highWaterMark] High water mark.\n   */\n  constructor(opt_highWaterMark) {\n    /**\n     * Desired max cache size after expireCache(). If set to 0, no cache entries\n     * will be pruned at all.\n     * @type {number}\n     */\n    this.highWaterMark =\n      opt_highWaterMark !== undefined ? opt_highWaterMark : 2048;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.count_ = 0;\n\n    /**\n     * @private\n     * @type {!Object<string, Entry>}\n     */\n    this.entries_ = {};\n\n    /**\n     * @private\n     * @type {?Entry}\n     */\n    this.oldest_ = null;\n\n    /**\n     * @private\n     * @type {?Entry}\n     */\n    this.newest_ = null;\n  }\n\n  /**\n   * @return {boolean} Can expire cache.\n   */\n  canExpireCache() {\n    return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;\n  }\n\n  /**\n   * FIXME empty description for jsdoc\n   */\n  clear() {\n    this.count_ = 0;\n    this.entries_ = {};\n    this.oldest_ = null;\n    this.newest_ = null;\n  }\n\n  /**\n   * @param {string} key Key.\n   * @return {boolean} Contains key.\n   */\n  containsKey(key) {\n    return this.entries_.hasOwnProperty(key);\n  }\n\n  /**\n   * @param {function(T, string, LRUCache<T>): ?} f The function\n   *     to call for every entry from the oldest to the newer. This function takes\n   *     3 arguments (the entry value, the entry key and the LRUCache object).\n   *     The return value is ignored.\n   */\n  forEach(f) {\n    let entry = this.oldest_;\n    while (entry) {\n      f(entry.value_, entry.key_, this);\n      entry = entry.newer;\n    }\n  }\n\n  /**\n   * @param {string} key Key.\n   * @param {*} [opt_options] Options (reserved for subclasses).\n   * @return {T} Value.\n   */\n  get(key, opt_options) {\n    const entry = this.entries_[key];\n    assert(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache\n    if (entry === this.newest_) {\n      return entry.value_;\n    } else if (entry === this.oldest_) {\n      this.oldest_ = /** @type {Entry} */ (this.oldest_.newer);\n      this.oldest_.older = null;\n    } else {\n      entry.newer.older = entry.older;\n      entry.older.newer = entry.newer;\n    }\n    entry.newer = null;\n    entry.older = this.newest_;\n    this.newest_.newer = entry;\n    this.newest_ = entry;\n    return entry.value_;\n  }\n\n  /**\n   * Remove an entry from the cache.\n   * @param {string} key The entry key.\n   * @return {T} The removed entry.\n   */\n  remove(key) {\n    const entry = this.entries_[key];\n    assert(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache\n    if (entry === this.newest_) {\n      this.newest_ = /** @type {Entry} */ (entry.older);\n      if (this.newest_) {\n        this.newest_.newer = null;\n      }\n    } else if (entry === this.oldest_) {\n      this.oldest_ = /** @type {Entry} */ (entry.newer);\n      if (this.oldest_) {\n        this.oldest_.older = null;\n      }\n    } else {\n      entry.newer.older = entry.older;\n      entry.older.newer = entry.newer;\n    }\n    delete this.entries_[key];\n    --this.count_;\n    return entry.value_;\n  }\n\n  /**\n   * @return {number} Count.\n   */\n  getCount() {\n    return this.count_;\n  }\n\n  /**\n   * @return {Array<string>} Keys.\n   */\n  getKeys() {\n    const keys = new Array(this.count_);\n    let i = 0;\n    let entry;\n    for (entry = this.newest_; entry; entry = entry.older) {\n      keys[i++] = entry.key_;\n    }\n    return keys;\n  }\n\n  /**\n   * @return {Array<T>} Values.\n   */\n  getValues() {\n    const values = new Array(this.count_);\n    let i = 0;\n    let entry;\n    for (entry = this.newest_; entry; entry = entry.older) {\n      values[i++] = entry.value_;\n    }\n    return values;\n  }\n\n  /**\n   * @return {T} Last value.\n   */\n  peekLast() {\n    return this.oldest_.value_;\n  }\n\n  /**\n   * @return {string} Last key.\n   */\n  peekLastKey() {\n    return this.oldest_.key_;\n  }\n\n  /**\n   * Get the key of the newest item in the cache.  Throws if the cache is empty.\n   * @return {string} The newest key.\n   */\n  peekFirstKey() {\n    return this.newest_.key_;\n  }\n\n  /**\n   * @return {T} value Value.\n   */\n  pop() {\n    const entry = this.oldest_;\n    delete this.entries_[entry.key_];\n    if (entry.newer) {\n      entry.newer.older = null;\n    }\n    this.oldest_ = /** @type {Entry} */ (entry.newer);\n    if (!this.oldest_) {\n      this.newest_ = null;\n    }\n    --this.count_;\n    return entry.value_;\n  }\n\n  /**\n   * @param {string} key Key.\n   * @param {T} value Value.\n   */\n  replace(key, value) {\n    this.get(key); // update `newest_`\n    this.entries_[key].value_ = value;\n  }\n\n  /**\n   * @param {string} key Key.\n   * @param {T} value Value.\n   */\n  set(key, value) {\n    assert(!(key in this.entries_), 16); // Tried to set a value for a key that is used already\n    const entry = {\n      key_: key,\n      newer: null,\n      older: this.newest_,\n      value_: value,\n    };\n    if (!this.newest_) {\n      this.oldest_ = entry;\n    } else {\n      this.newest_.newer = entry;\n    }\n    this.newest_ = entry;\n    this.entries_[key] = entry;\n    ++this.count_;\n  }\n\n  /**\n   * Set a maximum number of entries for the cache.\n   * @param {number} size Cache size.\n   * @api\n   */\n  setSize(size) {\n    this.highWaterMark = size;\n  }\n}\n\nexport default LRUCache;\n","/**\n * @module ol/tilecoord\n */\n\n/**\n * An array of three numbers representing the location of a tile in a tile\n * grid. The order is `z` (zoom level), `x` (column), and `y` (row).\n * @typedef {Array<number>} TileCoord\n * @api\n */\n\n/**\n * @param {number} z Z.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {TileCoord} [opt_tileCoord] Tile coordinate.\n * @return {TileCoord} Tile coordinate.\n */\nexport function createOrUpdate(z, x, y, opt_tileCoord) {\n  if (opt_tileCoord !== undefined) {\n    opt_tileCoord[0] = z;\n    opt_tileCoord[1] = x;\n    opt_tileCoord[2] = y;\n    return opt_tileCoord;\n  } else {\n    return [z, x, y];\n  }\n}\n\n/**\n * @param {number} z Z.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {string} Key.\n */\nexport function getKeyZXY(z, x, y) {\n  return z + '/' + x + '/' + y;\n}\n\n/**\n * Get the key for a tile coord.\n * @param {TileCoord} tileCoord The tile coord.\n * @return {string} Key.\n */\nexport function getKey(tileCoord) {\n  return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);\n}\n\n/**\n * Get a tile coord given a key.\n * @param {string} key The tile coord key.\n * @return {TileCoord} The tile coord.\n */\nexport function fromKey(key) {\n  return key.split('/').map(Number);\n}\n\n/**\n * @param {TileCoord} tileCoord Tile coord.\n * @return {number} Hash.\n */\nexport function hash(tileCoord) {\n  return (tileCoord[1] << tileCoord[0]) + tileCoord[2];\n}\n\n/**\n * @param {TileCoord} tileCoord Tile coordinate.\n * @param {!import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n * @return {boolean} Tile coordinate is within extent and zoom level range.\n */\nexport function withinExtentAndZ(tileCoord, tileGrid) {\n  const z = tileCoord[0];\n  const x = tileCoord[1];\n  const y = tileCoord[2];\n\n  if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {\n    return false;\n  }\n  const tileRange = tileGrid.getFullTileRange(z);\n  if (!tileRange) {\n    return true;\n  } else {\n    return tileRange.containsXY(x, y);\n  }\n}\n","/**\n * @module ol/TileCache\n */\nimport LRUCache from './structs/LRUCache.js';\nimport {fromKey, getKey} from './tilecoord.js';\n\nclass TileCache extends LRUCache {\n  /**\n   * @param {!Object<string, boolean>} usedTiles Used tiles.\n   */\n  expireCache(usedTiles) {\n    while (this.canExpireCache()) {\n      const tile = this.peekLast();\n      if (tile.getKey() in usedTiles) {\n        break;\n      } else {\n        this.pop().release();\n      }\n    }\n  }\n\n  /**\n   * Prune all tiles from the cache that don't have the same z as the newest tile.\n   */\n  pruneExceptNewestZ() {\n    if (this.getCount() === 0) {\n      return;\n    }\n    const key = this.peekFirstKey();\n    const tileCoord = fromKey(key);\n    const z = tileCoord[0];\n    this.forEach(\n      function (tile) {\n        if (tile.tileCoord[0] !== z) {\n          this.remove(getKey(tile.tileCoord));\n          tile.release();\n        }\n      }.bind(this)\n    );\n  }\n}\n\nexport default TileCache;\n","/**\n * @module ol/source/TileEventType\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  /**\n   * Triggered when a tile starts loading.\n   * @event module:ol/source/Tile.TileSourceEvent#tileloadstart\n   * @api\n   */\n  TILELOADSTART: 'tileloadstart',\n\n  /**\n   * Triggered when a tile finishes loading, either when its data is loaded,\n   * or when loading was aborted because the tile is no longer needed.\n   * @event module:ol/source/Tile.TileSourceEvent#tileloadend\n   * @api\n   */\n  TILELOADEND: 'tileloadend',\n\n  /**\n   * Triggered if tile loading results in an error.\n   * @event module:ol/source/Tile.TileSourceEvent#tileloaderror\n   * @api\n   */\n  TILELOADERROR: 'tileloaderror',\n};\n","/**\n * @module ol/tilegrid/TileGrid\n */\nimport TileRange, {\n  createOrUpdate as createOrUpdateTileRange,\n} from '../TileRange.js';\nimport {DEFAULT_TILE_SIZE} from './common.js';\nimport {assert} from '../asserts.js';\nimport {clamp} from '../math.js';\nimport {createOrUpdate, getTopLeft} from '../extent.js';\nimport {createOrUpdate as createOrUpdateTileCoord} from '../tilecoord.js';\nimport {isSorted, linearFindNearest} from '../array.js';\nimport {toSize} from '../size.js';\n\n/**\n * @private\n * @type {import(\"../tilecoord.js\").TileCoord}\n */\nconst tmpTileCoord = [0, 0, 0];\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../extent.js\").Extent} [extent] Extent for the tile grid. No tiles outside this\n * extent will be requested by {@link module:ol/source/Tile} sources. When no `origin` or\n * `origins` are configured, the `origin` will be set to the top-left corner of the extent.\n * @property {number} [minZoom=0] Minimum zoom.\n * @property {import(\"../coordinate.js\").Coordinate} [origin] The tile grid origin, i.e. where the `x`\n * and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left to right and downwards. If not\n * specified, `extent` or `origins` must be provided.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} [origins] Tile grid origins, i.e. where\n * the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If given, the array length\n * should match the length of the `resolutions` array, i.e. each resolution can have a different\n * origin. Tile coordinates increase left to right and downwards. If not specified, `extent` or\n * `origin` must be provided.\n * @property {!Array<number>} resolutions Resolutions. The array index of each resolution needs\n * to match the zoom level. This means that even if a `minZoom` is configured, the resolutions\n * array will have a length of `maxZoom + 1`.\n * @property {Array<import(\"../size.js\").Size>} [sizes] Number of tile rows and columns\n * of the grid for each zoom level. If specified the values\n * define each zoom level's extent together with the `origin` or `origins`.\n * A grid `extent` can be configured in addition, and will further limit the extent\n * for which tile requests are made by sources. If the bottom-left corner of\n * an extent is used as `origin` or `origins`, then the `y` value must be\n * negative because OpenLayers tile coordinates use the top left as the origin.\n * @property {number|import(\"../size.js\").Size} [tileSize] Tile size.\n * Default is `[256, 256]`.\n * @property {Array<import(\"../size.js\").Size>} [tileSizes] Tile sizes. If given, the array length\n * should match the length of the `resolutions` array, i.e. each resolution can have a different\n * tile size.\n */\n\n/**\n * @classdesc\n * Base class for setting the grid pattern for sources accessing tiled-image\n * servers.\n * @api\n */\nclass TileGrid {\n  /**\n   * @param {Options} options Tile grid options.\n   */\n  constructor(options) {\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.minZoom = options.minZoom !== undefined ? options.minZoom : 0;\n\n    /**\n     * @private\n     * @type {!Array<number>}\n     */\n    this.resolutions_ = options.resolutions;\n    assert(\n      isSorted(\n        this.resolutions_,\n        function (a, b) {\n          return b - a;\n        },\n        true\n      ),\n      17\n    ); // `resolutions` must be sorted in descending order\n\n    // check if we've got a consistent zoom factor and origin\n    let zoomFactor;\n    if (!options.origins) {\n      for (let i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {\n        if (!zoomFactor) {\n          zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];\n        } else {\n          if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {\n            zoomFactor = undefined;\n            break;\n          }\n        }\n      }\n    }\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.zoomFactor_ = zoomFactor;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.maxZoom = this.resolutions_.length - 1;\n\n    /**\n     * @private\n     * @type {import(\"../coordinate.js\").Coordinate}\n     */\n    this.origin_ = options.origin !== undefined ? options.origin : null;\n\n    /**\n     * @private\n     * @type {Array<import(\"../coordinate.js\").Coordinate>}\n     */\n    this.origins_ = null;\n    if (options.origins !== undefined) {\n      this.origins_ = options.origins;\n      assert(this.origins_.length == this.resolutions_.length, 20); // Number of `origins` and `resolutions` must be equal\n    }\n\n    const extent = options.extent;\n\n    if (extent !== undefined && !this.origin_ && !this.origins_) {\n      this.origin_ = getTopLeft(extent);\n    }\n\n    assert(\n      (!this.origin_ && this.origins_) || (this.origin_ && !this.origins_),\n      18\n    ); // Either `origin` or `origins` must be configured, never both\n\n    /**\n     * @private\n     * @type {Array<number|import(\"../size.js\").Size>}\n     */\n    this.tileSizes_ = null;\n    if (options.tileSizes !== undefined) {\n      this.tileSizes_ = options.tileSizes;\n      assert(this.tileSizes_.length == this.resolutions_.length, 19); // Number of `tileSizes` and `resolutions` must be equal\n    }\n\n    /**\n     * @private\n     * @type {number|import(\"../size.js\").Size}\n     */\n    this.tileSize_ =\n      options.tileSize !== undefined\n        ? options.tileSize\n        : !this.tileSizes_\n        ? DEFAULT_TILE_SIZE\n        : null;\n    assert(\n      (!this.tileSize_ && this.tileSizes_) ||\n        (this.tileSize_ && !this.tileSizes_),\n      22\n    ); // Either `tileSize` or `tileSizes` must be configured, never both\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.extent_ = extent !== undefined ? extent : null;\n\n    /**\n     * @private\n     * @type {Array<import(\"../TileRange.js\").default>}\n     */\n    this.fullTileRanges_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../size.js\").Size}\n     */\n    this.tmpSize_ = [0, 0];\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.tmpExtent_ = [0, 0, 0, 0];\n\n    if (options.sizes !== undefined) {\n      this.fullTileRanges_ = options.sizes.map(function (size, z) {\n        const tileRange = new TileRange(\n          Math.min(0, size[0]),\n          Math.max(size[0] - 1, -1),\n          Math.min(0, size[1]),\n          Math.max(size[1] - 1, -1)\n        );\n        if (extent) {\n          const restrictedTileRange = this.getTileRangeForExtentAndZ(extent, z);\n          tileRange.minX = Math.max(restrictedTileRange.minX, tileRange.minX);\n          tileRange.maxX = Math.min(restrictedTileRange.maxX, tileRange.maxX);\n          tileRange.minY = Math.max(restrictedTileRange.minY, tileRange.minY);\n          tileRange.maxY = Math.min(restrictedTileRange.maxY, tileRange.maxY);\n        }\n        return tileRange;\n      }, this);\n    } else if (extent) {\n      this.calculateTileRanges_(extent);\n    }\n  }\n\n  /**\n   * Call a function with each tile coordinate for a given extent and zoom level.\n   *\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} zoom Integer zoom level.\n   * @param {function(import(\"../tilecoord.js\").TileCoord): void} callback Function called with each tile coordinate.\n   * @api\n   */\n  forEachTileCoord(extent, zoom, callback) {\n    const tileRange = this.getTileRangeForExtentAndZ(extent, zoom);\n    for (let i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {\n      for (let j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {\n        callback([zoom, i, j]);\n      }\n    }\n  }\n\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {function(number, import(\"../TileRange.js\").default): boolean} callback Callback.\n   * @param {import(\"../TileRange.js\").default} [opt_tileRange] Temporary import(\"../TileRange.js\").default object.\n   * @param {import(\"../extent.js\").Extent} [opt_extent] Temporary import(\"../extent.js\").Extent object.\n   * @return {boolean} Callback succeeded.\n   */\n  forEachTileCoordParentTileRange(\n    tileCoord,\n    callback,\n    opt_tileRange,\n    opt_extent\n  ) {\n    let tileRange, x, y;\n    let tileCoordExtent = null;\n    let z = tileCoord[0] - 1;\n    if (this.zoomFactor_ === 2) {\n      x = tileCoord[1];\n      y = tileCoord[2];\n    } else {\n      tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);\n    }\n    while (z >= this.minZoom) {\n      if (this.zoomFactor_ === 2) {\n        x = Math.floor(x / 2);\n        y = Math.floor(y / 2);\n        tileRange = createOrUpdateTileRange(x, x, y, y, opt_tileRange);\n      } else {\n        tileRange = this.getTileRangeForExtentAndZ(\n          tileCoordExtent,\n          z,\n          opt_tileRange\n        );\n      }\n      if (callback(z, tileRange)) {\n        return true;\n      }\n      --z;\n    }\n    return false;\n  }\n\n  /**\n   * Get the extent for this tile grid, if it was configured.\n   * @return {import(\"../extent.js\").Extent} Extent.\n   * @api\n   */\n  getExtent() {\n    return this.extent_;\n  }\n\n  /**\n   * Get the maximum zoom level for the grid.\n   * @return {number} Max zoom.\n   * @api\n   */\n  getMaxZoom() {\n    return this.maxZoom;\n  }\n\n  /**\n   * Get the minimum zoom level for the grid.\n   * @return {number} Min zoom.\n   * @api\n   */\n  getMinZoom() {\n    return this.minZoom;\n  }\n\n  /**\n   * Get the origin for the grid at the given zoom level.\n   * @param {number} z Integer zoom level.\n   * @return {import(\"../coordinate.js\").Coordinate} Origin.\n   * @api\n   */\n  getOrigin(z) {\n    if (this.origin_) {\n      return this.origin_;\n    } else {\n      return this.origins_[z];\n    }\n  }\n\n  /**\n   * Get the resolution for the given zoom level.\n   * @param {number} z Integer zoom level.\n   * @return {number} Resolution.\n   * @api\n   */\n  getResolution(z) {\n    return this.resolutions_[z];\n  }\n\n  /**\n   * Get the list of resolutions for the tile grid.\n   * @return {Array<number>} Resolutions.\n   * @api\n   */\n  getResolutions() {\n    return this.resolutions_;\n  }\n\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"../TileRange.js\").default} [opt_tileRange] Temporary import(\"../TileRange.js\").default object.\n   * @param {import(\"../extent.js\").Extent} [opt_extent] Temporary import(\"../extent.js\").Extent object.\n   * @return {import(\"../TileRange.js\").default} Tile range.\n   */\n  getTileCoordChildTileRange(tileCoord, opt_tileRange, opt_extent) {\n    if (tileCoord[0] < this.maxZoom) {\n      if (this.zoomFactor_ === 2) {\n        const minX = tileCoord[1] * 2;\n        const minY = tileCoord[2] * 2;\n        return createOrUpdateTileRange(\n          minX,\n          minX + 1,\n          minY,\n          minY + 1,\n          opt_tileRange\n        );\n      }\n      const tileCoordExtent = this.getTileCoordExtent(\n        tileCoord,\n        opt_extent || this.tmpExtent_\n      );\n      return this.getTileRangeForExtentAndZ(\n        tileCoordExtent,\n        tileCoord[0] + 1,\n        opt_tileRange\n      );\n    }\n    return null;\n  }\n\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {number} z Integer zoom level.\n   * @param {import(\"../TileRange.js\").default} [opt_tileRange] Temporary import(\"../TileRange.js\").default object.\n   * @return {import(\"../TileRange.js\").default} Tile range.\n   */\n  getTileRangeForTileCoordAndZ(tileCoord, z, opt_tileRange) {\n    if (z > this.maxZoom || z < this.minZoom) {\n      return null;\n    }\n\n    const tileCoordZ = tileCoord[0];\n    const tileCoordX = tileCoord[1];\n    const tileCoordY = tileCoord[2];\n\n    if (z === tileCoordZ) {\n      return createOrUpdateTileRange(\n        tileCoordX,\n        tileCoordY,\n        tileCoordX,\n        tileCoordY,\n        opt_tileRange\n      );\n    }\n\n    if (this.zoomFactor_) {\n      const factor = Math.pow(this.zoomFactor_, z - tileCoordZ);\n      const minX = Math.floor(tileCoordX * factor);\n      const minY = Math.floor(tileCoordY * factor);\n      if (z < tileCoordZ) {\n        return createOrUpdateTileRange(minX, minX, minY, minY, opt_tileRange);\n      }\n\n      const maxX = Math.floor(factor * (tileCoordX + 1)) - 1;\n      const maxY = Math.floor(factor * (tileCoordY + 1)) - 1;\n      return createOrUpdateTileRange(minX, maxX, minY, maxY, opt_tileRange);\n    }\n\n    const tileCoordExtent = this.getTileCoordExtent(tileCoord, this.tmpExtent_);\n    return this.getTileRangeForExtentAndZ(tileCoordExtent, z, opt_tileRange);\n  }\n\n  /**\n   * Get the extent for a tile range.\n   * @param {number} z Integer zoom level.\n   * @param {import(\"../TileRange.js\").default} tileRange Tile range.\n   * @param {import(\"../extent.js\").Extent} [opt_extent] Temporary import(\"../extent.js\").Extent object.\n   * @return {import(\"../extent.js\").Extent} Extent.\n   */\n  getTileRangeExtent(z, tileRange, opt_extent) {\n    const origin = this.getOrigin(z);\n    const resolution = this.getResolution(z);\n    const tileSize = toSize(this.getTileSize(z), this.tmpSize_);\n    const minX = origin[0] + tileRange.minX * tileSize[0] * resolution;\n    const maxX = origin[0] + (tileRange.maxX + 1) * tileSize[0] * resolution;\n    const minY = origin[1] + tileRange.minY * tileSize[1] * resolution;\n    const maxY = origin[1] + (tileRange.maxY + 1) * tileSize[1] * resolution;\n    return createOrUpdate(minX, minY, maxX, maxY, opt_extent);\n  }\n\n  /**\n   * Get a tile range for the given extent and integer zoom level.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} z Integer zoom level.\n   * @param {import(\"../TileRange.js\").default} [opt_tileRange] Temporary tile range object.\n   * @return {import(\"../TileRange.js\").default} Tile range.\n   */\n  getTileRangeForExtentAndZ(extent, z, opt_tileRange) {\n    const tileCoord = tmpTileCoord;\n    this.getTileCoordForXYAndZ_(extent[0], extent[3], z, false, tileCoord);\n    const minX = tileCoord[1];\n    const minY = tileCoord[2];\n    this.getTileCoordForXYAndZ_(extent[2], extent[1], z, true, tileCoord);\n    return createOrUpdateTileRange(\n      minX,\n      tileCoord[1],\n      minY,\n      tileCoord[2],\n      opt_tileRange\n    );\n  }\n\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @return {import(\"../coordinate.js\").Coordinate} Tile center.\n   */\n  getTileCoordCenter(tileCoord) {\n    const origin = this.getOrigin(tileCoord[0]);\n    const resolution = this.getResolution(tileCoord[0]);\n    const tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);\n    return [\n      origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution,\n      origin[1] - (tileCoord[2] + 0.5) * tileSize[1] * resolution,\n    ];\n  }\n\n  /**\n   * Get the extent of a tile coordinate.\n   *\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"../extent.js\").Extent} [opt_extent] Temporary extent object.\n   * @return {import(\"../extent.js\").Extent} Extent.\n   * @api\n   */\n  getTileCoordExtent(tileCoord, opt_extent) {\n    const origin = this.getOrigin(tileCoord[0]);\n    const resolution = this.getResolution(tileCoord[0]);\n    const tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);\n    const minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;\n    const minY = origin[1] - (tileCoord[2] + 1) * tileSize[1] * resolution;\n    const maxX = minX + tileSize[0] * resolution;\n    const maxY = minY + tileSize[1] * resolution;\n    return createOrUpdate(minX, minY, maxX, maxY, opt_extent);\n  }\n\n  /**\n   * Get the tile coordinate for the given map coordinate and resolution.  This\n   * method considers that coordinates that intersect tile boundaries should be\n   * assigned the higher tile coordinate.\n   *\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {number} resolution Resolution.\n   * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Destination import(\"../tilecoord.js\").TileCoord object.\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n   * @api\n   */\n  getTileCoordForCoordAndResolution(coordinate, resolution, opt_tileCoord) {\n    return this.getTileCoordForXYAndResolution_(\n      coordinate[0],\n      coordinate[1],\n      resolution,\n      false,\n      opt_tileCoord\n    );\n  }\n\n  /**\n   * Note that this method should not be called for resolutions that correspond\n   * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {number} resolution Resolution (for a non-integer zoom level).\n   * @param {boolean} reverseIntersectionPolicy Instead of letting edge\n   *     intersections go to the higher tile coordinate, let edge intersections\n   *     go to the lower tile coordinate.\n   * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Temporary import(\"../tilecoord.js\").TileCoord object.\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n   * @private\n   */\n  getTileCoordForXYAndResolution_(\n    x,\n    y,\n    resolution,\n    reverseIntersectionPolicy,\n    opt_tileCoord\n  ) {\n    const z = this.getZForResolution(resolution);\n    const scale = resolution / this.getResolution(z);\n    const origin = this.getOrigin(z);\n    const tileSize = toSize(this.getTileSize(z), this.tmpSize_);\n\n    const adjustX = reverseIntersectionPolicy ? 0.5 : 0;\n    const adjustY = reverseIntersectionPolicy ? 0.5 : 0;\n    const xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);\n    const yFromOrigin = Math.floor((origin[1] - y) / resolution + adjustY);\n    let tileCoordX = (scale * xFromOrigin) / tileSize[0];\n    let tileCoordY = (scale * yFromOrigin) / tileSize[1];\n\n    if (reverseIntersectionPolicy) {\n      tileCoordX = Math.ceil(tileCoordX) - 1;\n      tileCoordY = Math.ceil(tileCoordY) - 1;\n    } else {\n      tileCoordX = Math.floor(tileCoordX);\n      tileCoordY = Math.floor(tileCoordY);\n    }\n\n    return createOrUpdateTileCoord(z, tileCoordX, tileCoordY, opt_tileCoord);\n  }\n\n  /**\n   * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,\n   * they should have separate implementations.  This method is for integer zoom\n   * levels.  The other method should only be called for resolutions corresponding\n   * to non-integer zoom levels.\n   * @param {number} x Map x coordinate.\n   * @param {number} y Map y coordinate.\n   * @param {number} z Integer zoom level.\n   * @param {boolean} reverseIntersectionPolicy Instead of letting edge\n   *     intersections go to the higher tile coordinate, let edge intersections\n   *     go to the lower tile coordinate.\n   * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Temporary import(\"../tilecoord.js\").TileCoord object.\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n   * @private\n   */\n  getTileCoordForXYAndZ_(x, y, z, reverseIntersectionPolicy, opt_tileCoord) {\n    const origin = this.getOrigin(z);\n    const resolution = this.getResolution(z);\n    const tileSize = toSize(this.getTileSize(z), this.tmpSize_);\n\n    const adjustX = reverseIntersectionPolicy ? 0.5 : 0;\n    const adjustY = reverseIntersectionPolicy ? 0.5 : 0;\n    const xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);\n    const yFromOrigin = Math.floor((origin[1] - y) / resolution + adjustY);\n    let tileCoordX = xFromOrigin / tileSize[0];\n    let tileCoordY = yFromOrigin / tileSize[1];\n\n    if (reverseIntersectionPolicy) {\n      tileCoordX = Math.ceil(tileCoordX) - 1;\n      tileCoordY = Math.ceil(tileCoordY) - 1;\n    } else {\n      tileCoordX = Math.floor(tileCoordX);\n      tileCoordY = Math.floor(tileCoordY);\n    }\n\n    return createOrUpdateTileCoord(z, tileCoordX, tileCoordY, opt_tileCoord);\n  }\n\n  /**\n   * Get a tile coordinate given a map coordinate and zoom level.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {number} z Zoom level.\n   * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Destination import(\"../tilecoord.js\").TileCoord object.\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n   * @api\n   */\n  getTileCoordForCoordAndZ(coordinate, z, opt_tileCoord) {\n    return this.getTileCoordForXYAndZ_(\n      coordinate[0],\n      coordinate[1],\n      z,\n      false,\n      opt_tileCoord\n    );\n  }\n\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @return {number} Tile resolution.\n   */\n  getTileCoordResolution(tileCoord) {\n    return this.resolutions_[tileCoord[0]];\n  }\n\n  /**\n   * Get the tile size for a zoom level. The type of the return value matches the\n   * `tileSize` or `tileSizes` that the tile grid was configured with. To always\n   * get an `import(\"../size.js\").Size`, run the result through `import(\"../size.js\").Size.toSize()`.\n   * @param {number} z Z.\n   * @return {number|import(\"../size.js\").Size} Tile size.\n   * @api\n   */\n  getTileSize(z) {\n    if (this.tileSize_) {\n      return this.tileSize_;\n    } else {\n      return this.tileSizes_[z];\n    }\n  }\n\n  /**\n   * @param {number} z Zoom level.\n   * @return {import(\"../TileRange.js\").default} Extent tile range for the specified zoom level.\n   */\n  getFullTileRange(z) {\n    if (!this.fullTileRanges_) {\n      return this.extent_\n        ? this.getTileRangeForExtentAndZ(this.extent_, z)\n        : null;\n    } else {\n      return this.fullTileRanges_[z];\n    }\n  }\n\n  /**\n   * @param {number} resolution Resolution.\n   * @param {number} [opt_direction] If 0, the nearest resolution will be used.\n   *     If 1, the nearest lower resolution will be used. If -1, the nearest\n   *     higher resolution will be used. Default is 0.\n   * @return {number} Z.\n   * @api\n   */\n  getZForResolution(resolution, opt_direction) {\n    const z = linearFindNearest(\n      this.resolutions_,\n      resolution,\n      opt_direction || 0\n    );\n    return clamp(z, this.minZoom, this.maxZoom);\n  }\n\n  /**\n   * @param {!import(\"../extent.js\").Extent} extent Extent for this tile grid.\n   * @private\n   */\n  calculateTileRanges_(extent) {\n    const length = this.resolutions_.length;\n    const fullTileRanges = new Array(length);\n    for (let z = this.minZoom; z < length; ++z) {\n      fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);\n    }\n    this.fullTileRanges_ = fullTileRanges;\n  }\n}\n\nexport default TileGrid;\n","/**\n * @module ol/tilegrid\n */\nimport Corner from './extent/Corner.js';\nimport TileGrid from './tilegrid/TileGrid.js';\nimport Units from './proj/Units.js';\nimport {DEFAULT_MAX_ZOOM, DEFAULT_TILE_SIZE} from './tilegrid/common.js';\nimport {METERS_PER_UNIT, get as getProjection} from './proj.js';\nimport {\n  containsCoordinate,\n  createOrUpdate,\n  getCorner,\n  getHeight,\n  getWidth,\n} from './extent.js';\nimport {toSize} from './size.js';\n\n/**\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {!TileGrid} Default tile grid for the\n * passed projection.\n */\nexport function getForProjection(projection) {\n  let tileGrid = projection.getDefaultTileGrid();\n  if (!tileGrid) {\n    tileGrid = createForProjection(projection);\n    projection.setDefaultTileGrid(tileGrid);\n  }\n  return tileGrid;\n}\n\n/**\n * @param {TileGrid} tileGrid Tile grid.\n * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {import(\"./tilecoord.js\").TileCoord} Tile coordinate.\n */\nexport function wrapX(tileGrid, tileCoord, projection) {\n  const z = tileCoord[0];\n  const center = tileGrid.getTileCoordCenter(tileCoord);\n  const projectionExtent = extentFromProjection(projection);\n  if (!containsCoordinate(projectionExtent, center)) {\n    const worldWidth = getWidth(projectionExtent);\n    const worldsAway = Math.ceil(\n      (projectionExtent[0] - center[0]) / worldWidth\n    );\n    center[0] += worldWidth * worldsAway;\n    return tileGrid.getTileCoordForCoordAndZ(center, z);\n  } else {\n    return tileCoord;\n  }\n}\n\n/**\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number} [opt_maxZoom] Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size} [opt_tileSize] Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {import(\"./extent/Corner.js\").default} [opt_corner] Extent corner (default is `'top-left'`).\n * @return {!TileGrid} TileGrid instance.\n */\nexport function createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner) {\n  const corner = opt_corner !== undefined ? opt_corner : Corner.TOP_LEFT;\n\n  const resolutions = resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize);\n\n  return new TileGrid({\n    extent: extent,\n    origin: getCorner(extent, corner),\n    resolutions: resolutions,\n    tileSize: opt_tileSize,\n  });\n}\n\n/**\n * @typedef {Object} XYZOptions\n * @property {import(\"./extent.js\").Extent} [extent] Extent for the tile grid. The origin for an XYZ tile grid is the\n * top-left corner of the extent. If `maxResolution` is not provided the zero level of the grid is defined by the resolution\n * at which one tile fits in the provided extent. If not provided, the extent of the EPSG:3857 projection is used.\n * @property {number} [maxResolution] Resolution at level zero.\n * @property {number} [maxZoom] Maximum zoom. The default is `42`. This determines the number of levels\n * in the grid set. For example, a `maxZoom` of 21 means there are 22 levels in the grid set.\n * @property {number} [minZoom=0] Minimum zoom.\n * @property {number|import(\"./size.js\").Size} [tileSize=[256, 256]] Tile size in pixels.\n */\n\n/**\n * Creates a tile grid with a standard XYZ tiling scheme.\n * @param {XYZOptions} [opt_options] Tile grid options.\n * @return {!TileGrid} Tile grid instance.\n * @api\n */\nexport function createXYZ(opt_options) {\n  const xyzOptions = opt_options || {};\n\n  const extent = xyzOptions.extent || getProjection('EPSG:3857').getExtent();\n\n  const gridOptions = {\n    extent: extent,\n    minZoom: xyzOptions.minZoom,\n    tileSize: xyzOptions.tileSize,\n    resolutions: resolutionsFromExtent(\n      extent,\n      xyzOptions.maxZoom,\n      xyzOptions.tileSize,\n      xyzOptions.maxResolution\n    ),\n  };\n  return new TileGrid(gridOptions);\n}\n\n/**\n * Create a resolutions array from an extent.  A zoom factor of 2 is assumed.\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number} [opt_maxZoom] Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size} [opt_tileSize] Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {number} [opt_maxResolution] Resolution at level zero.\n * @return {!Array<number>} Resolutions array.\n */\nfunction resolutionsFromExtent(\n  extent,\n  opt_maxZoom,\n  opt_tileSize,\n  opt_maxResolution\n) {\n  const maxZoom = opt_maxZoom !== undefined ? opt_maxZoom : DEFAULT_MAX_ZOOM;\n\n  const height = getHeight(extent);\n  const width = getWidth(extent);\n\n  const tileSize = toSize(\n    opt_tileSize !== undefined ? opt_tileSize : DEFAULT_TILE_SIZE\n  );\n  const maxResolution =\n    opt_maxResolution > 0\n      ? opt_maxResolution\n      : Math.max(width / tileSize[0], height / tileSize[1]);\n\n  const length = maxZoom + 1;\n  const resolutions = new Array(length);\n  for (let z = 0; z < length; ++z) {\n    resolutions[z] = maxResolution / Math.pow(2, z);\n  }\n  return resolutions;\n}\n\n/**\n * @param {import(\"./proj.js\").ProjectionLike} projection Projection.\n * @param {number} [opt_maxZoom] Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size} [opt_tileSize] Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {import(\"./extent/Corner.js\").default} [opt_corner] Extent corner (default is `'top-left'`).\n * @return {!TileGrid} TileGrid instance.\n */\nexport function createForProjection(\n  projection,\n  opt_maxZoom,\n  opt_tileSize,\n  opt_corner\n) {\n  const extent = extentFromProjection(projection);\n  return createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner);\n}\n\n/**\n * Generate a tile grid extent from a projection.  If the projection has an\n * extent, it is used.  If not, a global extent is assumed.\n * @param {import(\"./proj.js\").ProjectionLike} projection Projection.\n * @return {import(\"./extent.js\").Extent} Extent.\n */\nexport function extentFromProjection(projection) {\n  projection = getProjection(projection);\n  let extent = projection.getExtent();\n  if (!extent) {\n    const half =\n      (180 * METERS_PER_UNIT[Units.DEGREES]) / projection.getMetersPerUnit();\n    extent = createOrUpdate(-half, -half, half, half);\n  }\n  return extent;\n}\n","/**\n * @module ol/source/Tile\n */\nimport Event from '../events/Event.js';\nimport Source from './Source.js';\nimport TileCache from '../TileCache.js';\nimport TileState from '../TileState.js';\nimport {abstract} from '../util.js';\nimport {assert} from '../asserts.js';\nimport {equivalent} from '../proj.js';\nimport {getKeyZXY, withinExtentAndZ} from '../tilecoord.js';\nimport {\n  getForProjection as getTileGridForProjection,\n  wrapX,\n} from '../tilegrid.js';\nimport {scale as scaleSize, toSize} from '../size.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] CacheSize.\n * @property {boolean} [opaque=false] Whether the layer is opaque.\n * @property {number} [tilePixelRatio] TilePixelRatio.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection.\n * @property {import(\"./State.js\").default} [state] State.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] TileGrid.\n * @property {boolean} [wrapX=true] WrapX.\n * @property {number} [transition] Transition.\n * @property {string} [key] Key.\n * @property {number} [zDirection=0] ZDirection.\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for sources providing images divided into a tile grid.\n * @abstract\n * @api\n */\nclass TileSource extends Source {\n  /**\n   * @param {Options} options SourceTile source options.\n   */\n  constructor(options) {\n    super({\n      attributions: options.attributions,\n      attributionsCollapsible: options.attributionsCollapsible,\n      projection: options.projection,\n      state: options.state,\n      wrapX: options.wrapX,\n    });\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.opaque_ = options.opaque !== undefined ? options.opaque : false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.tilePixelRatio_ =\n      options.tilePixelRatio !== undefined ? options.tilePixelRatio : 1;\n\n    /**\n     * @protected\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.tileGrid = options.tileGrid !== undefined ? options.tileGrid : null;\n\n    const tileSize = [256, 256];\n    const tileGrid = options.tileGrid;\n    if (tileGrid) {\n      toSize(tileGrid.getTileSize(tileGrid.getMinZoom()), tileSize);\n    }\n\n    /**\n     * @protected\n     * @type {import(\"../TileCache.js\").default}\n     */\n    this.tileCache = new TileCache(options.cacheSize || 0);\n\n    /**\n     * @protected\n     * @type {import(\"../size.js\").Size}\n     */\n    this.tmpSize = [0, 0];\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.key_ = options.key || '';\n\n    /**\n     * @protected\n     * @type {import(\"../Tile.js\").Options}\n     */\n    this.tileOptions = {transition: options.transition};\n\n    /**\n     * zDirection hint, read by the renderer. Indicates which resolution should be used\n     * by a renderer if the views resolution does not match any resolution of the tile source.\n     * If 0, the nearest resolution will be used. If 1, the nearest lower resolution\n     * will be used. If -1, the nearest higher resolution will be used.\n     * @type {number}\n     */\n    this.zDirection = options.zDirection ? options.zDirection : 0;\n  }\n\n  /**\n   * @return {boolean} Can expire cache.\n   */\n  canExpireCache() {\n    return this.tileCache.canExpireCache();\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @param {!Object<string, boolean>} usedTiles Used tiles.\n   */\n  expireCache(projection, usedTiles) {\n    const tileCache = this.getTileCacheForProjection(projection);\n    if (tileCache) {\n      tileCache.expireCache(usedTiles);\n    }\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @param {number} z Zoom level.\n   * @param {import(\"../TileRange.js\").default} tileRange Tile range.\n   * @param {function(import(\"../Tile.js\").default):(boolean|void)} callback Called with each\n   *     loaded tile.  If the callback returns `false`, the tile will not be\n   *     considered loaded.\n   * @return {boolean} The tile range is fully covered with loaded tiles.\n   */\n  forEachLoadedTile(projection, z, tileRange, callback) {\n    const tileCache = this.getTileCacheForProjection(projection);\n    if (!tileCache) {\n      return false;\n    }\n\n    let covered = true;\n    let tile, tileCoordKey, loaded;\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        tileCoordKey = getKeyZXY(z, x, y);\n        loaded = false;\n        if (tileCache.containsKey(tileCoordKey)) {\n          tile = /** @type {!import(\"../Tile.js\").default} */ (tileCache.get(\n            tileCoordKey\n          ));\n          loaded = tile.getState() === TileState.LOADED;\n          if (loaded) {\n            loaded = callback(tile) !== false;\n          }\n        }\n        if (!loaded) {\n          covered = false;\n        }\n      }\n    }\n    return covered;\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {number} Gutter.\n   */\n  getGutterForProjection(projection) {\n    return 0;\n  }\n\n  /**\n   * Return the key to be used for all tiles in the source.\n   * @return {string} The key for all tiles.\n   * @protected\n   */\n  getKey() {\n    return this.key_;\n  }\n\n  /**\n   * Set the value to be used as the key for all tiles in the source.\n   * @param {string} key The key for tiles.\n   * @protected\n   */\n  setKey(key) {\n    if (this.key_ !== key) {\n      this.key_ = key;\n      this.changed();\n    }\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {boolean} Opaque.\n   */\n  getOpaque(projection) {\n    return this.opaque_;\n  }\n\n  /**\n   * @return {Array<number>} Resolutions.\n   */\n  getResolutions() {\n    return this.tileGrid.getResolutions();\n  }\n\n  /**\n   * @abstract\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../Tile.js\").default} Tile.\n   */\n  getTile(z, x, y, pixelRatio, projection) {\n    return abstract();\n  }\n\n  /**\n   * Return the tile grid of the tile source.\n   * @return {import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n   * @api\n   */\n  getTileGrid() {\n    return this.tileGrid;\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n   */\n  getTileGridForProjection(projection) {\n    if (!this.tileGrid) {\n      return getTileGridForProjection(projection);\n    } else {\n      return this.tileGrid;\n    }\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../TileCache.js\").default} Tile cache.\n   * @protected\n   */\n  getTileCacheForProjection(projection) {\n    assert(\n      equivalent(this.getProjection(), projection),\n      68 // A VectorTile source can only be rendered if it has a projection compatible with the view projection.\n    );\n    return this.tileCache;\n  }\n\n  /**\n   * Get the tile pixel ratio for this source. Subclasses may override this\n   * method, which is meant to return a supported pixel ratio that matches the\n   * provided `pixelRatio` as close as possible.\n   * @param {number} pixelRatio Pixel ratio.\n   * @return {number} Tile pixel ratio.\n   */\n  getTilePixelRatio(pixelRatio) {\n    return this.tilePixelRatio_;\n  }\n\n  /**\n   * @param {number} z Z.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../size.js\").Size} Tile size.\n   */\n  getTilePixelSize(z, pixelRatio, projection) {\n    const tileGrid = this.getTileGridForProjection(projection);\n    const tilePixelRatio = this.getTilePixelRatio(pixelRatio);\n    const tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);\n    if (tilePixelRatio == 1) {\n      return tileSize;\n    } else {\n      return scaleSize(tileSize, tilePixelRatio, this.tmpSize);\n    }\n  }\n\n  /**\n   * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate\n   * is outside the resolution and extent range of the tile grid, `null` will be\n   * returned.\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"../proj/Projection.js\").default} [opt_projection] Projection.\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate to be passed to the tileUrlFunction or\n   *     null if no tile URL should be created for the passed `tileCoord`.\n   */\n  getTileCoordForTileUrlFunction(tileCoord, opt_projection) {\n    const projection =\n      opt_projection !== undefined ? opt_projection : this.getProjection();\n    const tileGrid = this.getTileGridForProjection(projection);\n    if (this.getWrapX() && projection.isGlobal()) {\n      tileCoord = wrapX(tileGrid, tileCoord, projection);\n    }\n    return withinExtentAndZ(tileCoord, tileGrid) ? tileCoord : null;\n  }\n\n  /**\n   * Remove all cached tiles from the source. The next render cycle will fetch new tiles.\n   * @api\n   */\n  clear() {\n    this.tileCache.clear();\n  }\n\n  refresh() {\n    this.clear();\n    super.refresh();\n  }\n\n  /**\n   * Increases the cache size if needed\n   * @param {number} tileCount Minimum number of tiles needed.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   */\n  updateCacheSize(tileCount, projection) {\n    const tileCache = this.getTileCacheForProjection(projection);\n    if (tileCount > tileCache.highWaterMark) {\n      tileCache.highWaterMark = tileCount;\n    }\n  }\n\n  /**\n   * Marks a tile coord as being used, without triggering a load.\n   * @abstract\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   */\n  useTile(z, x, y, projection) {}\n}\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/source/Tile~TileSource} instances are instances of this\n * type.\n */\nexport class TileSourceEvent extends Event {\n  /**\n   * @param {string} type Type.\n   * @param {import(\"../Tile.js\").default} tile The tile.\n   */\n  constructor(type, tile) {\n    super(type);\n\n    /**\n     * The tile related to the event.\n     * @type {import(\"../Tile.js\").default}\n     * @api\n     */\n    this.tile = tile;\n  }\n}\n\nexport default TileSource;\n","/**\n * @module ol/tileurlfunction\n */\nimport {assert} from './asserts.js';\nimport {modulo} from './math.js';\nimport {hash as tileCoordHash} from './tilecoord.js';\n\n/**\n * @param {string} template Template.\n * @param {import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n * @return {import(\"./Tile.js\").UrlFunction} Tile URL function.\n */\nexport function createFromTemplate(template, tileGrid) {\n  const zRegEx = /\\{z\\}/g;\n  const xRegEx = /\\{x\\}/g;\n  const yRegEx = /\\{y\\}/g;\n  const dashYRegEx = /\\{-y\\}/g;\n  return (\n    /**\n     * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile Coordinate.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"./proj/Projection.js\").default} projection Projection.\n     * @return {string|undefined} Tile URL.\n     */\n    function (tileCoord, pixelRatio, projection) {\n      if (!tileCoord) {\n        return undefined;\n      } else {\n        return template\n          .replace(zRegEx, tileCoord[0].toString())\n          .replace(xRegEx, tileCoord[1].toString())\n          .replace(yRegEx, tileCoord[2].toString())\n          .replace(dashYRegEx, function () {\n            const z = tileCoord[0];\n            const range = tileGrid.getFullTileRange(z);\n            assert(range, 55); // The {-y} placeholder requires a tile grid with extent\n            const y = range.getHeight() - tileCoord[2] - 1;\n            return y.toString();\n          });\n      }\n    }\n  );\n}\n\n/**\n * @param {Array<string>} templates Templates.\n * @param {import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n * @return {import(\"./Tile.js\").UrlFunction} Tile URL function.\n */\nexport function createFromTemplates(templates, tileGrid) {\n  const len = templates.length;\n  const tileUrlFunctions = new Array(len);\n  for (let i = 0; i < len; ++i) {\n    tileUrlFunctions[i] = createFromTemplate(templates[i], tileGrid);\n  }\n  return createFromTileUrlFunctions(tileUrlFunctions);\n}\n\n/**\n * @param {Array<import(\"./Tile.js\").UrlFunction>} tileUrlFunctions Tile URL Functions.\n * @return {import(\"./Tile.js\").UrlFunction} Tile URL function.\n */\nexport function createFromTileUrlFunctions(tileUrlFunctions) {\n  if (tileUrlFunctions.length === 1) {\n    return tileUrlFunctions[0];\n  }\n  return (\n    /**\n     * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile Coordinate.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"./proj/Projection.js\").default} projection Projection.\n     * @return {string|undefined} Tile URL.\n     */\n    function (tileCoord, pixelRatio, projection) {\n      if (!tileCoord) {\n        return undefined;\n      } else {\n        const h = tileCoordHash(tileCoord);\n        const index = modulo(h, tileUrlFunctions.length);\n        return tileUrlFunctions[index](tileCoord, pixelRatio, projection);\n      }\n    }\n  );\n}\n\n/**\n * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @param {number} pixelRatio Pixel ratio.\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {string|undefined} Tile URL.\n */\nexport function nullTileUrlFunction(tileCoord, pixelRatio, projection) {\n  return undefined;\n}\n\n/**\n * @param {string} url URL.\n * @return {Array<string>} Array of urls.\n */\nexport function expandUrl(url) {\n  const urls = [];\n  let match = /\\{([a-z])-([a-z])\\}/.exec(url);\n  if (match) {\n    // char range\n    const startCharCode = match[1].charCodeAt(0);\n    const stopCharCode = match[2].charCodeAt(0);\n    let charCode;\n    for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {\n      urls.push(url.replace(match[0], String.fromCharCode(charCode)));\n    }\n    return urls;\n  }\n  match = /\\{(\\d+)-(\\d+)\\}/.exec(url);\n  if (match) {\n    // number range\n    const stop = parseInt(match[2], 10);\n    for (let i = parseInt(match[1], 10); i <= stop; i++) {\n      urls.push(url.replace(match[0], i.toString()));\n    }\n    return urls;\n  }\n  urls.push(url);\n  return urls;\n}\n","/**\n * @module ol/source/UrlTile\n */\nimport TileEventType from './TileEventType.js';\nimport TileSource, {TileSourceEvent} from './Tile.js';\nimport TileState from '../TileState.js';\nimport {createFromTemplates, expandUrl} from '../tileurlfunction.js';\nimport {getKeyZXY} from '../tilecoord.js';\nimport {getUid} from '../util.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] Cache size.\n * @property {boolean} [opaque=false] Whether the layer is opaque.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection.\n * @property {import(\"./State.js\").default} [state] State.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] TileGrid.\n * @property {import(\"../Tile.js\").LoadFunction} tileLoadFunction TileLoadFunction.\n * @property {number} [tilePixelRatio] TilePixelRatio.\n * @property {import(\"../Tile.js\").UrlFunction} [tileUrlFunction] TileUrlFunction.\n * @property {string} [url] Url.\n * @property {Array<string>} [urls] Urls.\n * @property {boolean} [wrapX=true] WrapX.\n * @property {number} [transition] Transition.\n * @property {string} [key] Key.\n * @property {number} [zDirection=0] ZDirection.\n */\n\n/**\n * @classdesc\n * Base class for sources providing tiles divided into a tile grid over http.\n *\n * @fires import(\"./Tile.js\").TileSourceEvent\n */\nclass UrlTile extends TileSource {\n  /**\n   * @param {Options} options Image tile options.\n   */\n  constructor(options) {\n    super({\n      attributions: options.attributions,\n      cacheSize: options.cacheSize,\n      opaque: options.opaque,\n      projection: options.projection,\n      state: options.state,\n      tileGrid: options.tileGrid,\n      tilePixelRatio: options.tilePixelRatio,\n      wrapX: options.wrapX,\n      transition: options.transition,\n      key: options.key,\n      attributionsCollapsible: options.attributionsCollapsible,\n      zDirection: options.zDirection,\n    });\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.generateTileUrlFunction_ =\n      this.tileUrlFunction === UrlTile.prototype.tileUrlFunction;\n\n    /**\n     * @protected\n     * @type {import(\"../Tile.js\").LoadFunction}\n     */\n    this.tileLoadFunction = options.tileLoadFunction;\n\n    if (options.tileUrlFunction) {\n      this.tileUrlFunction = options.tileUrlFunction;\n    }\n\n    /**\n     * @protected\n     * @type {!Array<string>|null}\n     */\n    this.urls = null;\n\n    if (options.urls) {\n      this.setUrls(options.urls);\n    } else if (options.url) {\n      this.setUrl(options.url);\n    }\n\n    /**\n     * @private\n     * @type {!Object<string, boolean>}\n     */\n    this.tileLoadingKeys_ = {};\n  }\n\n  /**\n   * Return the tile load function of the source.\n   * @return {import(\"../Tile.js\").LoadFunction} TileLoadFunction\n   * @api\n   */\n  getTileLoadFunction() {\n    return this.tileLoadFunction;\n  }\n\n  /**\n   * Return the tile URL function of the source.\n   * @return {import(\"../Tile.js\").UrlFunction} TileUrlFunction\n   * @api\n   */\n  getTileUrlFunction() {\n    return Object.getPrototypeOf(this).tileUrlFunction === this.tileUrlFunction\n      ? this.tileUrlFunction.bind(this)\n      : this.tileUrlFunction;\n  }\n\n  /**\n   * Return the URLs used for this source.\n   * When a tileUrlFunction is used instead of url or urls,\n   * null will be returned.\n   * @return {!Array<string>|null} URLs.\n   * @api\n   */\n  getUrls() {\n    return this.urls;\n  }\n\n  /**\n   * Handle tile change events.\n   * @param {import(\"../events/Event.js\").default} event Event.\n   * @protected\n   */\n  handleTileChange(event) {\n    const tile = /** @type {import(\"../Tile.js\").default} */ (event.target);\n    const uid = getUid(tile);\n    const tileState = tile.getState();\n    let type;\n    if (tileState == TileState.LOADING) {\n      this.tileLoadingKeys_[uid] = true;\n      type = TileEventType.TILELOADSTART;\n    } else if (uid in this.tileLoadingKeys_) {\n      delete this.tileLoadingKeys_[uid];\n      type =\n        tileState == TileState.ERROR\n          ? TileEventType.TILELOADERROR\n          : tileState == TileState.LOADED\n          ? TileEventType.TILELOADEND\n          : undefined;\n    }\n    if (type != undefined) {\n      this.dispatchEvent(new TileSourceEvent(type, tile));\n    }\n  }\n\n  /**\n   * Set the tile load function of the source.\n   * @param {import(\"../Tile.js\").LoadFunction} tileLoadFunction Tile load function.\n   * @api\n   */\n  setTileLoadFunction(tileLoadFunction) {\n    this.tileCache.clear();\n    this.tileLoadFunction = tileLoadFunction;\n    this.changed();\n  }\n\n  /**\n   * Set the tile URL function of the source.\n   * @param {import(\"../Tile.js\").UrlFunction} tileUrlFunction Tile URL function.\n   * @param {string} [key] Optional new tile key for the source.\n   * @api\n   */\n  setTileUrlFunction(tileUrlFunction, key) {\n    this.tileUrlFunction = tileUrlFunction;\n    this.tileCache.pruneExceptNewestZ();\n    if (typeof key !== 'undefined') {\n      this.setKey(key);\n    } else {\n      this.changed();\n    }\n  }\n\n  /**\n   * Set the URL to use for requests.\n   * @param {string} url URL.\n   * @api\n   */\n  setUrl(url) {\n    const urls = expandUrl(url);\n    this.urls = urls;\n    this.setUrls(urls);\n  }\n\n  /**\n   * Set the URLs to use for requests.\n   * @param {Array<string>} urls URLs.\n   * @api\n   */\n  setUrls(urls) {\n    this.urls = urls;\n    const key = urls.join('\\n');\n    if (this.generateTileUrlFunction_) {\n      this.setTileUrlFunction(createFromTemplates(urls, this.tileGrid), key);\n    } else {\n      this.setKey(key);\n    }\n  }\n\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {string|undefined} Tile URL.\n   */\n  tileUrlFunction(tileCoord, pixelRatio, projection) {\n    return undefined;\n  }\n\n  /**\n   * Marks a tile coord as being used, without triggering a load.\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   */\n  useTile(z, x, y) {\n    const tileCoordKey = getKeyZXY(z, x, y);\n    if (this.tileCache.containsKey(tileCoordKey)) {\n      this.tileCache.get(tileCoordKey);\n    }\n  }\n}\n\nexport default UrlTile;\n","/**\n * @module ol/source/TileImage\n */\nimport EventType from '../events/EventType.js';\nimport ImageTile from '../ImageTile.js';\nimport ReprojTile from '../reproj/Tile.js';\nimport TileCache from '../TileCache.js';\nimport TileState from '../TileState.js';\nimport UrlTile from './UrlTile.js';\nimport {ENABLE_RASTER_REPROJECTION} from '../reproj/common.js';\nimport {IMAGE_SMOOTHING_DISABLED} from './common.js';\nimport {equivalent, get as getProjection} from '../proj.js';\nimport {getKey, getKeyZXY} from '../tilecoord.js';\nimport {getForProjection as getTileGridForProjection} from '../tilegrid.js';\nimport {getUid} from '../util.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {boolean} [imageSmoothing=true] Enable image smoothing.\n * @property {boolean} [opaque=false] Whether the layer is opaque.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection. Default is the view projection.\n * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).\n * Higher values can increase reprojection performance, but decrease precision.\n * @property {import(\"./State.js\").default} [state] Source state.\n * @property {typeof import(\"../ImageTile.js\").default} [tileClass] Class used to instantiate image tiles.\n * Default is {@link module:ol/ImageTile~ImageTile}.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is\n * ```js\n * function(imageTile, src) {\n *   imageTile.getImage().src = src;\n * };\n * ```\n * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service. For example, if the tile\n * service advertizes 256px by 256px tiles but actually sends 512px\n * by 512px images (for retina/hidpi devices) then `tilePixelRatio`\n * should be set to `2`.\n * @property {import(\"../Tile.js\").UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.\n * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.\n * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be\n * used instead of defining each one separately in the `urls` option.\n * @property {Array<string>} [urls] An array of URL templates.\n * @property {boolean} [wrapX] Whether to wrap the world horizontally. The default, is to\n * request out-of-bounds tiles from the server. When set to `false`, only one\n * world will be rendered. When set to `true`, tiles will be requested for one\n * world only, but they will be wrapped horizontally to render multiple worlds.\n * @property {number} [transition] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n * @property {string} [key] Optional tile key for proper cache fetching\n * @property {number} [zDirection=0] Indicate which resolution should be used\n * by a renderer if the view resolution does not match any resolution of the tile source.\n * If 0, the nearest resolution will be used. If 1, the nearest lower resolution\n * will be used. If -1, the nearest higher resolution will be used.\n */\n\n/**\n * @classdesc\n * Base class for sources providing images divided into a tile grid.\n *\n * @fires import(\"./Tile.js\").TileSourceEvent\n * @api\n */\nclass TileImage extends UrlTile {\n  /**\n   * @param {!Options} options Image tile options.\n   */\n  constructor(options) {\n    super({\n      attributions: options.attributions,\n      cacheSize: options.cacheSize,\n      opaque: options.opaque,\n      projection: options.projection,\n      state: options.state,\n      tileGrid: options.tileGrid,\n      tileLoadFunction: options.tileLoadFunction\n        ? options.tileLoadFunction\n        : defaultTileLoadFunction,\n      tilePixelRatio: options.tilePixelRatio,\n      tileUrlFunction: options.tileUrlFunction,\n      url: options.url,\n      urls: options.urls,\n      wrapX: options.wrapX,\n      transition: options.transition,\n      key: options.key,\n      attributionsCollapsible: options.attributionsCollapsible,\n      zDirection: options.zDirection,\n    });\n\n    /**\n     * @protected\n     * @type {?string}\n     */\n    this.crossOrigin =\n      options.crossOrigin !== undefined ? options.crossOrigin : null;\n\n    /**\n     * @protected\n     * @type {typeof ImageTile}\n     */\n    this.tileClass =\n      options.tileClass !== undefined ? options.tileClass : ImageTile;\n\n    /**\n     * @protected\n     * @type {!Object<string, TileCache>}\n     */\n    this.tileCacheForProjection = {};\n\n    /**\n     * @protected\n     * @type {!Object<string, import(\"../tilegrid/TileGrid.js\").default>}\n     */\n    this.tileGridForProjection = {};\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.reprojectionErrorThreshold_ = options.reprojectionErrorThreshold;\n\n    /**\n     * @private\n     * @type {object|undefined}\n     */\n    this.contextOptions_ =\n      options.imageSmoothing === false ? IMAGE_SMOOTHING_DISABLED : undefined;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.renderReprojectionEdges_ = false;\n  }\n\n  /**\n   * @return {boolean} Can expire cache.\n   */\n  canExpireCache() {\n    if (!ENABLE_RASTER_REPROJECTION) {\n      return super.canExpireCache();\n    }\n    if (this.tileCache.canExpireCache()) {\n      return true;\n    } else {\n      for (const key in this.tileCacheForProjection) {\n        if (this.tileCacheForProjection[key].canExpireCache()) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @param {!Object<string, boolean>} usedTiles Used tiles.\n   */\n  expireCache(projection, usedTiles) {\n    if (!ENABLE_RASTER_REPROJECTION) {\n      super.expireCache(projection, usedTiles);\n      return;\n    }\n    const usedTileCache = this.getTileCacheForProjection(projection);\n\n    this.tileCache.expireCache(\n      this.tileCache == usedTileCache ? usedTiles : {}\n    );\n    for (const id in this.tileCacheForProjection) {\n      const tileCache = this.tileCacheForProjection[id];\n      tileCache.expireCache(tileCache == usedTileCache ? usedTiles : {});\n    }\n  }\n\n  /**\n   * @return {Object|undefined} Context options.\n   */\n  getContextOptions() {\n    return this.contextOptions_;\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {number} Gutter.\n   */\n  getGutterForProjection(projection) {\n    if (\n      ENABLE_RASTER_REPROJECTION &&\n      this.getProjection() &&\n      projection &&\n      !equivalent(this.getProjection(), projection)\n    ) {\n      return 0;\n    } else {\n      return this.getGutter();\n    }\n  }\n\n  /**\n   * @return {number} Gutter.\n   */\n  getGutter() {\n    return 0;\n  }\n\n  /**\n   * Return the key to be used for all tiles in the source.\n   * @return {string} The key for all tiles.\n   * @protected\n   */\n  getKey() {\n    return (\n      super.getKey() +\n      (this.contextOptions_ ? '\\n' + JSON.stringify(this.contextOptions_) : '')\n    );\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {boolean} Opaque.\n   */\n  getOpaque(projection) {\n    if (\n      ENABLE_RASTER_REPROJECTION &&\n      this.getProjection() &&\n      projection &&\n      !equivalent(this.getProjection(), projection)\n    ) {\n      return false;\n    } else {\n      return super.getOpaque(projection);\n    }\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n   */\n  getTileGridForProjection(projection) {\n    if (!ENABLE_RASTER_REPROJECTION) {\n      return super.getTileGridForProjection(projection);\n    }\n    const thisProj = this.getProjection();\n    if (this.tileGrid && (!thisProj || equivalent(thisProj, projection))) {\n      return this.tileGrid;\n    } else {\n      const projKey = getUid(projection);\n      if (!(projKey in this.tileGridForProjection)) {\n        this.tileGridForProjection[projKey] = getTileGridForProjection(\n          projection\n        );\n      }\n      return this.tileGridForProjection[projKey];\n    }\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../TileCache.js\").default} Tile cache.\n   */\n  getTileCacheForProjection(projection) {\n    if (!ENABLE_RASTER_REPROJECTION) {\n      return super.getTileCacheForProjection(projection);\n    }\n    const thisProj = this.getProjection();\n    if (!thisProj || equivalent(thisProj, projection)) {\n      return this.tileCache;\n    } else {\n      const projKey = getUid(projection);\n      if (!(projKey in this.tileCacheForProjection)) {\n        this.tileCacheForProjection[projKey] = new TileCache(\n          this.tileCache.highWaterMark\n        );\n      }\n      return this.tileCacheForProjection[projKey];\n    }\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @param {string} key The key set on the tile.\n   * @return {!import(\"../Tile.js\").default} Tile.\n   * @private\n   */\n  createTile_(z, x, y, pixelRatio, projection, key) {\n    const tileCoord = [z, x, y];\n    const urlTileCoord = this.getTileCoordForTileUrlFunction(\n      tileCoord,\n      projection\n    );\n    const tileUrl = urlTileCoord\n      ? this.tileUrlFunction(urlTileCoord, pixelRatio, projection)\n      : undefined;\n    const tile = new this.tileClass(\n      tileCoord,\n      tileUrl !== undefined ? TileState.IDLE : TileState.EMPTY,\n      tileUrl !== undefined ? tileUrl : '',\n      this.crossOrigin,\n      this.tileLoadFunction,\n      this.tileOptions\n    );\n    tile.key = key;\n    tile.addEventListener(EventType.CHANGE, this.handleTileChange.bind(this));\n    return tile;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../Tile.js\").default} Tile.\n   */\n  getTile(z, x, y, pixelRatio, projection) {\n    const sourceProjection = this.getProjection();\n    if (\n      !ENABLE_RASTER_REPROJECTION ||\n      !sourceProjection ||\n      !projection ||\n      equivalent(sourceProjection, projection)\n    ) {\n      return this.getTileInternal(\n        z,\n        x,\n        y,\n        pixelRatio,\n        sourceProjection || projection\n      );\n    } else {\n      const cache = this.getTileCacheForProjection(projection);\n      const tileCoord = [z, x, y];\n      let tile;\n      const tileCoordKey = getKey(tileCoord);\n      if (cache.containsKey(tileCoordKey)) {\n        tile = cache.get(tileCoordKey);\n      }\n      const key = this.getKey();\n      if (tile && tile.key == key) {\n        return tile;\n      } else {\n        const sourceTileGrid = this.getTileGridForProjection(sourceProjection);\n        const targetTileGrid = this.getTileGridForProjection(projection);\n        const wrappedTileCoord = this.getTileCoordForTileUrlFunction(\n          tileCoord,\n          projection\n        );\n        const newTile = new ReprojTile(\n          sourceProjection,\n          sourceTileGrid,\n          projection,\n          targetTileGrid,\n          tileCoord,\n          wrappedTileCoord,\n          this.getTilePixelRatio(pixelRatio),\n          this.getGutter(),\n          function (z, x, y, pixelRatio) {\n            return this.getTileInternal(z, x, y, pixelRatio, sourceProjection);\n          }.bind(this),\n          this.reprojectionErrorThreshold_,\n          this.renderReprojectionEdges_,\n          this.contextOptions_\n        );\n        newTile.key = key;\n\n        if (tile) {\n          newTile.interimTile = tile;\n          newTile.refreshInterimChain();\n          cache.replace(tileCoordKey, newTile);\n        } else {\n          cache.set(tileCoordKey, newTile);\n        }\n        return newTile;\n      }\n    }\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {!import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../Tile.js\").default} Tile.\n   * @protected\n   */\n  getTileInternal(z, x, y, pixelRatio, projection) {\n    let tile = null;\n    const tileCoordKey = getKeyZXY(z, x, y);\n    const key = this.getKey();\n    if (!this.tileCache.containsKey(tileCoordKey)) {\n      tile = this.createTile_(z, x, y, pixelRatio, projection, key);\n      this.tileCache.set(tileCoordKey, tile);\n    } else {\n      tile = this.tileCache.get(tileCoordKey);\n      if (tile.key != key) {\n        // The source's params changed. If the tile has an interim tile and if we\n        // can use it then we use it. Otherwise we create a new tile.  In both\n        // cases we attempt to assign an interim tile to the new tile.\n        const interimTile = tile;\n        tile = this.createTile_(z, x, y, pixelRatio, projection, key);\n\n        //make the new tile the head of the list,\n        if (interimTile.getState() == TileState.IDLE) {\n          //the old tile hasn't begun loading yet, and is now outdated, so we can simply discard it\n          tile.interimTile = interimTile.interimTile;\n        } else {\n          tile.interimTile = interimTile;\n        }\n        tile.refreshInterimChain();\n        this.tileCache.replace(tileCoordKey, tile);\n      }\n    }\n    return tile;\n  }\n\n  /**\n   * Sets whether to render reprojection edges or not (usually for debugging).\n   * @param {boolean} render Render the edges.\n   * @api\n   */\n  setRenderReprojectionEdges(render) {\n    if (\n      !ENABLE_RASTER_REPROJECTION ||\n      this.renderReprojectionEdges_ == render\n    ) {\n      return;\n    }\n    this.renderReprojectionEdges_ = render;\n    for (const id in this.tileCacheForProjection) {\n      this.tileCacheForProjection[id].clear();\n    }\n    this.changed();\n  }\n\n  /**\n   * Sets the tile grid to use when reprojecting the tiles to the given\n   * projection instead of the default tile grid for the projection.\n   *\n   * This can be useful when the default tile grid cannot be created\n   * (e.g. projection has no extent defined) or\n   * for optimization reasons (custom tile size, resolutions, ...).\n   *\n   * @param {import(\"../proj.js\").ProjectionLike} projection Projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} tilegrid Tile grid to use for the projection.\n   * @api\n   */\n  setTileGridForProjection(projection, tilegrid) {\n    if (ENABLE_RASTER_REPROJECTION) {\n      const proj = getProjection(projection);\n      if (proj) {\n        const projKey = getUid(proj);\n        if (!(projKey in this.tileGridForProjection)) {\n          this.tileGridForProjection[projKey] = tilegrid;\n        }\n      }\n    }\n  }\n}\n\n/**\n * @param {ImageTile} imageTile Image tile.\n * @param {string} src Source.\n */\nfunction defaultTileLoadFunction(imageTile, src) {\n  /** @type {HTMLImageElement|HTMLVideoElement} */ (imageTile.getImage()).src = src;\n}\n\nexport default TileImage;\n","/**\n * @module ol/source/XYZ\n */\n\nimport TileImage from './TileImage.js';\nimport {createXYZ, extentFromProjection} from '../tilegrid.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {boolean} [imageSmoothing=true] Enable image smoothing.\n * @property {boolean} [opaque=false] Whether the layer is opaque.\n * @property {import(\"../proj.js\").ProjectionLike} [projection='EPSG:3857'] Projection.\n * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).\n * Higher values can increase reprojection performance, but decrease precision.\n * @property {number} [maxZoom=42] Optional max zoom level. Not used if `tileGrid` is provided.\n * @property {number} [minZoom=0] Optional min zoom level. Not used if `tileGrid` is provided.\n * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is\n * ```js\n * function(imageTile, src) {\n *   imageTile.getImage().src = src;\n * };\n * ```\n * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service.\n * For example, if the tile service advertizes 256px by 256px tiles but actually sends 512px\n * by 512px images (for retina/hidpi devices) then `tilePixelRatio`\n * should be set to `2`.\n * @property {number|import(\"../size.js\").Size} [tileSize=[256, 256]] The tile size used by the tile service.\n * Not used if `tileGrid` is provided.\n * @property {import(\"../Tile.js\").UrlFunction} [tileUrlFunction] Optional function to get\n * tile URL given a tile coordinate and the projection.\n * Required if `url` or `urls` are not provided.\n * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`,\n * and `{z}` placeholders. A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`,\n * may be used instead of defining each one separately in the `urls` option.\n * @property {Array<string>} [urls] An array of URL templates.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n * @property {number} [transition=250] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n * @property {number} [zDirection=0] Indicate which resolution should be used\n * by a renderer if the view resolution does not match any resolution of the tile source.\n * If 0, the nearest resolution will be used. If 1, the nearest lower resolution\n * will be used. If -1, the nearest higher resolution will be used.\n */\n\n/**\n * @classdesc\n * Layer source for tile data with URLs in a set XYZ format that are\n * defined in a URL template. By default, this follows the widely-used\n * Google grid where `x` 0 and `y` 0 are in the top left. Grids like\n * TMS where `x` 0 and `y` 0 are in the bottom left can be used by\n * using the `{-y}` placeholder in the URL template, so long as the\n * source does not have a custom tile grid. In this case\n * a `tileUrlFunction` can be used, such as:\n * ```js\n *  tileUrlFunction: function(coordinate) {\n *    return 'http://mapserver.com/' + coordinate[0] + '/' +\n *      coordinate[1] + '/' + (-coordinate[2] - 1) + '.png';\n *  }\n * ```\n * @api\n */\nclass XYZ extends TileImage {\n  /**\n   * @param {Options} [opt_options] XYZ options.\n   */\n  constructor(opt_options) {\n    const options = opt_options || {};\n    const projection =\n      options.projection !== undefined ? options.projection : 'EPSG:3857';\n\n    const tileGrid =\n      options.tileGrid !== undefined\n        ? options.tileGrid\n        : createXYZ({\n            extent: extentFromProjection(projection),\n            maxResolution: options.maxResolution,\n            maxZoom: options.maxZoom,\n            minZoom: options.minZoom,\n            tileSize: options.tileSize,\n          });\n\n    super({\n      attributions: options.attributions,\n      cacheSize: options.cacheSize,\n      crossOrigin: options.crossOrigin,\n      imageSmoothing: options.imageSmoothing,\n      opaque: options.opaque,\n      projection: projection,\n      reprojectionErrorThreshold: options.reprojectionErrorThreshold,\n      tileGrid: tileGrid,\n      tileLoadFunction: options.tileLoadFunction,\n      tilePixelRatio: options.tilePixelRatio,\n      tileUrlFunction: options.tileUrlFunction,\n      url: options.url,\n      urls: options.urls,\n      wrapX: options.wrapX !== undefined ? options.wrapX : true,\n      transition: options.transition,\n      attributionsCollapsible: options.attributionsCollapsible,\n      zDirection: options.zDirection,\n    });\n  }\n}\n\nexport default XYZ;\n","/**\n * @module ol/source/OSM\n */\n\nimport XYZ from './XYZ.js';\n\n/**\n * The attribution containing a link to the OpenStreetMap Copyright and License\n * page.\n * @const\n * @type {string}\n * @api\n */\nexport const ATTRIBUTION =\n  '&#169; ' +\n  '<a href=\"https://www.openstreetmap.org/copyright\" target=\"_blank\">OpenStreetMap</a> ' +\n  'contributors.';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.\n * @property {null|string} [crossOrigin='anonymous'] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {boolean} [imageSmoothing=true] Enable image smoothing.\n * @property {number} [maxZoom=19] Max zoom.\n * @property {boolean} [opaque=true] Whether the layer is opaque.\n * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).\n * Higher values can increase reprojection performance, but decrease precision.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is\n * ```js\n * function(imageTile, src) {\n *   imageTile.getImage().src = src;\n * };\n * ```\n * @property {number} [transition=250] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n * @property {string} [url='https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png'] URL template.\n * Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n */\n\n/**\n * @classdesc\n * Layer source for the OpenStreetMap tile server.\n * @api\n */\nclass OSM extends XYZ {\n  /**\n   * @param {Options} [opt_options] Open Street Map options.\n   */\n  constructor(opt_options) {\n    const options = opt_options || {};\n\n    let attributions;\n    if (options.attributions !== undefined) {\n      attributions = options.attributions;\n    } else {\n      attributions = [ATTRIBUTION];\n    }\n\n    const crossOrigin =\n      options.crossOrigin !== undefined ? options.crossOrigin : 'anonymous';\n\n    const url =\n      options.url !== undefined\n        ? options.url\n        : 'https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png';\n\n    super({\n      attributions: attributions,\n      attributionsCollapsible: false,\n      cacheSize: options.cacheSize,\n      crossOrigin: crossOrigin,\n      imageSmoothing: options.imageSmoothing,\n      maxZoom: options.maxZoom !== undefined ? options.maxZoom : 19,\n      opaque: options.opaque !== undefined ? options.opaque : true,\n      reprojectionErrorThreshold: options.reprojectionErrorThreshold,\n      tileLoadFunction: options.tileLoadFunction,\n      transition: options.transition,\n      url: url,\n      wrapX: options.wrapX,\n    });\n  }\n}\n\nexport default OSM;\n","\"use strict\";\n\n/* globals document:readonly */\nvar bundleURL = null;\n\nfunction getBundleURLCached() {\n  if (!bundleURL) {\n    bundleURL = getBundleURL();\n  }\n\n  return bundleURL;\n}\n\nfunction getBundleURL() {\n  try {\n    throw new Error();\n  } catch (err) {\n    var matches = ('' + err.stack).match(/(https?|file|ftp):\\/\\/[^)\\n]+/g);\n\n    if (matches) {\n      return getBaseURL(matches[0]);\n    }\n  }\n\n  return '/';\n}\n\nfunction getBaseURL(url) {\n  return ('' + url).replace(/^((?:https?|file|ftp):\\/\\/.+)\\/[^/]+$/, '$1') + '/';\n} // TODO: Replace uses with `new URL(url).origin` when ie11 is no longer supported.\n\n\nfunction getOrigin(url) {\n  let matches = ('' + url).match(/(https?|file|ftp):\\/\\/[^/]+/);\n\n  if (!matches) {\n    throw new Error('Origin not found');\n  }\n\n  return matches[0];\n}\n\nexports.getBundleURL = getBundleURLCached;\nexports.getBaseURL = getBaseURL;\nexports.getOrigin = getOrigin;","\"use strict\";\n\nvar resolve = require('./bundle-manifest').resolve;\n\nmodule.exports = function (fromId, toId) {\n  return relative(dirname(resolve(fromId)), resolve(toId));\n};\n\nfunction dirname(_filePath) {\n  if (_filePath === '') {\n    return '.';\n  }\n\n  var filePath = _filePath[_filePath.length - 1] === '/' ? _filePath.slice(0, _filePath.length - 1) : _filePath;\n  var slashIndex = filePath.lastIndexOf('/');\n  return slashIndex === -1 ? '.' : filePath.slice(0, slashIndex);\n}\n\nfunction relative(from, to) {\n  if (from === to) {\n    return '';\n  }\n\n  var fromParts = from.split('/');\n\n  if (fromParts[0] === '.') {\n    fromParts.shift();\n  }\n\n  var toParts = to.split('/');\n\n  if (toParts[0] === '.') {\n    toParts.shift();\n  } // Find where path segments diverge.\n\n\n  var i;\n  var divergeIndex;\n\n  for (i = 0; (i < toParts.length || i < fromParts.length) && divergeIndex == null; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      divergeIndex = i;\n    }\n  } // If there are segments from \"from\" beyond the point of divergence,\n  // return back up the path to that point using \"..\".\n\n\n  var parts = [];\n\n  for (i = 0; i < fromParts.length - divergeIndex; i++) {\n    parts.push('..');\n  } // If there are segments from \"to\" beyond the point of divergence,\n  // continue using the remaining segments.\n\n\n  if (toParts.length > divergeIndex) {\n    parts.push.apply(parts, toParts.slice(divergeIndex));\n  }\n\n  return parts.join('/');\n}\n\nmodule.exports._dirname = dirname;\nmodule.exports._relative = relative;","module.exports = require('./bundle-url').getBundleURL() + require('./relative-path')(\"6dNpu\", \"54TNJ\")","import 'ol/ol.css';\nimport { Map, View } from 'ol';\nimport { Zoom } from 'ol/control';\nimport GPX from 'ol/format/GPX';\nimport { GeometryCollection, Point } from 'ol/geom';\nimport TileLayer from 'ol/layer/Tile';\nimport VectorLayer from 'ol/layer/Vector';\nimport { fromLonLat } from 'ol/proj';\nimport OSM from 'ol/source/OSM';\nimport VectorSource from 'ol/source/Vector';\nimport { Circle, Fill, Stroke, Style } from 'ol/style';\nimport backhendl from 'url:./data/backhendl.gpx';\nimport { getVectorContext } from 'ol/render';\n\nvar raster = new TileLayer({\n  source: new OSM()\n});\n\nvar style = new Style({\n  image: new Circle({\n    fill: new Fill({\n      color: 'rgb(255,240,0)'\n    }),\n    stroke: new Stroke({\n      color: 'rgb(255,170,0)',\n      width: 1.5\n    }),\n    radius: 11\n  }),\n  stroke: new Stroke({\n    color: 'rgb(50,200,50)',\n    width: 2\n  })\n});\n\nvar source = new VectorSource({\n  url: backhendl,\n  format: new GPX()\n});\n\nvar maxRotation = Math.PI / 200;\n\nvar past = [];\nvar vector = new VectorLayer({\n  source: source,\n  style: function(feature, resolution) {\n    var deltaTime;\n    if (playing) {\n      deltaTime = 30 * ((Date.now() / 1000) - originM);\n    } else if (stopM) {\n      deltaTime = 30 * (stopM - originM);\n    } else {\n      deltaTime = 0;\n    }\n    var line = feature.getGeometry().getLineString(0);\n    var time = stats.minTime + deltaTime;\n    if (time > stats.maxTime) {\n      time = stats.maxTime;\n      reset();\n    }\n    var coord = line.getCoordinateAtM(time, true);\n    var next = line.getCoordinateAtM(time + 30, true);\n    var nextRotation = Math.atan2(next[1] - coord[1], next[0] - coord[0]) - Math.PI / 2\n    var rotation = view.getRotation();\n    var deltaRotation = nextRotation - rotation;\n    if (deltaRotation > maxRotation) {\n      view.setRotation(rotation + maxRotation);\n    } else if (deltaRotation < -maxRotation) {\n      view.setRotation(rotation - maxRotation);\n    } else {\n      view.setRotation(nextRotation);\n    }\n    view.setCenter(coord);\n\n    var point = new Point(coord, 'XYZM');\n    past.unshift(point);\n    style.setGeometry(new GeometryCollection([line, point]));\n    return [style];\n  }\n});\n\nvar view = new View({\n  center: fromLonLat([15.4409210, 47.1530110]),\n  zoom: 10,\n  constrainRotation: false\n});\n\nvar map = new Map({\n  target: document.getElementById('map'),\n  layers: [raster, vector],\n  controls: [new Zoom()],\n  view: view\n});\n\nvar timeRange = null;\n\nvar stats = {\n  minTime: Infinity,\n  maxTime: -Infinity,\n  minZ: Infinity,\n  maxZ: -Infinity,\n  lengths: [],\n  coordinates: []\n};\n\nfunction distance(from, to) {\n  var dx = to[0] - from[0];\n  var dy = to[1] - from[1];\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nsource.on('addfeature', function(event) {\n  var line = event.feature.getGeometry().getLineString(0);\n  var coords = line.getCoordinates();\n  var first = coords[0];\n  var num = coords.length;\n  var last = coords[num - 1];\n  stats.minTime = first[3];\n  stats.maxTime = last[3];\n  for (var i = 0; i < num; ++i) {\n    var z = coords[i][2];\n    if (z < stats.minZ) {\n      stats.minZ = z;\n    }\n    if (z > stats.maxZ) {\n      stats.maxZ = z;\n    }\n    if (i === 0) {\n      stats.lengths.push(0);\n    } else {\n      stats.lengths.push(\n          distance(coords[i - 1], coords[i]) + stats.lengths[i - 1]);\n    }\n  }\n  stats.coordinates = coords;\n  view.animate({\n    center: first,\n    zoom: 17\n  });\n});\n\nvar playing = false;\nvar originM;\nfunction start() {\n  originM = Date.now() / 1000;\n  playing = true;\n  stopM = null;\n  source.changed();\n}\n\nvar stopM;\nfunction stop() {\n  stopM = Date.now() / 1000;\n  playing = false;\n}\n\nfunction resume() {\n  originM += (Date.now() / 1000) - stopM;\n  playing = true;\n  source.changed();\n}\n\nfunction reset() {\n  stop();\n  stopM = null;\n}\n\nmap.on('singleclick', function() {\n  if (playing) {\n    stop();\n  } else if (stopM) {\n    resume();\n  } else {\n    start();\n  }\n})\n\nvar maxHistory = 30;\n\nvector.on('postrender', function(event) {\n  if (playing) {\n    var vectorContext = getVectorContext(event);\n    var len = Math.min(maxHistory, past.length);\n    for (var i = 0; i < len; i += 6) {\n      vectorContext.setImageStyle(new Circle({\n        fill: new Fill({\n          color: 'rgba(255,240,0, ' + (1 - i / len) + ')'\n        }),\n        radius: 9\n      }));\n      vectorContext.drawPoint(past[i]);\n    }\n    past.length = len;\n    plot(event.context);\n    setTimeout(function() {\n      source.changed();\n    }, 100);\n  } else {\n    past.length = 0;\n  }\n});\n\nfunction plot(context) {\n  var canvas = context.canvas;\n  var width = canvas.width;\n  var bottom = canvas.height;\n  var height = bottom / 5;\n\n  var rangeZ = stats.maxZ - stats.minZ;\n  var rangeX = stats.lengths[stats.lengths.length - 1];\n\n  // full plot\n  context.beginPath();\n  context.moveTo(0, bottom);\n  for (var i = 0, ii = stats.coordinates.length; i < ii; i += 2) {\n    var coord = stats.coordinates[i];\n    var deltaZ = coord[2] - stats.minZ;\n    var x = width * stats.lengths[i] / rangeX;\n    var y = bottom - height * deltaZ / rangeZ;\n    context.lineTo(x, y);\n  }\n  context.lineTo(width, bottom);\n  context.closePath();\n  context.fillStyle = 'rgba(0,0,0,0.6)';\n  context.fill();\n\n  // current progress\n  if (past.length < 1) {\n    return;\n  }\n  var now = past[0].getCoordinates()[3];\n  context.beginPath();\n  context.moveTo(0, bottom);\n  for (var i = 0, ii = stats.coordinates.length; i < ii; i += 2) {\n    var coord = stats.coordinates[i];\n    if (coord[3] > now) {\n      break;\n    }\n    var deltaZ = coord[2] - stats.minZ;\n    var x = width * stats.lengths[i] / rangeX;\n    var y = bottom - height * deltaZ / rangeZ;\n    context.lineTo(x, y);\n  }\n  context.lineTo(x, bottom);\n  context.closePath();\n  context.fillStyle = 'rgba(50,170,50,0.5)';\n  context.fill();\n}\n","/**\n * @module ol/render\n */\nimport CanvasImmediateRenderer from './render/canvas/Immediate.js';\nimport {DEVICE_PIXEL_RATIO} from './has.js';\nimport {\n  apply as applyTransform,\n  create as createTransform,\n  multiply as multiplyTransform,\n  scale as scaleTransform,\n} from './transform.js';\nimport {getSquaredTolerance} from './renderer/vector.js';\nimport {getTransformFromProjections, getUserProjection} from './proj.js';\n\n/**\n * @typedef {Object} State\n * @property {CanvasRenderingContext2D} context Canvas context that the layer is being rendered to.\n * @property {import(\"./Feature.js\").FeatureLike} feature Feature.\n * @property {import(\"./geom/SimpleGeometry.js\").default} geometry Geometry.\n * @property {number} pixelRatio Pixel ratio used by the layer renderer.\n * @property {number} resolution Resolution that the render batch was created and optimized for.\n * This is not the view's resolution that is being rendered.\n * @property {number} rotation Rotation of the rendered layer in radians.\n */\n\n/**\n * A function to be used when sorting features before rendering.\n * It takes two instances of {@link module:ol/Feature} or\n * {@link module:ol/render/Feature} and returns a `{number}`.\n *\n * @typedef {function(import(\"./Feature.js\").FeatureLike, import(\"./Feature.js\").FeatureLike):number} OrderFunction\n */\n\n/**\n * @typedef {Object} ToContextOptions\n * @property {import(\"./size.js\").Size} [size] Desired size of the canvas in css\n * pixels. When provided, both canvas and css size will be set according to the\n * `pixelRatio`. If not provided, the current canvas and css sizes will not be\n * altered.\n * @property {number} [pixelRatio=window.devicePixelRatio] Pixel ratio (canvas\n * pixel to css pixel ratio) for the canvas.\n */\n\n/**\n * Binds a Canvas Immediate API to a canvas context, to allow drawing geometries\n * to the context's canvas.\n *\n * The units for geometry coordinates are css pixels relative to the top left\n * corner of the canvas element.\n * ```js\n * import {toContext} from 'ol/render';\n * import Fill from 'ol/style/Fill';\n * import Polygon from 'ol/geom/Polygon';\n *\n * var canvas = document.createElement('canvas');\n * var render = toContext(canvas.getContext('2d'),\n *     { size: [100, 100] });\n * render.setFillStrokeStyle(new Fill({ color: blue }));\n * render.drawPolygon(\n *     new Polygon([[[0, 0], [100, 100], [100, 0], [0, 0]]]));\n * ```\n *\n * @param {CanvasRenderingContext2D} context Canvas context.\n * @param {ToContextOptions} [opt_options] Options.\n * @return {CanvasImmediateRenderer} Canvas Immediate.\n * @api\n */\nexport function toContext(context, opt_options) {\n  const canvas = context.canvas;\n  const options = opt_options ? opt_options : {};\n  const pixelRatio = options.pixelRatio || DEVICE_PIXEL_RATIO;\n  const size = options.size;\n  if (size) {\n    canvas.width = size[0] * pixelRatio;\n    canvas.height = size[1] * pixelRatio;\n    canvas.style.width = size[0] + 'px';\n    canvas.style.height = size[1] + 'px';\n  }\n  const extent = [0, 0, canvas.width, canvas.height];\n  const transform = scaleTransform(createTransform(), pixelRatio, pixelRatio);\n  return new CanvasImmediateRenderer(context, pixelRatio, extent, transform, 0);\n}\n\n/**\n * Gets a vector context for drawing to the event's canvas.\n * @param {import(\"./render/Event.js\").default} event Render event.\n * @return {CanvasImmediateRenderer} Vector context.\n * @api\n */\nexport function getVectorContext(event) {\n  const frameState = event.frameState;\n  const transform = multiplyTransform(\n    event.inversePixelTransform.slice(),\n    frameState.coordinateToPixelTransform\n  );\n  const squaredTolerance = getSquaredTolerance(\n    frameState.viewState.resolution,\n    frameState.pixelRatio\n  );\n  let userTransform;\n  const userProjection = getUserProjection();\n  if (userProjection) {\n    userTransform = getTransformFromProjections(\n      userProjection,\n      frameState.viewState.projection\n    );\n  }\n  return new CanvasImmediateRenderer(\n    event.context,\n    frameState.pixelRatio,\n    frameState.extent,\n    transform,\n    frameState.viewState.rotation,\n    squaredTolerance,\n    userTransform\n  );\n}\n\n/**\n * Gets the pixel of the event's canvas context from the map viewport's CSS pixel.\n * @param {import(\"./render/Event.js\").default} event Render event.\n * @param {import(\"./pixel.js\").Pixel} pixel CSS pixel relative to the top-left\n * corner of the map viewport.\n * @return {import(\"./pixel.js\").Pixel} Pixel on the event's canvas context.\n * @api\n */\nexport function getRenderPixel(event, pixel) {\n  const result = pixel.slice(0);\n  applyTransform(event.inversePixelTransform.slice(), result);\n  return result;\n}\n"],"names":["$7d806a7a603c235ec027b73d847f4d95$var$mapping","$7d806a7a603c235ec027b73d847f4d95$export$357eb1b4f03c1402","pairs","keys","Object","i","length","$7d806a7a603c235ec027b73d847f4d95$export$40339995e8a21591","id","resolved","Error","parcelRequire","register","JSON","parse","$b33e8a0ea0c493ce5741084af120ccb7$var$NAMESPACE_URIS","$b33e8a0ea0c493ce5741084af120ccb7$var$FEATURE_READER","$b33e8a0ea0c493ce5741084af120ccb7$var$readRte","$b33e8a0ea0c493ce5741084af120ccb7$var$readTrk","$b33e8a0ea0c493ce5741084af120ccb7$var$readWpt","$b33e8a0ea0c493ce5741084af120ccb7$var$GPX_PARSERS","$6u7wO","makeStructureNS","makeArrayPusher","$b33e8a0ea0c493ce5741084af120ccb7$var$LINK_PARSERS","makeObjectPropertySetter","$4pjCM","readString","$b33e8a0ea0c493ce5741084af120ccb7$var$GPX_SERIALIZERS","makeChildAppender","node","feature","objectStack","options","properties","getProperties","context","geometry","getGeometry","getType","$1gVIf","default","LINE_STRING","lineString","$2rUWQ","transformGeometryWithOptions","getLayout","getCoordinates","parentNode","orderedKeys","$b33e8a0ea0c493ce5741084af120ccb7$var$RTE_SEQUENCE","namespaceURI","values","makeSequence","pushSerializeAndPop","$b33e8a0ea0c493ce5741084af120ccb7$var$RTE_SERIALIZERS","OBJECT_PROPERTY_NODE_FACTORY","MULTI_LINE_STRING","multiLineString","getLineStrings","$b33e8a0ea0c493ce5741084af120ccb7$var$TRK_SEQUENCE","$b33e8a0ea0c493ce5741084af120ccb7$var$TRK_SERIALIZERS","POINT","point","$b33e8a0ea0c493ce5741084af120ccb7$var$writeWptType","$b33e8a0ea0c493ce5741084af120ccb7$var$GPX","_super","GPX","opt_options","_this","call","this","dataProjection","$2vjin","get","readExtensions_","readExtensions","$b33e8a0ea0c493ce5741084af120ccb7$var$__extends","prototype","handleReadExtensions_","features","ii","extensionsNode","set","undefined","readFeatureFromNode","$3MevS","includes","featureReader","localName","getReadOptions","readFeaturesFromNode","pushParseAndPop","writeFeaturesNode","adaptOptions","gpx","createElementNS","setAttributeNS","XML_SCHEMA_INSTANCE_URI","setAttribute","$b33e8a0ea0c493ce5741084af120ccb7$var$GPX_NODE_FACTORY","$6MnPI","$b33e8a0ea0c493ce5741084af120ccb7$var$RTE_PARSERS","$b33e8a0ea0c493ce5741084af120ccb7$var$parseLink","readNonNegativeInteger","$b33e8a0ea0c493ce5741084af120ccb7$var$parseExtensions","$b33e8a0ea0c493ce5741084af120ccb7$var$RTEPT_PARSERS","rteValues","flatCoordinates","layoutOptions","$b33e8a0ea0c493ce5741084af120ccb7$var$appendCoordinate","readDecimal","readDateTime","$b33e8a0ea0c493ce5741084af120ccb7$var$TRK_PARSERS","parseNode","$b33e8a0ea0c493ce5741084af120ccb7$var$TRKSEG_PARSERS","push","$b33e8a0ea0c493ce5741084af120ccb7$var$TRKPT_PARSERS","trkValues","$b33e8a0ea0c493ce5741084af120ccb7$var$WPT_PARSERS","$b33e8a0ea0c493ce5741084af120ccb7$var$LINK_SEQUENCE","$b33e8a0ea0c493ce5741084af120ccb7$var$LINK_SERIALIZERS","writeStringTextNode","$b33e8a0ea0c493ce5741084af120ccb7$var$writeLink","writeNonNegativeIntegerTextNode","makeArraySerializer","$b33e8a0ea0c493ce5741084af120ccb7$var$RTEPT_TYPE_SEQUENCE","$b33e8a0ea0c493ce5741084af120ccb7$var$TRKSEG_SERIALIZERS","$b33e8a0ea0c493ce5741084af120ccb7$var$TRKSEG_NODE_FACTORY","makeSimpleNodeFactory","$b33e8a0ea0c493ce5741084af120ccb7$var$WPT_TYPE_SEQUENCE","$b33e8a0ea0c493ce5741084af120ccb7$var$WPT_TYPE_SERIALIZERS","writeDecimalTextNode","writeDateTimeTextNode","$b33e8a0ea0c493ce5741084af120ccb7$var$GEOMETRY_TYPE_TO_NODENAME","value","opt_nodeName","nodeName","parseFloat","getAttribute","hasZ","hasM","$b33e8a0ea0c493ce5741084af120ccb7$var$applyLayoutOptions","ends","layout","$3dG11","XY","stride","XYZM","XYZ","XYM","href","$7oM0w","$7JkHi","setProperties","$4LOxL","coordinates","$5g6wp","link","coordinate","String","$b33e8a0ea0c493ce5741084af120ccb7$export$9099ad97b570f7c","$013ee184ddda363412ada1e10e95871e$export$9099ad97b570f7c","$ab70eb0a0a56b112261264db1ea7acab$export$9099ad97b570f7c","BaseTileLayer","baseOptions","$6RQ94","assign","preload","useInterimTilesOnError","setPreload","setUseInterimTilesOnError","$ab70eb0a0a56b112261264db1ea7acab$var$__extends","getPreload","getUseInterimTilesOnError","$Lzmdv","$6a958d3d10a45fbc13d601def6cb4731$var$TileRange","TileRange","minX","maxX","minY","maxY","contains","tileCoord","containsXY","containsTileRange","tileRange","x","y","equals","extend","getHeight","getSize","getWidth","intersects","$6a958d3d10a45fbc13d601def6cb4731$export$ea8082d0226d35a5","$6a958d3d10a45fbc13d601def6cb4731$export$9099ad97b570f7c","$21101e8f6691f861098a74ca233ba3e1$var$CanvasTileLayerRenderer","CanvasTileLayerRenderer","tileLayer","extentChanged","renderedExtent_","renderedPixelRatio","renderedProjection","renderedRevision","renderedTiles","newTiles_","tmpExtent","$4lmw7","createEmpty","tmpTileRange_","$21101e8f6691f861098a74ca233ba3e1$var$__extends","isDrawableTile","tile","getLayer","tileState","getState","$dgki0","LOADED","EMPTY","ERROR","getTile","z","frameState","pixelRatio","projection","viewState","getSource","setState","getInterimTile","loadedTileCallback","tiles","zoom","prepareFrame","renderFrame","target","layerState","layerStatesArray","layerIndex","viewResolution","resolution","viewCenter","center","rotation","tileSource","sourceRevision","getRevision","tileGrid","getTileGridForProjection","getZForResolution","zDirection","tileResolution","getResolution","extent","layerExtent","fromUserExtent","getIntersection","tilePixelRatio","getTilePixelRatio","width","Math","round","size","height","sqrt","dx","dy","canvasExtent","getTileRangeForExtentAndZ","tilesToDrawByZ","findLoadedTiles","createLoadedTileFinder","tmpTileRange","uid","$6fegY","getUid","toString","inTransition","indexOf","getAlpha","time","childTileRange","getTileCoordChildTileRange","covered","forEachTileCoordParentTileRange","canvasScale","$5ljS4","compose","pixelTransform","canvasTransform","useContainer","opacity","canvas","makeInverse","inversePixelTransform","tempTransform","containerReused","clearRect","clipUnrotated","getContextOptions","preRender","clips","clipZs","currentClip","zs","map","Number","sort","numberSafeCompareFunction","getOpaque","reverse","currentZ","currentTilePixelSize","getTilePixelSize","currentScale","dx_1","dy_1","originTileCoord","getTileCoordForCoordAndZ","getTopLeft","originTileExtent","getTileCoordExtent","origin_1","apply","tileGutter","getGutterForProjection","tilesToDraw","tileCoordKey","floatX","nextX","floatY","nextY","w","h","transition","save","i_1","clip","beginPath","moveTo","lineTo","drawTileImage","restore","unshift","updateUsedTiles","usedTiles","renderedResolution","manageTilePyramid","scheduleExpireCache","postRender","style","transform","container","gutter","image","getTileImage","tileAlpha","alpha","alphaChanged","globalAlpha","drawImage","animate","endTransition","getImage","canExpireCache","postRenderFunction","tileSource1","frameState1","tileSourceKey","expireCache","bind","postRenderFunctions","getKey","opt_tileCallback","wantedTiles","tileQueue","tileCount","getMinZoom","IDLE","isKeyQueued","enqueue","getTileCoordCenter","useTile","updateCacheSize","$5eOHj","$21101e8f6691f861098a74ca233ba3e1$export$9099ad97b570f7c","$7f639b92eb9591e7aded56644548f656$export$9099ad97b570f7c","TileLayer","$7f639b92eb9591e7aded56644548f656$var$__extends","createRenderer","$21101e8f6691f861098a74ca233ba3e1$exports","$ab70eb0a0a56b112261264db1ea7acab$exports","$6ea2e09c0ee686e4fcf344e90f929221$export$9099ad97b570f7c","Tile","state","interimTile","hifi","key","transition_","transitionStarts_","$6ea2e09c0ee686e4fcf344e90f929221$var$__extends","changed","dispatchEvent","$65ADj","CHANGE","release","refreshInterimChain","prev","LOADING","getTileCoord","load","abstract","start","delta","$46UD2","easeIn","$4GA14","$69031f3b45b1bb2d223c45e6bbe47b36$export$9099ad97b570f7c","ImageTile","src","crossOrigin","tileLoadFunction","crossOrigin_","src_","image_","Image","unlisten_","tileLoadFunction_","$69031f3b45b1bb2d223c45e6bbe47b36$var$__extends","handleImageError_","ctx","unlistenImage_","$4eVqD","createCanvasContext2D","fillStyle","fillRect","handleImageLoad_","naturalWidth","naturalHeight","$1s8C5","listenImage","$6ea2e09c0ee686e4fcf344e90f929221$exports","$7e4c33869bbc09ad771e58efcd7791e2$var$brokenDiagonalRendering_","$3a0ea260bd0161734cb5e603b9086c9d$export$9099ad97b570f7c","Triangulation","sourceProj","targetProj","targetExtent","maxSourceExtent","errorThreshold","opt_destinationResolution","sourceProj_","targetProj_","transformInvCache","transformInv","getTransform","transformInv_","c","maxSourceExtent_","errorThresholdSquared_","triangles_","wrapsXInSource_","canWrapXInSource_","canWrapX","getExtent","sourceWorldWidth_","targetWorldWidth_","destinationTopLeft","destinationTopRight","getTopRight","destinationBottomRight","getBottomRight","destinationBottomLeft","getBottomLeft","sourceTopLeft","sourceTopRight","sourceBottomRight","sourceBottomLeft","maxSubdivision","max","ceil","$4qq0p","log2","getArea","addQuad_","leftBound_1","Infinity","forEach","triangle","arr","min","source","newTriangle","addTriangle_","a","b","aSrc","bSrc","cSrc","d","dSrc","sourceQuadExtent","boundingExtent","sourceCoverageX","sourceWorldWidth","wrapsX","needsSubdivision","isGlobal","targetQuadExtent","isFinite","isNotFinite","centerSrc","modulo","abs","bc","bcSrc","da","daSrc","ab","abSrc","cd","cdSrc","calculateSourceExtent","extendCoordinate","getTriangles","$dffde8f1acde674bc74a24601c2788a7$export$5f986e3acaff8610","imageSmoothingEnabled","msImageSmoothingEnabled","$7e4c33869bbc09ad771e58efcd7791e2$var$drawTestTriangle","u1","v1","u2","v2","closePath","$7e4c33869bbc09ad771e58efcd7791e2$var$verifyBrokenDiagonalRendering","data","offset","$7e4c33869bbc09ad771e58efcd7791e2$export$fbbff54b3c32db8d","targetCenter","targetResolution","sourceCenter","sourceResolution","getPointResolution","targetMetersPerUnit","getMetersPerUnit","sourceMetersPerUnit","sourceExtent","containsCoordinate","compensationFactor","$7e4c33869bbc09ad771e58efcd7791e2$export$792a797b69be0d58","triangulation","sources","opt_renderEdges","opt_contextOptions","pixelRound","scale","globalCompositeOperation","sourceDataExtent","canvasWidthInUnits","canvasHeightInUnits","stitchContext","stitchScale","xPos","yPos","srcWidth","srcHeight","targetTopLeft","x0","y0","x1","y1","x2","y2","u0","v0","sourceNumericalShiftX","sourceNumericalShiftY","augmentedMatrix","affineCoefs","solveLinearSystem","document","createElement","getContext","getImageData","$7e4c33869bbc09ad771e58efcd7791e2$var$isBrokenDiagonalRendering","ud","vd","step","steps","translate","strokeStyle","lineWidth","stroke","$97e37be8733b1927a1ed959b854a8d18$export$9099ad97b570f7c","ReprojTile","sourceTileGrid","targetTileGrid","wrappedTileCoord","getTileFunction","opt_errorThreshold","renderEdges_","contextOptions_","pixelRatio_","gutter_","canvas_","sourceTileGrid_","targetTileGrid_","wrappedTileCoord_","sourceTiles_","sourcesListenerKeys_","sourceZ_","maxTargetExtent","limitedTargetExtent","sourceProjExtent","getCenter","forEachCorner","corner","$7e4c33869bbc09ad771e58efcd7791e2$export$ed73ddd0371d87e2","errorThresholdInPixels","triangulation_","clamp","sourceRange","srcX","srcY","$97e37be8733b1927a1ed959b854a8d18$var$__extends","reproject_","getTileSize","leftToLoad_1","sourceListenKey_1","$3H2uZ","listen","e","state1","unlistenByKey","unlistenSources_","setTimeout","$101ae72fedfe330e8897d118e958a8b6$export$9099ad97b570f7c","LRUCache","opt_highWaterMark","highWaterMark","count_","entries_","oldest_","newest_","getCount","clear","containsKey","hasOwnProperty","f","entry","value_","key_","newer","$1mHUI","assert","older","remove","getKeys","Array","getValues","peekLast","peekLastKey","peekFirstKey","pop","replace","setSize","$c98d704946f2a3a0e1335bd43bccb465$export$ea8082d0226d35a5","opt_tileCoord","$c98d704946f2a3a0e1335bd43bccb465$export$1039fb0288fd71e3","$c98d704946f2a3a0e1335bd43bccb465$export$a0f0ccbe5bbc0789","$8328c42c04c9adada69111ec662476d9$export$9099ad97b570f7c","TileCache","$8328c42c04c9adada69111ec662476d9$var$__extends","pruneExceptNewestZ","split","$c98d704946f2a3a0e1335bd43bccb465$export$5208a752d34424e5","$6fb7cf65abcfc8d879372ec2dca0d0b8$export$9099ad97b570f7c","$0f9feaa19e1db86e91525f400c1bbfa1$var$tmpTileCoord","$0f9feaa19e1db86e91525f400c1bbfa1$export$9099ad97b570f7c","TileGrid","zoomFactor","minZoom","resolutions_","resolutions","isSorted","origins","zoomFactor_","maxZoom","origin_","origin","origins_","tileSizes_","tileSizes","tileSize_","tileSize","$5TQMR","DEFAULT_TILE_SIZE","extent_","fullTileRanges_","tmpSize_","tmpExtent_","sizes","restrictedTileRange","calculateTileRanges_","forEachTileCoord","callback","j","jj","opt_tileRange","opt_extent","tileCoordExtent","floor","getMaxZoom","getOrigin","getResolutions","getTileRangeForTileCoordAndZ","tileCoordZ","tileCoordX","tileCoordY","factor","pow","getTileRangeExtent","$43BI1","toSize","createOrUpdate","getTileCoordForXYAndZ_","getTileCoordForCoordAndResolution","getTileCoordForXYAndResolution_","reverseIntersectionPolicy","adjustX","adjustY","xFromOrigin","yFromOrigin","getTileCoordResolution","getFullTileRange","opt_direction","linearFindNearest","fullTileRanges","$0b7f50deff6bfc90c8b239d5ceca7010$export$115502f69f929231","getDefaultTileGrid","opt_maxZoom","opt_tileSize","opt_corner","$4nuo6","TOP_LEFT","$0b7f50deff6bfc90c8b239d5ceca7010$var$resolutionsFromExtent","getCorner","$0b7f50deff6bfc90c8b239d5ceca7010$export$57c49ef1657592d4","$0b7f50deff6bfc90c8b239d5ceca7010$export$9666e825b22d806d","$0b7f50deff6bfc90c8b239d5ceca7010$export$6dfef52f91d4f582","setDefaultTileGrid","opt_maxResolution","DEFAULT_MAX_ZOOM","maxResolution","half","METERS_PER_UNIT","$6MSva","DEGREES","$cde35ab3df9629f8ffd26ea2f187b41e$var$TileSource","TileSource","attributions","attributionsCollapsible","wrapX","opaque_","opaque","tilePixelRatio_","tileCache","$8328c42c04c9adada69111ec662476d9$exports","cacheSize","tmpSize","tileOptions","$cde35ab3df9629f8ffd26ea2f187b41e$var$__extends","getTileCacheForProjection","forEachLoadedTile","loaded","setKey","getTileGrid","equivalent","getProjection","getTileCoordForTileUrlFunction","opt_projection","getWrapX","projectionExtent","worldWidth","worldsAway","$0b7f50deff6bfc90c8b239d5ceca7010$export$5a0d9577a24f3c5b","$c98d704946f2a3a0e1335bd43bccb465$export$b46b80619528d4e5","refresh","$3f7LD","$cde35ab3df9629f8ffd26ea2f187b41e$export$8434c8db61edbf9d","TileSourceEvent","type","$0qSof","$cde35ab3df9629f8ffd26ea2f187b41e$export$9099ad97b570f7c","$f3b33fdefe65058178a4b532c7b3f14b$export$ee162149bf998c0f","template","zRegEx","xRegEx","yRegEx","dashYRegEx","range","$f3b33fdefe65058178a4b532c7b3f14b$export$2d2faeb2e9d58b93","templates","len","tileUrlFunctions","$c98d704946f2a3a0e1335bd43bccb465$export$4639c7f2947f4458","index","$f3b33fdefe65058178a4b532c7b3f14b$export$c6a04e0c49b28953","$671acdd0ca89710db49a7e8e41335e8e$export$9099ad97b570f7c","UrlTile","generateTileUrlFunction_","tileUrlFunction","urls","setUrls","url","setUrl","tileLoadingKeys_","$671acdd0ca89710db49a7e8e41335e8e$var$__extends","getTileLoadFunction","getTileUrlFunction","getPrototypeOf","getUrls","handleTileChange","event","$cde35ab3df9629f8ffd26ea2f187b41e$exports","setTileLoadFunction","setTileUrlFunction","match","exec","startCharCode","charCodeAt","stopCharCode","charCode","fromCharCode","stop_1","parseInt","$f3b33fdefe65058178a4b532c7b3f14b$export$47abe479fba0e55d","join","$f1c529d0542d6a8d6fa77a64fa516101$var$defaultTileLoadFunction","imageTile","$f1c529d0542d6a8d6fa77a64fa516101$export$9099ad97b570f7c","TileImage","tileClass","$69031f3b45b1bb2d223c45e6bbe47b36$exports","tileCacheForProjection","tileGridForProjection","reprojectionErrorThreshold_","reprojectionErrorThreshold","imageSmoothing","renderReprojectionEdges_","$f1c529d0542d6a8d6fa77a64fa516101$var$__extends","usedTileCache","getGutter","stringify","thisProj","projKey","createTile_","urlTileCoord","tileUrl","addEventListener","sourceProjection","cache","newTile","$97e37be8733b1927a1ed959b854a8d18$exports","z1","pixelRatio1","getTileInternal","setRenderReprojectionEdges","render","setTileGridForProjection","tilegrid","proj","$671acdd0ca89710db49a7e8e41335e8e$exports","$fd3ab3577c0c67d5f04f77f7494fe563$export$9099ad97b570f7c","xyzOptions","gridOptions","$0b7f50deff6bfc90c8b239d5ceca7010$export$5731532c605ee56","$fd3ab3577c0c67d5f04f77f7494fe563$var$__extends","$f1c529d0542d6a8d6fa77a64fa516101$exports","$ff8235042efbfb69f46b35131190fa2b$export$bd9c1867755cf54e","$ff8235042efbfb69f46b35131190fa2b$export$9099ad97b570f7c","OSM","$ff8235042efbfb69f46b35131190fa2b$var$__extends","$fd3ab3577c0c67d5f04f77f7494fe563$exports","$634f916bc30b7d6650877f3f4b6a8b3a$var$bundleURL","$634f916bc30b7d6650877f3f4b6a8b3a$var$getBaseURL","$634f916bc30b7d6650877f3f4b6a8b3a$export$da289beea9c5b10d","err","matches","stack","$634f916bc30b7d6650877f3f4b6a8b3a$var$getBundleURL","resolve","$824bc590bf0a3702ac7bd27152cb0639$var$dirname","_filePath","filePath","slice","slashIndex","lastIndexOf","$824bc590bf0a3702ac7bd27152cb0639$var$relative","from","to","fromParts","shift","divergeIndex","toParts","parts","module","exports","fromId","toId","$824bc590bf0a3702ac7bd27152cb0639$require$resolve","_dirname","_relative","$d3d5a0af21676091111686ce080c045c$exports","getBundleURL","$660ddfae62ab927110b85f404e392196$var$raster","$7f639b92eb9591e7aded56644548f656$exports","$ff8235042efbfb69f46b35131190fa2b$exports","$660ddfae62ab927110b85f404e392196$var$style","$1z20P","Style","Circle","fill","Fill","color","Stroke","radius","$660ddfae62ab927110b85f404e392196$var$source","$3CnQS","$parcel$interopDefault","format","$b33e8a0ea0c493ce5741084af120ccb7$exports","$660ddfae62ab927110b85f404e392196$var$maxRotation","PI","$660ddfae62ab927110b85f404e392196$var$past","$660ddfae62ab927110b85f404e392196$var$vector","$1rnY9","deltaTime","$660ddfae62ab927110b85f404e392196$var$playing","Date","now","$660ddfae62ab927110b85f404e392196$var$originM","$660ddfae62ab927110b85f404e392196$var$stopM","line","getLineString","$660ddfae62ab927110b85f404e392196$var$stats","minTime","maxTime","$660ddfae62ab927110b85f404e392196$var$stop","coord","getCoordinateAtM","next","nextRotation","atan2","$660ddfae62ab927110b85f404e392196$var$view","getRotation","deltaRotation","setRotation","setCenter","setGeometry","$4eboh","$N1rY5","fromLonLat","constrainRotation","$660ddfae62ab927110b85f404e392196$var$map","$4BFFB","getElementById","layers","controls","$5ScHR","Zoom","view","minZ","maxZ","lengths","on","coords","first","num","last","vectorContext","userTransform","multiply","coordinateToPixelTransform","squaredTolerance","$25giy","getSquaredTolerance","userProjection","getUserProjection","getTransformFromProjections","$4R4Ev","$ef5a32aa029d77fee7a3a3bd54627b3c$export$ce92cfb882ff66f4","setImageStyle","drawPoint","bottom","rangeZ","rangeX","deltaZ","$660ddfae62ab927110b85f404e392196$var$plot"],"version":3,"file":"bike-track.0bbb8003.js.map"}