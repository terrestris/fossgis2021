{"mappings":"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","sources":["node_modules/@ngageoint/geopackage/lib/db/sqliteAdapter.ts","node_modules/os-browserify/browser.js","node_modules/@parcel/runtime-js/lib/runtime-ddaa2d9fdb8b81dbe9d2450e08c17c57.js"],"sourcesContent":["import { DBAdapter, DBValue } from './dbAdapter';\nimport fs from 'fs';\nimport path from 'path';\nimport http from 'http';\nimport os from 'os';\n/**\n * This adapter uses better-sqlite3 to execute queries against the GeoPackage database\n * @see {@link https://github.com/JoshuaWise/better-sqlite3|better-sqlite3}\n */\n\n/**\n * Class which adapts generic GeoPackage queries to better-sqlite3 queries\n */\nexport class SqliteAdapter implements DBAdapter {\n  filePath: string | Buffer | Uint8Array;\n  db: any;\n  /**\n   * Returns a Promise which, when resolved, returns a DBAdapter which has connected to the GeoPackage database file\n   */\n  async initialize(): Promise<this> {\n    // @ts-ignore\n    const bettersqlite = await import('better-sqlite3');\n    const Database = bettersqlite.default;\n    try {\n      if (this.filePath && typeof this.filePath === 'string') {\n        if (this.filePath.indexOf('http') === 0) {\n          const url: string = this.filePath as string;\n          return new Promise((resolve, reject) => {\n            http\n              .get(url, response => {\n                if (response.statusCode !== 200) {\n                  reject(new Error('Unable to reach url: ' + this.filePath));\n                }\n                const tmpPath = path.join(os.tmpdir(), Date.now() + Math.floor(Math.random() * 100) + '.gpkg');\n                const writeStream = fs.createWriteStream(tmpPath);\n                response.pipe(writeStream);\n                writeStream.on('close', () => {\n                  try {\n                    this.db = new Database(tmpPath);\n                    // verify that this is an actual database\n                    this.db.pragma('journal_mode = WAL');\n                    this.filePath = tmpPath;\n                    resolve(this);\n                  } catch (err) {\n                    console.log('error', err);\n                    reject(err);\n                  }\n                });\n              })\n              .on('error', e => {\n                reject(e);\n              });\n          });\n        } else {\n          this.db = new Database(this.filePath);\n          return this;\n        }\n      } else if (this.filePath) {\n        // write this byte array to a file then open it\n        const byteArray = this.filePath;\n        const tmpPath = path.join(os.tmpdir(), Date.now() + '.gpkg');\n        return new Promise((resolve, reject) => {\n          fs.writeFile(tmpPath, byteArray, () => {\n            this.db = new Database(tmpPath);\n            // verify that this is an actual database\n            try {\n              this.db.pragma('journal_mode = WAL');\n            } catch (err) {\n              console.log('error', err);\n              reject(err);\n            }\n            this.filePath = tmpPath;\n            resolve(this);\n          });\n        });\n      } else {\n        console.log('create in memory');\n        // creating a random name here.  If the same name is used twice the database is appended to\n        this.db = new Database('memory' + Math.random(), {\n          memory: !this.filePath,\n        });\n        return this;\n      }\n    } catch (err) {\n      console.log('Error opening database', err);\n      throw err;\n    }\n  }\n  // /**\n  //  * Creates an adapter from an already established better-sqlite3 database connection\n  //  * @param  {*} db better-sqlite3 database connection\n  //  * @return {module:db/sqliteAdapter~Adapter}\n  //  */\n  // static createAdapterFromDb(db) {\n  //   return new SqliteAdapter(db);\n  // };\n\n  constructor(filePath?: string | Buffer | Uint8Array) {\n    this.filePath = filePath;\n  }\n  /**\n   * Closes the connection to the GeoPackage\n   */\n  close(): void {\n    this.db.pragma('wal_autocheckpoint=0');\n    this.db.checkpoint();\n    this.db.close();\n  }\n  /**\n   * Get the connection to the database file\n   * @return {*}\n   */\n  getDBConnection(): any {\n    return this.db;\n  }\n  /**\n   * Returns a Buffer containing the contents of the database as a file\n   */\n  async export(): Promise<any> {\n    return new Promise(resolve => {\n      return fs.readFile(this.filePath as string, (err, data) => {\n        resolve(data);\n      });\n    });\n  }\n  /**\n   * Registers the given function so that it can be used by SQL statements\n   * @see {@link https://github.com/JoshuaWise/better-sqlite3/wiki/API#registeroptions-function---this|better-sqlite3 register}\n   * @param  {string} name               name of function to register\n   * @param  {Function} functionDefinition function to register\n   * @return {module:db/sqliteAdapter~Adapter} this\n   */\n  registerFunction(name: string, functionDefinition: Function): this {\n    this.db.function(name, functionDefinition);\n    return this;\n  }\n  /**\n   * Gets one row of results from the statement\n   * @see {@link https://github.com/JoshuaWise/better-sqlite3/wiki/API#getbindparameters---row|better-sqlite3 get}\n   * @param  {string} sql    statement to run\n   * @param  {Array|Object} [params] bind parameters\n   * @return {Object}\n   */\n  get(sql: string, params?: [] | Record<string, DBValue>): Record<string, DBValue> {\n    const statement = this.db.prepare(sql);\n    if (params) {\n      return statement.get(params);\n    } else {\n      return statement.get();\n    }\n  }\n  /**\n   * Determines if a tableName exists in the database\n   * @param {String} tableName\n   * @returns {Boolean}\n   */\n  isTableExists(tableName: string): boolean {\n    const statement = this.db.prepare(\"SELECT name FROM sqlite_master WHERE type='table' AND name=:name\");\n    const result = statement.get({ name: tableName });\n    return !!result;\n  }\n  /**\n   * Gets all results from the statement in an array\n   * @see {@link https://github.com/JoshuaWise/better-sqlite3/wiki/API#allbindparameters---array-of-rows|better-sqlite3 all}\n   * @param  {String} sql    statement to run\n   * @param  {Array|Object} [params] bind parameters\n   * @return {Object[]}\n   */\n  all(sql: string, params?: [] | Record<string, DBValue>): Record<string, DBValue>[] {\n    const statement = this.db.prepare(sql);\n    if (params) {\n      return statement.all(params);\n    } else {\n      return statement.all();\n    }\n  }\n  /**\n   * Returns an `Iterable` with results from the query\n   * @see {@link https://github.com/JoshuaWise/better-sqlite3/wiki/API#iteratebindparameters---iterator|better-sqlite3 iterate}\n   * @param  {String} sql    statement to run\n   * @param  {Object|Array} [params] bind parameters\n   * @return {Iterable.<Object>}\n   */\n  each(sql: string, params?: [] | Record<string, DBValue>): IterableIterator<Record<string, DBValue>> {\n    const statement = this.db.prepare(sql);\n    if (params) {\n      return statement.iterate(params);\n    } else {\n      return statement.iterate();\n    }\n  }\n  /**\n   * Run the given statement, returning information about what changed.\n   *\n   * @see {@link https://github.com/JoshuaWise/better-sqlite3/wiki/API#runbindparameters---object|better-sqlite3}\n   * @param  {String} sql    statement to run\n   * @param  {Object|Array} [params] bind parameters\n   * @return {{changes: number, lastInsertROWID: number}} object: `{ \"changes\": number, \"lastInsertROWID\": number }`\n   * * `changes`: number of rows the statement changed\n   * * `lastInsertROWID`: ID of the last inserted row\n   */\n  run(sql: string, params?: [] | Record<string, DBValue>): { changes: number; lastInsertRowid: number } {\n    const statement = this.db.prepare(sql);\n    if (params) {\n      return statement.run(params);\n    } else {\n      return statement.run();\n    }\n  }\n  /**\n   * Runs the specified insert statement and returns the last inserted id or undefined if no insert happened\n   * @param  {String} sql    statement to run\n   * @param  {Object|Array} [params] bind parameters\n   * @return {Number} last inserted row id\n   */\n  insert(sql: string, params?: [] | Record<string, DBValue>): number {\n    const statement = this.db.prepare(sql);\n    return statement.run(params).lastInsertRowid;\n  }\n  /**\n   * Runs the specified delete statement and returns the number of deleted rows\n   * @param  {String} sql    statement to run\n   * @param  {Object|Array} params bind parameters\n   * @return {Number} deleted rows\n   */\n  delete(sql: string, params?: [] | Record<string, DBValue>): number {\n    const statement = this.db.prepare(sql);\n    return statement.run(params).changes;\n  }\n  /**\n   * Drops the table\n   * @param  {String} table table name\n   * @return {Boolean} indicates if the table was dropped\n   */\n  dropTable(table: string): boolean {\n    try {\n      const statement = this.db.prepare('DROP TABLE IF EXISTS \"' + table + '\"');\n      const result = statement.run();\n      const vacuum = this.db.prepare('VACUUM');\n      vacuum.run();\n      return result.changes === 0;\n    } catch (e) {\n      console.log('Drop Table Error', e);\n      return false;\n    }\n  }\n  /**\n   * Counts rows that match the query\n   * @param  {string} tableName table name from which to count\n   * @param  {string} [where]     where clause\n   * @param  {Object|Array} [whereArgs] where args\n   * @return {Number} count\n   */\n  count(tableName: string, where?: string, whereArgs?: [] | Record<string, DBValue>): number {\n    let sql = 'SELECT COUNT(*) as count FROM \"' + tableName + '\"';\n    if (where) {\n      sql += ' where ' + where;\n    }\n    const statement = this.db.prepare(sql);\n    if (whereArgs) {\n      return statement.get(whereArgs).count;\n    } else {\n      return statement.get().count;\n    }\n  }\n}\n","exports.endianness = function () { return 'LE' };\n\nexports.hostname = function () {\n    if (typeof location !== 'undefined') {\n        return location.hostname\n    }\n    else return '';\n};\n\nexports.loadavg = function () { return [] };\n\nexports.uptime = function () { return 0 };\n\nexports.freemem = function () {\n    return Number.MAX_VALUE;\n};\n\nexports.totalmem = function () {\n    return Number.MAX_VALUE;\n};\n\nexports.cpus = function () { return [] };\n\nexports.type = function () { return 'Browser' };\n\nexports.release = function () {\n    if (typeof navigator !== 'undefined') {\n        return navigator.appVersion;\n    }\n    return '';\n};\n\nexports.networkInterfaces\n= exports.getNetworkInterfaces\n= function () { return {} };\n\nexports.arch = function () { return 'javascript' };\n\nexports.platform = function () { return 'browser' };\n\nexports.tmpdir = exports.tmpDir = function () {\n    return '/tmp';\n};\n\nexports.EOL = '\\n';\n\nexports.homedir = function () {\n\treturn '/'\n};\n","module.exports = (require(\"./loaders/browser/js-loader\")(require('./bundle-url').getBundleURL() + require('./relative-path')(\"5RlLk\", \"4zvP4\"))).then(() => module.bundle.root('2nurn'));"],"names":["fs_1","__importDefault","require","path_1","http_1","os_1","SqliteAdapter","SqliteAdapter1","filePath","prototype","initialize","Promise","resolve","then","__importStar","res","bettersqlite","_a","sent","Database","default","this","indexOf","url_1","reject","get","response","statusCode","Error","_this","tmpPath","join","tmpdir","Date","now","Math","floor","random","writeStream","createWriteStream","pipe","on","db","pragma","err","console","log","e","byteArray_1","tmpPath_1","writeFile","memory","close","checkpoint","getDBConnection","export","readFile","data","registerFunction","name","functionDefinition","function","sql","params","statement","prepare","isTableExists","tableName","all","each","iterate","run","insert","lastInsertRowid","delete","changes","dropTable","table","result","count","where","whereArgs","exports","endianness","hostname","location","loadavg","uptime","freemem","Number","MAX_VALUE","totalmem","cpus","type","release","navigator","appVersion","networkInterfaces","getNetworkInterfaces","arch","platform","tmpDir","EOL","homedir","module","getBundleURL","bundle","root"],"version":3,"file":"sqliteAdapter.092a150f.js.map"}