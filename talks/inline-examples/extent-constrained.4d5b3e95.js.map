{"mappings":"0yCAaaA,EAAW,2GA0ExBC,EAvCA,SAAAC,GAGK,SACHC,EAAYC,OAGNC,EAFEC,EAAUF,GAAW,GAIzBC,OAD2BE,IAAzBD,EAAQD,aACKC,EAAQD,aAEX,CAAIL,OAGZQ,OACoBD,IAAxBD,EAAQE,YAA4BF,EAAQE,YAAW,YAEnDC,OACYF,IAAhBD,EAAQG,IACJH,EAAQG,IAAG,8DAGjBP,EAAAQ,KAAAC,KAAA,CACEN,aAAcA,EACdO,yBAAyB,EACzBC,UAAWP,EAAQO,UACnBL,YAAaA,EACbM,eAAgBR,EAAQQ,eACxBC,aAA6BR,IAApBD,EAAQS,QAAwBT,EAAQS,QAAU,GAC3DC,YAA2BT,IAAnBD,EAAQU,QAAuBV,EAAQU,OAC/CC,2BAA4BX,EAAQW,2BACpCC,iBAAkBZ,EAAQY,iBAC1BC,WAAYb,EAAQa,WACpBV,IAAKA,EACLW,MAAOd,EAAQc,qBAlCHC,EAAAlB,EAAAD,GAqClBC,EArCA,CAAkBmB,EAAAC,wjBC+DlBC,EA1CA,SAAAtB,GAGK,SACHuB,EAAYrB,OACJE,EAAUF,GAAW,GACrBsB,OACmBnB,IAAvBD,EAAQoB,WAA2BpB,EAAQoB,WAAU,YAEjDC,OACiBpB,IAArBD,EAAQqB,SACJrB,EAAQqB,SACRC,EAAAC,UAAS,CACPC,OAAQF,EAAAG,qBAAqBL,GAC7BM,cAAe1B,EAAQ0B,cACvBjB,QAAST,EAAQS,QACjBkB,QAAS3B,EAAQ2B,QACjBC,SAAU5B,EAAQ4B,kBAG1BhC,EAAAQ,KAAAC,KAAA,CACEN,aAAcC,EAAQD,aACtBQ,UAAWP,EAAQO,UACnBL,YAAaF,EAAQE,YACrBM,eAAgBR,EAAQQ,eACxBE,OAAQV,EAAQU,OAChBU,WAAYA,EACZT,2BAA4BX,EAAQW,2BACpCU,SAAUA,EACVT,iBAAkBZ,EAAQY,iBAC1BiB,eAAgB7B,EAAQ6B,eACxBC,gBAAiB9B,EAAQ8B,gBACzB3B,IAAKH,EAAQG,IACb4B,KAAM/B,EAAQ+B,KACdjB,WAAyBb,IAAlBD,EAAQc,OAAsBd,EAAQc,MAC7CD,WAAYb,EAAQa,WACpBP,wBAAyBN,EAAQM,wBACjC0B,WAAYhC,EAAQgC,0BArCRC,EAAAd,EAAAvB,GAwClBuB,EAxCA,CAAkBe,EAAAjB,0rBCmZf,SACMkB,EAAwBC,EAAWC,GACQD,EAAUE,WAAYD,IAAMA,MAGhFE,EAzZA,SAAA3C,GAGK,SACH4C,EAAYxC,OAAZyC,EACE7C,EAAAQ,KAAAC,KAAA,CACEN,aAAcC,EAAQD,aACtBQ,UAAWP,EAAQO,UACnBG,OAAQV,EAAQU,OAChBU,WAAYpB,EAAQoB,WACpBsB,MAAO1C,EAAQ0C,MACfrB,SAAUrB,EAAQqB,SAClBT,iBAAkBZ,EAAQY,iBACtBZ,EAAQY,iBACRuB,EACJN,eAAgB7B,EAAQ6B,eACxBC,gBAAiB9B,EAAQ8B,gBACzB3B,IAAKH,EAAQG,IACb4B,KAAM/B,EAAQ+B,KACdjB,MAAOd,EAAQc,MACfD,WAAYb,EAAQa,WACpB8B,IAAK3C,EAAQ2C,IACbrC,wBAAyBN,EAAQM,wBACjC0B,WAAYhC,EAAQgC,0BAOtBS,EAAKvC,iBACqBD,IAAxBD,EAAQE,YAA4BF,EAAQE,YAAc,KAM5DuC,EAAKG,eACmB3C,IAAtBD,EAAQ4C,UAA0B5C,EAAQ4C,UAAYC,EAAA5B,QAMxDwB,EAAKK,uBAAsB,GAM3BL,EAAKM,sBAAqB,GAM1BN,EAAKO,4BAA8BhD,EAAQW,2BAM3C8B,EAAKQ,iBACwB,IAA3BjD,EAAQQ,eAA2B0C,EAAAC,8BAA2BlD,EAMhEwC,EAAKW,0BAA2B,WArEZC,EAAAb,EAAA5C,GA2EtB4C,EAAAc,UAAAC,eAAc,eACPC,EAAAC,2BAA0B,OACtB7D,EAAA0D,UAAMC,eAAcnD,KAAAC,cAEpBqD,UAAUH,iBAAc,OACxB,UAEIZ,KAAGtC,KAASyC,+BACZA,uBAAuBH,GAAKY,iBAAc,OAC1C,SAIN,GAOTf,EAAAc,UAAAK,YAAW,SAACvC,EAAYwC,MACjBJ,EAAAC,gCAICI,EAAaxD,KAAQyD,0BAA0B1C,WAK1C2C,UAHNL,UAAUC,YAAWtD,KACnBqD,WAAaG,EAAgBD,EAAS,IAEhCvD,KAASyC,uBAAsB,KACpCY,EAASrD,KAAQyC,uBAAuBiB,GAC9CL,EAAUC,YAAYD,GAAaG,EAAgBD,EAAS,UAV5DhE,EAAA0D,UAAMK,YAAWvD,KAAAC,KAACe,EAAYwC,IAiBlCpB,EAAAc,UAAAU,kBAAiB,uBACHf,iBAOdT,EAAAc,UAAAW,uBAAsB,SAAC7C,UAEnBoC,EAAAC,4BAA0BpD,KACrB6D,iBACL9C,IACC+C,EAAAC,WAAU/D,KAAM6D,gBAAiB9C,GAE3B,OAEKiD,aAOhB7B,EAAAc,UAAAe,UAAS,kBACA,GAQT7B,EAAAc,UAAAgB,OAAM,kBAEF1E,EAAA0D,UAAMgB,OAAMlE,KAAAC,OAAAA,KACN4C,gBAAe,KAAUsB,KAAKC,UAASnE,KAAM4C,iBAAe,KAQtET,EAAAc,UAAAmB,UAAS,SAACrD,WAENoC,EAAAC,4BAA0BpD,KACrB6D,iBACL9C,IACC+C,EAAAC,WAAU/D,KAAM6D,gBAAiB9C,KAI3BxB,EAAA0D,UAAMmB,UAASrE,KAAAC,KAACe,IAQ3BoB,EAAAc,UAAAoB,yBAAwB,SAACtD,OAClBoC,EAAAC,2BAA0B,OACtB7D,EAAA0D,UAAMoB,yBAAwBtE,KAAAC,KAACe,OAElCuD,EAAQtE,KAAQ6D,yBACb7C,UAAcsD,IAAYR,EAAAC,WAAWO,EAAUvD,QAGhDwD,EAAUC,EAAAC,OAAO1D,UACjBwD,KAAOvE,KAAS0C,wBAAqB1C,KACpC0C,sBAAsB6B,GAAWtD,EAAAyD,iBACpC3D,SAGQ2B,sBAAsB6B,GAT8B,OAAAvE,KACpDgB,UAgBhBmB,EAAAc,UAAAQ,0BAAyB,SAAC1C,OACnBoC,EAAAC,2BAA0B,OACtB7D,EAAA0D,UAAMQ,0BAAyB1D,KAAAC,KAACe,OAEnCuD,EAAQtE,KAAQ6D,oBACjBS,GAAYR,EAAAC,WAAWO,EAAUvD,GAAU,OAAAf,KAClCqD,cAENkB,EAAUC,EAAAC,OAAO1D,UACjBwD,KAAOvE,KAASyC,yBAAsBzC,KACrCyC,uBAAuB8B,GAAO,IAAQI,EAAA/D,QAASZ,KAC7CqD,UAAUuB,qBAGPnC,uBAAuB8B,IAcvCpC,EAAAc,UAAA4B,YAAW,SAACC,EAAGC,EAAGC,EAAGC,EAAYlE,EAAYuB,OACrC4C,EAAS,CAAIJ,EAAGC,EAAGC,GACnBG,EAAYnF,KAAQoF,+BACxBF,EACAnE,GAEIsE,EAAUF,EAAYnF,KACnByB,gBAAgB0D,EAAcF,EAAYlE,QAC/CnB,EACE0F,EAAI,IAAAtF,KAAYuC,UACpB2C,OACYtF,IAAZyF,EAAwBE,EAAA3E,QAAU4E,KAAOD,EAAA3E,QAAU6E,WACvC7F,IAAZyF,EAAwBA,EAAO,GAAArF,KAC1BH,YAAWG,KACXO,iBAAgBP,KAChB0F,oBAEPJ,EAAKhD,IAAMA,EACXgD,EAAKK,iBAAiBC,EAAAhF,QAAUiF,OAAM7F,KAAO8F,iBAAiBC,KAAI/F,OAC3DsF,GAWTnD,EAAAc,UAAA+C,QAAO,SAAClB,EAAGC,EAAGC,EAAGC,EAAYlE,OACrBkF,EAAgBjG,KAAQ6D,mBAE3BV,EAAAC,4BACA6C,GACAlF,IACD+C,EAAAC,WAAWkC,EAAkBlF,QAUvBmF,EAAKlG,KAAQyD,0BAA0B1C,GACvCmE,EAAS,CAAIJ,EAAGC,EAAGC,GACrBM,OAAI,EACFa,EAAeC,EAAAnC,OAAOiB,GACxBgB,EAAMG,YAAYF,KACpBb,EAAOY,EAAMI,IAAIH,QAEb7D,EAAGtC,KAAQiE,YACbqB,GAAQA,EAAKhD,KAAOA,EAAG,OAClBgD,MAEDiB,EAAcvG,KAAQqE,yBAAyB4B,GAC/CO,EAAcxG,KAAQqE,yBAAyBtD,GAC/C0F,EAAgBzG,KAAQoF,+BAC5BF,EACAnE,GAEI2F,EAAO,IAAOC,EAAA/F,QAClBqF,EACAM,EACAxF,EACAyF,EACAtB,EACAuB,EAAgBzG,KACX4G,kBAAkB3B,GAAUjF,KAC5BgE,YAAS,SACJ6C,EAAGC,EAAGC,EAAGC,eACLC,gBAAgBJ,EAAGC,EAAGC,EAAGC,EAAYf,IACjDF,KAAI/F,MAAAA,KACD2C,4BAA2B3C,KAC3B+C,yBAAwB/C,KACxB4C,wBAEP8D,EAAQpE,IAAMA,EAEVgD,GACFoB,EAAQQ,YAAc5B,EACtBoB,EAAQS,sBACRjB,EAAMkB,QAAQjB,EAAcO,IAE5BR,EAAMmB,IAAIlB,EAAcO,GAEnBA,EApD8B,OAAA1G,KAE3BiH,gBACVnC,EACAC,EACAC,EACAC,EACAgB,GAAoBlF,IA2D1BoB,EAAAc,UAAAgE,gBAAe,SAACnC,EAAGC,EAAGC,EAAGC,EAAYlE,OAC/BuE,EAAO,KACLa,EAAeC,EAAAkB,UAAUxC,EAAGC,EAAGC,GAC/B1C,EAAGtC,KAAQiE,iBACPZ,UAAUgD,YAAYF,QAI9Bb,EAAItF,KAAQqD,UAAUiD,IAAIH,IACjB7D,KAAOA,EAAG,KAIX4E,EAAc5B,EACpBA,EAAItF,KAAQ6E,YAAYC,EAAGC,EAAGC,EAAGC,EAAYlE,EAAYuB,GAGrD4E,EAAYK,YAAchC,EAAA3E,QAAU4E,KAEtCF,EAAK4B,YAAcA,EAAYA,YAE/B5B,EAAK4B,YAAcA,EAErB5B,EAAK6B,2BACA9D,UAAU+D,QAAQjB,EAAcb,SAnBvCA,EAAItF,KAAQ6E,YAAYC,EAAGC,EAAGC,EAAGC,EAAYlE,EAAYuB,QACpDe,UAAUgE,IAAIlB,EAAcb,UAqB5BA,GAQTnD,EAAAc,UAAAuE,2BAA0B,SAACC,MAEtBtE,EAAAC,4BAA0BpD,KACtB+C,0BAA4B0E,WAKxB/D,UADNX,yBAA2B0E,EACnBzH,KAASyC,uBAAsBzC,KACrCyC,uBAAuBiB,GAAIgE,aAE7BC,YAePxF,EAAAc,UAAA2E,yBAAwB,SAAC7G,EAAY8G,MAC/B1E,EAAAC,2BAA0B,KACtB0E,EAAOhE,EAAAwC,IAAcvF,MACvB+G,EAAI,KACAvD,EAAUC,EAAAC,OAAOqD,GACjBvD,KAAOvE,KAAS0C,wBAAqB1C,KACpC0C,sBAAsB6B,GAAWsD,MAKhD1F,EA/YA,CAAwB4F,EAAAnH,slBCkFxBoH,EA9IA,SAAAzI,GAQK,SACH0I,EACE/C,EACA7C,EACAL,EACAnC,EACAU,EACAd,OANF2C,EAQE7C,EAAAQ,KAAAC,KAAMkF,EAAW7C,EAAO5C,IAAWO,YAMnCoC,EAAK8F,aAAerI,EAQpBuC,EAAK+F,KAAOnG,EAEZI,EAAKE,IAAMN,EAMXI,EAAKgG,OAAM,IAAOC,MACE,OAAhBxI,IACFuC,EAAKgG,OAAOvI,YAAcA,GAO5BuC,EAAKkG,UAAY,KAMjBlG,EAAKmG,kBAAoBhI,WAtDLiI,EAAAP,EAAA1I,GA8DtB0I,EAAAhF,UAAAhB,SAAQ,uBACMmG,QAQdH,EAAAhF,UAAAwF,kBAAiB,WA+DhB,IAEKC,OAhECrG,MAAQkD,EAAA3E,QAAU+H,WAClBC,sBACAR,SA8DDM,EAAMG,EAAAC,sBAAsB,EAAG,IACjCC,UAAS,gBACbL,EAAIM,SAAS,EAAG,EAAG,EAAG,GACfN,EAAIO,aAhEJtB,WAQPM,EAAAhF,UAAAiG,iBAAgB,eACRC,EAAKnJ,KAAyCoI,OAChDe,EAAMC,cAAgBD,EAAME,cAAarJ,KACtCqC,MAAQkD,EAAA3E,QAAU0I,YAElBjH,MAAQkD,EAAA3E,QAAU6E,WAEpBmD,sBACAjB,WAOPM,EAAAhF,UAAAsG,KAAI,gBACOlH,OAASkD,EAAA3E,QAAU+H,aACrBtG,MAAQkD,EAAA3E,QAAU4E,UAClB4C,OAAM,IAAOC,MACQ,YAAjBH,eAAqBlI,KACvBoI,OAAOvI,YAAWG,KAAQkI,oBAG1B7F,OAASkD,EAAA3E,QAAU4E,YACrBnD,MAAQkD,EAAA3E,QAAU4I,aAClB7B,eACAY,kBAAiBvI,KAAAA,KAAYmI,WAC7BG,UAAYmB,EAAAC,YAAW1J,KACrBoI,OAAMpI,KACNkJ,iBAAiBnD,KAAI/F,MAAAA,KACrByI,kBAAkB1C,KAAI/F,SAUjCiI,EAAAhF,UAAA2F,eAAc,gBACHN,iBACFA,iBACAA,UAAY,OAGvBL,EAjIA,CAAwB0B,EAAA/I,+lBCiTxBgJ,EA/OA,SAAArK,GAKK,SACHsK,EAAY3E,EAAW7C,EAAO5C,OAA9B2C,EACE7C,EAAAQ,KAAAC,OAAAA,KAEML,EAAUF,GAAyB,UAKzC2C,EAAK8C,UAAYA,EAMjB9C,EAAKC,MAAQA,EAQbD,EAAK8E,YAAc,KAQnB9E,EAAK0H,MAAO,EAQZ1H,EAAKE,IAAG,GAMRF,EAAK2H,iBACoBnK,IAAvBD,EAAQa,WAA2B,IAAMb,EAAQa,WAOnD4B,EAAK4H,kBAAiB,YA1DPC,EAAAJ,EAAAtK,GAgEjBsK,EAAA5G,UAAA0E,QAAO,gBACAuC,cAActE,EAAAhF,QAAUiF,SAM/BgE,EAAA5G,UAAAkH,QAAO,aAKPN,EAAA5G,UAAAgB,OAAM,uBACQ3B,IAAG,IAAMtC,KAAQkF,WAS/B2E,EAAA5G,UAAAmH,eAAc,oBACFlD,4BAIN5B,EAAItF,KAAQkH,kBAOV5B,EAAKiC,YAAchC,EAAA3E,QAAU0I,mBAG1BS,YAAc,EACZzE,EAETA,EAAOA,EAAK4B,kBACL5B,gBAUXuE,EAAA5G,UAAAkE,oBAAmB,mBACPD,iBAIN5B,EAAItF,KAAQkH,YACZmD,EAAIrK,WAGFsF,EAAKiC,YAAchC,EAAA3E,QAAU0I,OAAM,CAIrChE,EAAK4B,YAAc,WAEV5B,EAAKiC,YAAchC,EAAA3E,QAAU4I,QAGtCa,EAAO/E,EACEA,EAAKiC,YAAchC,EAAA3E,QAAU4E,KAGtC6E,EAAKnD,YAAc5B,EAAK4B,YAExBmD,EAAO/E,EAETA,EAAO+E,EAAKnD,kBACL5B,KAQXuE,EAAA5G,UAAAqH,aAAY,uBACEpF,WAMd2E,EAAA5G,UAAAsE,SAAQ,uBACMlF,OAWdwH,EAAA5G,UAAAsH,SAAQ,SAAClI,WACEA,QAAUkD,EAAA3E,QAAU+H,OAAK3I,KAASqC,MAAQA,EAAK,MAAA,IAC5CmI,MAAK,qCAEZnI,MAAQA,OACRsF,WAUPkC,EAAA5G,UAAAsG,KAAI,WACF/E,EAAAiG,YASFZ,EAAA5G,UAAAyH,SAAQ,SAAChH,EAAIiH,YACDZ,YAAW,OACZ,MAGLa,EAAK5K,KAAQgK,kBAAkBtG,MAC9BkH,OAGgB,IAAVA,EAAY,OACd,OAHPA,EAAQD,OACHX,kBAAkBtG,GAAMkH,MAKzBC,EAAQF,EAAOC,EAAQ,IAAO,UAChCC,GAAK7K,KAAS+J,YACT,EAEFe,EAAAC,OAAOF,EAAK7K,KAAQ+J,cAU7BF,EAAA5G,UAAA+H,aAAY,SAACtH,gBACDqG,cAG4B,SAA1BC,kBAAkBtG,IAOhCmG,EAAA5G,UAAAgI,cAAa,SAACvH,QACHqG,cAAW/J,KACbgK,kBAAkBtG,IAAM,IAGnCmG,EA7OA,CAAmBqB,EAAAtK,mpBC4RnBuK,EA3UA,SAAA5L,GAeK,SACH6L,EACEC,EACA9E,EACA+E,EACA9E,EACAtB,EACAuB,EACAxB,EACAsG,EACAC,EACAC,EACAC,EACAC,OAZFvJ,EAcE7C,EAAAQ,KAAAC,KAAMkF,EAAWK,EAAA3E,QAAU4E,OAAIxF,KAM/BoC,EAAKwJ,kBAAmChM,IAApB8L,GAAgCA,EAMpDtJ,EAAKQ,gBAAkB+I,EAMvBvJ,EAAKyJ,YAAc5G,EAMnB7C,EAAK0J,QAAUP,EAMfnJ,EAAK2J,QAAU,KAMf3J,EAAK4J,gBAAkBzF,EAMvBnE,EAAK6J,gBAAkBzF,EAMvBpE,EAAK8J,kBAAoBzF,GAAsCvB,EAM/D9C,EAAK+J,aAAY,GAMjB/J,EAAKgK,qBAAuB,KAM5BhK,EAAKiK,SAAW,MAEVC,EAAe9F,EAAe+F,mBAClCnK,EAAK8J,mBAEDM,EAAkBpK,EAAK6J,gBAAgBQ,YACzCC,EAAkBtK,EAAK4J,gBAAgBS,YAErCE,EAAsBH,EACxBI,EAAAC,gBAAgBP,EAAcE,GAC9BF,KAEiC,IAAjCM,EAAAE,QAAQH,UAGVvK,EAAKC,MAAQkD,EAAA3E,QAAU6E,YAInBsH,EAAmB1B,EAAWoB,YAChCM,IAIAL,EAHGA,EAGeE,EAAAC,gBAAgBH,EAAiBK,GAFjCA,OAMhBC,EAAmBxG,EAAeyG,cACtC7K,EAAK8J,kBAAkB,IAGnBgB,EAAmBC,EAAAC,gCACvB/B,EACAC,EACAqB,EACAK,OAGGK,SAASH,IAAqBA,GAAoB,SAGrD9K,EAAKC,MAAQkD,EAAA3E,QAAU6E,YAInB6H,OACmB1N,IAAvB6L,EAAmCA,EAAqBtI,EAAAoK,mBAM1DnL,EAAKoL,eAAc,IAAOC,EAAA7M,QACxByK,EACAC,EACAqB,EACAD,EACAQ,EAAmBI,EACnBN,GAGgD,IAA9C5K,EAAKoL,eAAeE,eAAeC,cAErCvL,EAAKC,MAAQkD,EAAA3E,QAAU6E,QAIzBrD,EAAKiK,SAAW9F,EAAeqH,kBAAkBV,OAC7CW,EAAezL,EAAKoL,eAAeM,2BAEnCpB,IACErB,EAAW0C,YACbF,EAAa,GAAKG,EAAAC,MAChBJ,EAAa,GACbnB,EAAgB,GAChBA,EAAgB,IAElBmB,EAAa,GAAKG,EAAAC,MAChBJ,EAAa,GACbnB,EAAgB,GAChBA,EAAgB,KAGlBmB,EAAejB,EAAAC,gBAAgBgB,EAAcnB,IAI5CE,EAAAE,QAAQe,YAGLK,EAAc3H,EAAe4H,0BACjCN,EACAzL,EAAKiK,UAGE+B,EAAOF,EAAYG,KAAMD,GAAQF,EAAYI,KAAMF,IAAI,IAAA,IACrDG,EAAOL,EAAYM,KAAMD,GAAQL,EAAYO,KAAMF,IAAI,KACxDjJ,EAAOkG,EAAgBpJ,EAAKiK,SAAU+B,EAAMG,EAAMtJ,GACpDK,GACFlD,EAAK+J,aAAauC,KAAKpJ,GAKI,IAA7BlD,EAAK+J,aAAawB,SACpBvL,EAAKC,MAAQkD,EAAA3E,QAAU6E,YAjBzBrD,EAAKC,MAAQkD,EAAA3E,QAAU6E,sBAzLJkJ,EAAAvD,EAAA7L,GAmNvB6L,EAAAnI,UAAAhB,SAAQ,uBACM8J,SAMdX,EAAAnI,UAAA2L,WAAU,eACFC,EAAO,WACR1C,aAAa2C,QAAO,SACbxJ,EAAMyJ,EAAGC,GACb1J,GAAQA,EAAKiC,YAAchC,EAAA3E,QAAU0I,QACvCuF,EAAQH,KAAI,CACVvN,OAAMnB,KAAOgM,gBAAgBO,mBAAmBjH,EAAKJ,WACrDiE,MAAO7D,EAAKrD,cAGhB8D,KAAI/F,YAEHmM,aAAawB,OAAS,EAEJ,IAAnBkB,EAAQlB,OAAY3N,KACjBqC,MAAQkD,EAAA3E,QAAU+H,eAEjB7D,EAAC9E,KAAQkM,kBAAkB,GAC3B+C,EAAIjP,KAAQiM,gBAAgBiD,YAAYpK,GACxCqK,EAAmB,iBAAJF,EAAoBA,EAAOA,EAAK,GAC/CG,EAAoB,iBAAJH,EAAoBA,EAAOA,EAAK,GAChDjC,EAAgBhN,KAAQiM,gBAAgBgB,cAAcnI,GACtDoI,EAAgBlN,KAAQgM,gBAAgBiB,cAAajN,KACpDqM,UAGDC,EAAYtM,KAAQiM,gBAAgBM,mBAAkBvM,KACrDkM,wBAEFH,QAAUoB,EAAA1F,OACb0H,EACAC,EAAMpP,KACD6L,YACLqB,EAAgBlN,KACXgM,gBAAgBS,YACrBO,EACAV,EAAYtM,KACPwN,eACLqB,EAAO7O,KACF8L,QAAO9L,KACP4L,aAAY5L,KACZ4C,sBAGFP,MAAQkD,EAAA3E,QAAU0I,YAEpB3B,WAMPyD,EAAAnI,UAAAsG,KAAI,mBACOlH,OAASkD,EAAA3E,QAAU4E,KAAI,MACzBnD,MAAQkD,EAAA3E,QAAU4I,aAClB7B,cAED0H,EAAa,OAEZjD,qBAAoB,QACpBD,aAAa2C,QAAO,SACbxJ,EAAMyJ,EAAGC,OACX3M,EAAQiD,EAAKiC,cACflF,GAASkD,EAAA3E,QAAU4E,MAAQnD,GAASkD,EAAA3E,QAAU4I,QAAO,CACvD6F,QAEMC,EAAkBC,EAAAC,OACtBlK,EACAM,EAAAhF,QAAUiF,QAAM,SACN4J,OACFC,EAAQpK,EAAKiC,WAEjBmI,GAASnK,EAAA3E,QAAU0I,QACnBoG,GAASnK,EAAA3E,QAAU+H,OACnB+G,GAASnK,EAAA3E,QAAU6E,QAEnB8J,EAAAI,cAAcL,GAEK,MADnBD,SAEOO,wBACAhB,4BAMRxC,qBAAqBsC,KAAKY,KAEjCvJ,KAAI/F,YAGHmM,aAAa2C,SAAO,SAAWxJ,EAAMyJ,EAAGC,GAC7B1J,EAAKiC,YACNhC,EAAA3E,QAAU4E,MACrBF,EAAKiE,UAIU,IAAf8F,GACFQ,WAAU7P,KAAM4O,WAAW7I,KAAI/F,MAAQ,KAQ7CoL,EAAAnI,UAAA2M,iBAAgB,gBACTxD,qBAAqB0C,QAAQS,EAAAI,oBAC7BvD,qBAAuB,MAEhChB,EAzUA,CAAyBzB,EAAA/I,2IClBZkP,EAAkB,GAOlBC,GAA6B,iHC0e1CC,EAzcA,WAQK,SACHC,EACE5E,EACAC,EACAgB,EACAI,EACAwD,EACAC,GAKGnQ,KACEoQ,YAAc/E,EAKhBrL,KACEqQ,YAAc/E,EAEkD,IACjEgF,EAAiB,GACfC,EAAezM,EAAA0M,aAAYxQ,KAAMqQ,YAAWrQ,KAAOoQ,aAMtDpQ,KACEyQ,cAAa,SAAaC,OACvBpO,EAAMoO,EAAE,GAAC,IAAUA,EAAE,UACtBJ,EAAkBhO,KACrBgO,EAAkBhO,GAAOiO,EAAaG,IAEjCJ,EAAkBhO,IAMxBtC,KACE2Q,iBAAmBjE,EAKrB1M,KACE4Q,uBAAyBV,EAAiBA,EAK5ClQ,KACE6Q,WAAU,GAMZ7Q,KACE8Q,iBAAkB,EAKpB9Q,KACE+Q,kBAAiB/Q,KACfoQ,YAAYrC,cACfrB,KAAe1M,KACVoQ,YAAY3D,aACnBG,EAAAoE,SAAStE,IAAoBE,EAAAoE,SAAQhR,KAAMoQ,YAAY3D,aAKtDzM,KACEiR,kBAAiBjR,KAAQoQ,YAAY3D,YACtCG,EAAAoE,SAAQhR,KAAMoQ,YAAY3D,aAC1B,KAKDzM,KACEkR,kBAAiBlR,KAAQqQ,YAAY5D,YACtCG,EAAAoE,SAAQhR,KAAMqQ,YAAY5D,aAC1B,SAEE0E,EAAqBvE,EAAAwE,WAAW9E,GAChC+E,EAAsBzE,EAAA0E,YAAYhF,GAClCiF,EAAyB3E,EAAA4E,eAAelF,GACxCmF,EAAwB7E,EAAA8E,cAAcpF,GACtCqF,EAAa3R,KAAQyQ,cAAcU,GACnCS,EAAc5R,KAAQyQ,cAAcY,GACpCQ,EAAiB7R,KAAQyQ,cAAcc,GACvCO,EAAgB9R,KAAQyQ,cAAcgB,GAYtCM,EArIc,IAuIjB5B,EACG6B,KAAKC,IACH,EACAD,KAAKE,KACHlE,EAAAmE,KACEvF,EAAAE,QAAQR,IACL6D,EACCA,EADD,UAOT,WAEDiC,SACHjB,EACAE,EACAE,EACAE,EACAE,EACAC,EACAC,EACAC,EACAC,QAGOjB,gBAAe,KAClBuB,EAAYC,EAAAA,OACXzB,WAAW/B,SAAO,SAAWyD,EAAUxD,EAAGC,GAC7CqD,EAAYL,KAAKQ,IACfH,EACAE,EAASE,OAAO,GAAG,GACnBF,EAASE,OAAO,GAAG,GACnBF,EAASE,OAAO,GAAG,YAMlB5B,WAAW/B,QAAO,SACXyD,MAENP,KAAKC,IACHM,EAASE,OAAO,GAAG,GACnBF,EAASE,OAAO,GAAG,GACnBF,EAASE,OAAO,GAAG,IAEnBJ,EAASrS,KACNiR,kBAAoB,EAAC,KAEpByB,EAAW,EACdH,EAASE,OAAO,GAAG,GAAIF,EAASE,OAAO,GAAG,KAC1CF,EAASE,OAAO,GAAG,GAAIF,EAASE,OAAO,GAAG,KAC1CF,EAASE,OAAO,GAAG,GAAIF,EAASE,OAAO,GAAG,KAEzCC,EAAY,GAAG,GAAKL,EAASrS,KAAQiR,kBAAoB,IAC3DyB,EAAY,GAAG,IAAC1S,KAAUiR,mBAExByB,EAAY,GAAG,GAAKL,EAASrS,KAAQiR,kBAAoB,IAC3DyB,EAAY,GAAG,IAAC1S,KAAUiR,mBAExByB,EAAY,GAAG,GAAKL,EAASrS,KAAQiR,kBAAoB,IAC3DyB,EAAY,GAAG,IAAC1S,KAAUiR,uBAMtB5C,EAAO2D,KAAKQ,IAChBE,EAAY,GAAG,GACfA,EAAY,GAAG,GACfA,EAAY,GAAG,IAEJV,KAAKC,IAChBS,EAAY,GAAG,GACfA,EAAY,GAAG,GACfA,EAAY,GAAG,IAENrE,EAAIrO,KAAQiR,kBAAoB,IACzCsB,EAASE,OAASC,KAGtB3M,KAAI/F,OAIVsQ,EAAiB,UAanBL,EAAAhN,UAAA0P,aAAY,SAACC,EAAGC,EAAGnC,EAAGoC,EAAMC,EAAMC,QAC3BnC,WAAWnC,KAAI,CAClB+D,OAAM,CAAGK,EAAMC,EAAMC,GACrBC,OAAM,CAAGL,EAAGC,EAAGnC,MAoBnBT,EAAAhN,UAAAmP,SAAQ,SAACQ,EAAGC,EAAGnC,EAAGwC,EAAGJ,EAAMC,EAAMC,EAAMG,EAAMpB,OACrCqB,EAAmBxG,EAAAyG,eAAc,CAAEP,EAAMC,EAAMC,EAAMG,IACrDG,EAAetT,KAAQiR,kBACzBrE,EAAAoE,SAASoC,GAAgBpT,KAASiR,kBAClC,KACEsC,EAAgBvT,KAA+BiR,kBAI/CuC,EAAMxT,KACLoQ,YAAYrC,YACjBuF,EAAkB,IAClBA,EAAkB,EAEhBG,GAAmB,KAEnB1B,EAAiB,EAAC,SACX1B,YAAYqD,YAAQ1T,KAAWkR,kBAAiB,KACjDyC,EAAmB/G,EAAAyG,eAAc,CAAET,EAAGC,EAAGnC,EAAGwC,IAGlDO,EADE7G,EAAAoE,SAAS2C,GAAgB3T,KAASkR,kBA5QjB,KA8QuBuC,GAEvCD,GAAMxT,KAASoQ,YAAYsD,YAAcJ,IAC5CG,EACEH,EAlRiB,KAkRuBG,SAIzCA,GAAgBzT,KAAS2Q,kBAE1BtD,SAAS+F,EAAiB,KAC1B/F,SAAS+F,EAAiB,KAC1B/F,SAAS+F,EAAiB,KAC1B/F,SAAS+F,EAAiB,MAErBxG,EAAAgH,WAAWR,EAAgBpT,KAAO2Q,uBAOvCkD,EAAc,OAEbJ,GAEApG,SAASyF,EAAK,KACdzF,SAASyF,EAAK,KACdzF,SAAS0F,EAAK,KACd1F,SAAS0F,EAAK,KACd1F,SAAS2F,EAAK,KACd3F,SAAS2F,EAAK,KACd3F,SAAS8F,EAAK,KACd9F,SAAS8F,EAAK,QAEXpB,EAAiB,EACnB0B,GAAmB,UAUF,IANjBI,GACIxG,SAASyF,EAAK,KAAQzF,SAASyF,EAAK,IAAU,EAAJ,IAC1CzF,SAAS0F,EAAK,KAAQ1F,SAAS0F,EAAK,IAAU,EAAJ,IAC1C1F,SAAS2F,EAAK,KAAQ3F,SAAS2F,EAAK,IAAU,EAAJ,IAC1C3F,SAAS8F,EAAK,KAAQ9F,SAAS8F,EAAK,IAAU,EAAJ,KAG7B,GAAfU,GACe,GAAfA,GACe,GAAfA,EAAgB,UAQpB9B,EAAiB,EAAC,KACf0B,EAAgB,KACbK,EAAM,EAAKlB,EAAE,GAAKlC,EAAE,IAAM,GAAIkC,EAAE,GAAKlC,EAAE,IAAM,GAC7CqD,EAAS/T,KAAQyQ,cAAcqD,GAEjCE,OAAE,KACFR,EAKFQ,GAHGhG,EAAAiG,OAAOnB,EAAK,GAAIS,GACfvF,EAAAiG,OAAOjB,EAAK,GAAIO,IAClB,EACqBvF,EAAAiG,OAAOF,EAAU,GAAIR,QAE5CS,GAAMlB,EAAK,GAAKE,EAAK,IAAM,EAAIe,EAAU,OAErCG,GAAMpB,EAAK,GAAKE,EAAK,IAAM,EAAIe,EAAU,GAE/CN,EAD8BO,EAAKA,EAAKE,EAAKA,EACLlU,KAAQ4Q,0BAE9C6C,EAAgB,IACdzB,KAAKmC,IAAIvB,EAAE,GAAKlC,EAAE,KAAOsB,KAAKmC,IAAIvB,EAAE,GAAKlC,EAAE,IAAC,KAExC0D,EAAE,EAAKvB,EAAE,GAAKnC,EAAE,IAAM,GAAImC,EAAE,GAAKnC,EAAE,IAAM,GACzC2D,EAAKrU,KAAQyQ,cAAc2D,GAC3BE,EAAE,EAAKpB,EAAE,GAAKN,EAAE,IAAM,GAAIM,EAAE,GAAKN,EAAE,IAAM,GACzC2B,EAAKvU,KAAQyQ,cAAc6D,QAE5BlC,SACHQ,EACAC,EACAuB,EACAE,EACAxB,EACAC,EACAsB,EACAE,EACAxC,EAAiB,QAEdK,SACHkC,EACAF,EACA1D,EACAwC,EACAqB,EACAF,EACArB,EACAG,EACApB,EAAiB,YAIbyC,EAAE,EAAK5B,EAAE,GAAKC,EAAE,IAAM,GAAID,EAAE,GAAKC,EAAE,IAAM,GACzC4B,EAAKzU,KAAQyQ,cAAc+D,GAC3BE,EAAE,EAAKhE,EAAE,GAAKwC,EAAE,IAAM,GAAIxC,EAAE,GAAKwC,EAAE,IAAM,GACzCyB,EAAK3U,KAAQyQ,cAAciE,QAE5BtC,SACHQ,EACA4B,EACAE,EACAxB,EACAJ,EACA2B,EACAE,EACAxB,EACApB,EAAiB,QAEdK,SACHoC,EACA3B,EACAnC,EACAgE,EACAD,EACA1B,EACAC,EACA2B,EACA5C,EAAiB,cAOrByB,EAAM,UACEzC,kBAAiB,YAGtBD,iBAAkB,EAOE,IAAR,GAAd+C,IAAuB7T,KACrB2S,aAAaC,EAAGlC,EAAGwC,EAAGJ,EAAME,EAAMG,GAEd,IAAR,GAAdU,IAAuB7T,KACrB2S,aAAaC,EAAGlC,EAAGmC,EAAGC,EAAME,EAAMD,GAErCc,IAEyB,IAAR,GAAdA,IAAuB7T,KACrB2S,aAAaE,EAAGK,EAAGN,EAAGG,EAAMI,EAAML,GAEd,IAAR,EAAde,IAAuB7T,KACrB2S,aAAaE,EAAGK,EAAGxC,EAAGqC,EAAMI,EAAMH,MAU7C/C,EAAAhN,UAAA6K,sBAAqB,eACb3M,EAASyL,EAAAgI,0BAEV/D,WAAW/B,SAAO,SAAWyD,EAAUxD,EAAGC,OACvChN,EAAMuQ,EAASE,OACrB7F,EAAAiI,iBAAiB1T,EAAQa,EAAI,IAC7B4K,EAAAiI,iBAAiB1T,EAAQa,EAAI,IAC7B4K,EAAAiI,iBAAiB1T,EAAQa,EAAI,OAGxBb,GAMT8O,EAAAhN,UAAAyK,aAAY,uBACEmD,YAEhBZ,EAvcA,iIC9BI6E,gFAWD,SACMC,EAAiBrM,EAAKsM,EAAIC,EAAIC,EAAIC,GACzCzM,EAAI0M,YACJ1M,EAAI2M,OAAO,EAAG,GACd3M,EAAI4M,OAAON,EAAIC,GACfvM,EAAI4M,OAAOJ,EAAIC,GACfzM,EAAI6M,YACJ7M,EAAI8M,OACJ9M,EAAI+M,OACJ/M,EAAIM,SAAS,EAAG,EAAGgJ,KAAKC,IAAI+C,EAAIE,GAAM,EAAGlD,KAAKC,IAAIgD,EAAIE,IACtDzM,EAAIgN,UAUH,SACMC,EAA8BC,EAAMC,UAGzC7D,KAAKmC,IAAIyB,EAAc,EAATC,GAAc,KAAO,GACnC7D,KAAKmC,IAAIyB,EAAc,EAATC,EAAa,GAAK,QAAc,WA2ClCC,EACdzK,EACAC,EACAyK,EACA/I,OAEMgJ,EAAelS,EAAAmS,UAAUF,EAAczK,EAAYD,GAGrD6B,EAAmBpJ,EAAAoS,mBACrB5K,EACA0B,EACA+I,GAGII,EAAsB7K,EAAW8K,wBACXxW,IAAxBuW,IACFjJ,GAAoBiJ,OAEhBE,EAAsBhL,EAAW+K,wBACXxW,IAAxByW,IACFnJ,GAAoBmJ,OAOhBxI,EAAexC,EAAWoB,gBAC3BoB,GAAgBjB,EAAA0J,mBAAmBzI,EAAcmI,GAAY,KAC1DO,EACJzS,EAAAoS,mBAAmB7K,EAAY6B,EAAkB8I,GACjD9I,EACEG,SAASkJ,IAAuBA,EAAqB,IACvDrJ,GAAoBqJ,UAIjBrJ,WAeOsJ,EACdnL,EACAC,EACAgB,EACAU,OAEM+I,EAAenJ,EAAA6J,UAAUnK,GAC3BY,EAAmB4I,EACrBzK,EACAC,EACAyK,EACA/I,WAGGK,SAASH,IAAqBA,GAAoB,IACrDN,EAAA8J,cAAcpK,GAAY,SAAYqK,UACpCzJ,EAAmB4I,EACjBzK,EACAC,EACAqL,EACA3J,GAEKK,SAASH,IAAqBA,EAAmB,KAIrDA,WA0BO0J,EACdzH,EACAC,EACAnK,EACAiI,EACAW,EACAb,EACAV,EACAuK,EACAhI,EACAtD,EACAG,EACAC,OAEMmL,EAAUjO,EAAAC,sBACdkJ,KAAK+E,MAAM9R,EAAakK,GACxB6C,KAAK+E,MAAM9R,EAAamK,OAE1B4H,EAAAC,OAAOH,EAASnL,GAEO,IAAnBkD,EAAQlB,OAAY,OACfmJ,EAAQ7N,gBAKRiO,EAAWC,UACXnF,KAAK+E,MAAMI,EAAQlS,GAAcA,EAH1C6R,EAAQM,MAAMnS,EAAYA,GAM1B6R,EAAQO,yBAAwB,cAE1BC,EAAmB1K,EAAAgI,cACzB/F,EAAQC,SAAO,SAAW9M,EAAK+M,EAAGC,GAChCpC,EAAA2K,OAAOD,EAAkBtV,EAAIb,eAGzBqW,EAAqB5K,EAAAoE,SAASsG,GAC9BG,EAAsB7K,EAAA8K,UAAUJ,GAChCK,EAAgB9O,EAAAC,sBACpBkJ,KAAK+E,MAAO9R,EAAauS,EAAsBtK,GAC/C8E,KAAK+E,MAAO9R,EAAawS,EAAuBvK,IAElD8J,EAAAC,OAAOU,EAAehM,OAEhBiM,EAAc3S,EAAaiI,EAEjC2B,EAAQC,SAAO,SAAW9M,EAAK+M,EAAGC,OAC1B6I,EAAO7V,EAAIb,OAAO,GAAKmW,EAAiB,GACxCQ,IAAS9V,EAAIb,OAAO,GAAKmW,EAAiB,IAC1CS,EAAWnL,EAAAoE,SAAShP,EAAIb,QACxB6W,EAAYpL,EAAA8K,UAAU1V,EAAIb,QAG5Ba,EAAImH,MAAMgG,MAAQ,GAAKnN,EAAImH,MAAMiG,OAAS,GAC5CuI,EAAcM,UACZjW,EAAImH,MACJoC,EACAA,EACAvJ,EAAImH,MAAMgG,MAAQ,EAAI5D,EACtBvJ,EAAImH,MAAMiG,OAAS,EAAI7D,EACvBsM,EAAOD,EACPE,EAAOF,EACPG,EAAWH,EACXI,EAAYJ,UAKZM,EAAgBtL,EAAAwE,WAAW9E,UAEjCuK,EAAcnJ,eAAeoB,SAAO,SAAWyD,EAAUxD,EAAGC,GAoBvD,IACGyD,EAASF,EAASE,OAClBQ,EAASV,EAASU,OACpBkF,EAAK1F,EAAO,GAAG,GACjB2F,EAAK3F,EAAO,GAAG,GACb3L,EAAK2L,EAAO,GAAG,GACjB1L,EAAK0L,EAAO,GAAG,GACb4F,EAAK5F,EAAO,GAAG,GACjB6F,EAAK7F,EAAO,GAAG,GAEX8F,EAAKrB,GAAYjE,EAAO,GAAG,GAAKiF,EAAc,IAAMlL,GACpDwL,EAAKtB,IACPjE,EAAO,GAAG,GAAKiF,EAAc,IAAMlL,GAEjCgI,EAAKkC,GAAYjE,EAAO,GAAG,GAAKiF,EAAc,IAAMlL,GACpDiI,EAAKiC,IACPjE,EAAO,GAAG,GAAKiF,EAAc,IAAMlL,GAEjCkI,EAAKgC,GAAYjE,EAAO,GAAG,GAAKiF,EAAc,IAAMlL,GACpDmI,EAAK+B,IACPjE,EAAO,GAAG,GAAKiF,EAAc,IAAMlL,GAMjCyL,EAAwBN,EACxBO,EAAwBN,EAC9BD,EAAK,EACLC,EAAK,MAMCO,EAAe,EALrB7R,GAAM2R,EACN1R,GAAM2R,EAKK,EAAG,EAAG1D,EAAKuD,IAJtBF,GAAMI,EACNH,GAAMI,EAIK,EAAG,EAAGxD,EAAKqD,IACnB,EAAG,EAAGzR,EAAIC,EAAIkO,EAAKuD,IACnB,EAAG,EAAGH,EAAIC,EAAInD,EAAKqD,IAEhBI,EAAc5K,EAAA6K,kBAAkBF,MACjCC,MAIL9B,EAAQtB,OACRsB,EAAQ1B,YAjRT,mBAEgCxV,IAA7BkV,EAAsC,KAClCpM,EAAMoQ,SAASC,cAAa,UAAWC,WAAU,MACvDtQ,EAAI2O,yBAAwB,UAC5B3O,EAAIK,UAAS,wBACbgM,EAAiBrM,EAAK,EAAG,EAAG,EAAG,GAC/BqM,EAAiBrM,EAAK,EAAG,EAAG,EAAG,OACzBkN,EAAOlN,EAAIuQ,aAAa,EAAG,EAAG,EAAG,GAAGrD,KAC1Cd,EACEa,EAA8BC,EAAM,IACpCD,EAA8BC,EAAM,IACpCD,EAA8BC,EAAM,UAGjCd,EAqQHoE,IACAvN,IAAuB9I,EAAAC,yBAAwB,CAG/CgU,EAAQzB,OAAOL,EAAIC,WAGbkE,EAAKZ,EAAKvD,EACVoE,EAAKZ,EAAKvD,EACPoE,EAAO,EAAGA,EAHL,EAGmBA,IAE/BvC,EAAQxB,OACNN,EAAKkC,GAAamC,EAAO,GAAKF,EANpB,GAOVlE,EAAKiC,EAAYmC,EAAOD,EAAE,IAGhBE,GAARD,GACFvC,EAAQxB,OACNN,EAAKkC,GAAamC,EAAO,GAAKF,EAZtB,GAaRlE,EAAKiC,GAAamC,EAAO,GAAKD,EAAE,IAKtCtC,EAAQxB,OAAOJ,EAAIC,QAEnB2B,EAAQzB,OAAOL,EAAIC,GACnB6B,EAAQxB,OAAOiD,EAAIC,GACnB1B,EAAQxB,OAAOJ,EAAIC,GAGrB2B,EAAQrB,OAERqB,EAAQb,UACN2C,EAAY,GACZA,EAAY,GACZA,EAAY,GACZA,EAAY,GACZL,EACAC,GAGF1B,EAAQyC,UACNjC,EAAiB,GAAKmB,EACtBnB,EAAiB,GAAKoB,GAGxB5B,EAAQM,MACNlK,EAAmBjI,GAClBiI,EAAmBjI,GAGtB6R,EAAQmB,UAAUN,EAAc1O,OAAQ,EAAG,GAC3C6N,EAAQpB,cAGNhK,IACFoL,EAAQtB,OAERsB,EAAQO,yBAAwB,cAChCP,EAAQ0C,YAAW,QACnB1C,EAAQ2C,UAAY,EAEpB5C,EAAcnJ,eAAeoB,SAAO,SAAWyD,EAAUxD,EAAGC,OACpDiE,EAASV,EAASU,OAClBsF,GAAMtF,EAAO,GAAG,GAAKiF,EAAc,IAAMlL,EACzCwL,IAAOvF,EAAO,GAAG,GAAKiF,EAAc,IAAMlL,EAC1CgI,GAAM/B,EAAO,GAAG,GAAKiF,EAAc,IAAMlL,EACzCiI,IAAOhC,EAAO,GAAG,GAAKiF,EAAc,IAAMlL,EAC1CkI,GAAMjC,EAAO,GAAG,GAAKiF,EAAc,IAAMlL,EACzCmI,IAAOlC,EAAO,GAAG,GAAKiF,EAAc,IAAMlL,EAEhD8J,EAAQ1B,YACR0B,EAAQzB,OAAOL,EAAIC,GACnB6B,EAAQxB,OAAOiD,EAAIC,GACnB1B,EAAQxB,OAAOJ,EAAIC,GACnB2B,EAAQvB,YACRuB,EAAQ4C,YAGV5C,EAAQpB,WAEHoB,EAAQ7N,iGC5ZJ0Q,EAAwB,CACnCC,uBAAuB,EACvBC,yBAAyB,kjBC0B3BC,EApCA,SAAAva,YAAAwa,0DAAwBC,EAAAD,EAAAxa,GAItBwa,EAAA9W,UAAAK,YAAW,SAACC,aACEL,kBAAc,IACdlD,KAAQia,WACThW,WAAYV,EAAS,WAGvB2W,MAAM/P,YAQjB4P,EAAA9W,UAAAkX,mBAAkB,cACQ,SAAfC,gBAGH9X,EAAGtC,KAAQqa,eAEXvV,EADYsB,EAAAkU,QAAQhY,GACN,QACfwM,QAAO,SACAxJ,GACJA,EAAKJ,UAAU,KAAOJ,SACnByV,OAAOnU,EAAAnC,OAAOqB,EAAKJ,YACxBI,EAAK6E,YAEPpE,KAAI/F,SAGZ+Z,EAlCA,CAAwBS,EAAA5Z,8FCkQxB6Z,EAjPA,WAGK,SACHC,EAAYC,GAKP3a,KACE4E,mBACmBhF,IAAtB+a,EAAkCA,EAAoB,KAKrD3a,KACE4a,OAAS,EAKX5a,KACE6a,SAAQ,GAKV7a,KACE8a,QAAU,KAKZ9a,KACE+a,QAAU,YAMjBL,EAAAzX,UAAAC,eAAc,uBACA0B,cAAgB,GAAC5E,KAASoa,WAAQpa,KAAU4E,eAM1D8V,EAAAzX,UAAAyE,MAAK,gBACEkT,OAAS,OACTC,SAAQ,QACRC,QAAU,UACVC,QAAU,MAOjBL,EAAAzX,UAAAoD,YAAW,SAAC/D,eACEuY,SAASG,eAAe1Y,IAStCoY,EAAAzX,UAAA6L,QAAO,SAACmM,WACFC,EAAKlb,KAAQ8a,QACVI,GACLD,EAAEC,EAAMC,OAAQD,EAAME,KAAIpb,MAC1Bkb,EAAQA,EAAMG,OASlBX,EAAAzX,UAAAqD,IAAG,SAAChE,EAAK7C,OACDyb,EAAKlb,KAAQ6a,SAASvY,UAC5BgZ,EAAAC,YAAiB3b,IAAVsb,EAAqB,IACxBA,IAAKlb,KAAU+a,UAERG,IAAKlb,KAAU8a,cACnBA,QAAO9a,KAA8B8a,QAAQO,WAC7CP,QAAQU,MAAQ,OAErBN,EAAMG,MAAMG,MAAQN,EAAMM,MAC1BN,EAAMM,MAAMH,MAAQH,EAAMG,OAE5BH,EAAMG,MAAQ,KACdH,EAAMM,MAAKxb,KAAQ+a,aACdA,QAAQM,MAAQH,OAChBH,QAAUG,GAXNA,EAAMC,QAoBjBT,EAAAzX,UAAAsX,OAAM,SAACjY,OACC4Y,EAAKlb,KAAQ6a,SAASvY,UAC5BgZ,EAAAC,YAAiB3b,IAAVsb,EAAqB,IACxBA,IAAKlb,KAAU+a,cACZA,QAAgCG,EAAMM,WAClCT,UAAO/a,KACT+a,QAAQM,MAAQ,OAEdH,IAAKlb,KAAU8a,cACnBA,QAAgCI,EAAMG,WAClCP,UAAO9a,KACT8a,QAAQU,MAAQ,QAGvBN,EAAMG,MAAMG,MAAQN,EAAMM,MAC1BN,EAAMM,MAAMH,MAAQH,EAAMG,mBAEhBR,SAASvY,UACdsY,OACAM,EAAMC,QAMfT,EAAAzX,UAAAmX,SAAQ,uBACMQ,QAMdF,EAAAzX,UAAAwY,QAAO,eAGDP,EAFEQ,EAAI,IAAOC,MAAK3b,KAAM4a,QACxB7L,EAAI,MAEHmM,EAAKlb,KAAQ+a,QAASG,EAAOA,EAAQA,EAAMM,MAC9CE,EAAK3M,KAAOmM,EAAME,YAEbM,GAMThB,EAAAzX,UAAA2Y,UAAS,eAGHV,EAFEW,EAAM,IAAOF,MAAK3b,KAAM4a,QAC1B7L,EAAI,MAEHmM,EAAKlb,KAAQ+a,QAASG,EAAOA,EAAQA,EAAMM,MAC9CK,EAAO9M,KAAOmM,EAAMC,cAEfU,GAMTnB,EAAAzX,UAAAgX,SAAQ,uBACMa,QAAQK,QAMtBT,EAAAzX,UAAA6Y,YAAW,uBACGhB,QAAQM,MAOtBV,EAAAzX,UAAAoX,aAAY,uBACEU,QAAQK,MAMtBV,EAAAzX,UAAAiX,IAAG,eACKgB,EAAKlb,KAAQ8a,2BACPD,SAASK,EAAME,MACvBF,EAAMG,QACRH,EAAMG,MAAMG,MAAQ,WAEjBV,QAAgCI,EAAMG,WACjCP,UAAO9a,KACV+a,QAAU,aAEVH,OACAM,EAAMC,QAOfT,EAAAzX,UAAAmE,QAAO,SAAC9E,EAAK6U,QACN7Q,IAAIhE,QACJuY,SAASvY,GAAK6Y,OAAShE,GAO9BuD,EAAAzX,UAAAoE,IAAG,SAAC/E,EAAK6U,GACPmE,EAAAC,SAASjZ,KAAGtC,KAAS6a,UAAW,QAC1BK,EAAK,CACTE,KAAM9Y,EACN+Y,MAAO,KACPG,MAAKxb,KAAO+a,QACZI,OAAQhE,QAEA4D,aAGHA,QAAQM,MAAQH,EAHNlb,KACV8a,QAAUI,OAIZH,QAAUG,OACVL,SAASvY,GAAO4Y,SACdN,QAQTF,EAAAzX,UAAA8Y,QAAO,SAAC9M,QACDrK,cAAgBqK,GAEzByL,EA/OA,iDCLgBsB,EAAelX,EAAGC,EAAGC,EAAGiX,eAChBrc,IAAlBqc,GACFA,EAAc,GAAKnX,EACnBmX,EAAc,GAAKlX,EACnBkX,EAAc,GAAKjX,EACZiX,IAECnX,EAAGC,EAAGC,YAUFkX,EAAUpX,EAAGC,EAAGC,UACvBF,EAAC,IAASC,EAAC,IAASC,WAQbmX,EAAOjX,UACdgX,EAAUhX,EAAU,GAAIA,EAAU,GAAIA,EAAU,aAQzCkX,EAAQ9Z,UACfA,EAAI+Z,MAAK,KAAMC,IAAIC,iBAOZC,EAAKtX,UACXA,EAAU,IAAMA,EAAU,IAAMA,EAAU,YAQpCuX,EAAiBvX,EAAWlE,OACpC8D,EAAII,EAAU,GACdH,EAAIG,EAAU,GACdF,EAAIE,EAAU,MAEhBlE,EAAS0b,aAAe5X,GAAKA,EAAI9D,EAAS2b,aAAU,OAC/C,MAEHC,EAAY5b,EAAS6b,iBAAiB/X,UACvC8X,GAGIA,EAAUE,WAAW/X,EAAGC,8yBCiJnC+X,EA/LA,SAAAxd,GAGK,SACHyd,EAAYrd,OAAZyC,EACE7C,EAAAQ,KAAAC,KAAA,CACEN,aAAcC,EAAQD,aACtBQ,UAAWP,EAAQO,UACnBG,OAAQV,EAAQU,OAChBU,WAAYpB,EAAQoB,WACpBsB,MAAO1C,EAAQ0C,MACfrB,SAAUrB,EAAQqB,SAClBQ,eAAgB7B,EAAQ6B,eACxBf,MAAOd,EAAQc,MACfD,WAAYb,EAAQa,WACpB8B,IAAK3C,EAAQ2C,IACbrC,wBAAyBN,EAAQM,wBACjC0B,WAAYhC,EAAQgC,0BAOtBS,EAAK6a,yBACH7a,EAAKX,kBAAoBub,EAAQ/Z,UAAUxB,gBAM7CW,EAAK7B,iBAAmBZ,EAAQY,iBAE5BZ,EAAQ8B,kBACVW,EAAKX,gBAAkB9B,EAAQ8B,iBAOjCW,EAAKV,KAAO,KAER/B,EAAQ+B,KACVU,EAAK8a,QAAQvd,EAAQ+B,MACZ/B,EAAQG,KACjBsC,EAAK+a,OAAOxd,EAAQG,KAOtBsC,EAAKgb,iBAAgB,YArDHC,EAAAL,EAAAzd,GA6DpByd,EAAA/Z,UAAAqa,oBAAmB,uBACL/c,kBAQdyc,EAAA/Z,UAAAsa,mBAAkB,kBACTC,OAAOC,eAAczd,MAAOyB,kBAAezB,KAAUyB,gBAAezB,KAClEyB,gBAAgBsE,KAAI/F,MAAAA,KACpByB,iBAUXub,EAAA/Z,UAAAya,QAAO,uBACOhc,MAQdsb,EAAA/Z,UAAA6C,iBAAgB,SAAC6X,OAIXC,EAHEtY,EAAoDqY,EAAM1K,OAC1D4K,EAAMrZ,EAAAC,OAAOa,GACbwY,EAAYxY,EAAKiC,WAEnBuW,GAAavY,EAAA3E,QAAU4I,cACpB4T,iBAAiBS,IAAO,EAC7BD,EAAOG,EAAAnd,QAAcod,eACZH,KAAG7d,KAASod,+BACTA,iBAAiBS,GAC7BD,EACEE,GAAavY,EAAA3E,QAAU+H,MACnBoV,EAAAnd,QAAcqd,cACdH,GAAavY,EAAA3E,QAAU0I,OACvByU,EAAAnd,QAAcsd,iBACdte,GAEIA,MAARge,GAAiB5d,KACdkK,cAAa,IAAKiU,EAAAC,gBAAgBR,EAAMtY,KASjD0X,EAAA/Z,UAAAob,oBAAmB,SAAC9d,QACb8C,UAAUqE,aACVnH,iBAAmBA,OACnBoH,WASPqV,EAAA/Z,UAAAqb,mBAAkB,SAAC7c,EAAiBa,QAC7Bb,gBAAkBA,OAClB4B,UAAU8W,0BACD,IAAH7X,EAAmBtC,KACvBue,OAAOjc,QAEPqF,WASTqV,EAAA/Z,UAAAka,OAAM,SAACrd,OACC4B,EAAO8c,EAAAC,UAAU3e,QAClB4B,KAAOA,OACPwb,QAAQxb,IAQfsb,EAAA/Z,UAAAia,QAAO,SAACxb,QACDA,KAAOA,MACNY,EAAMZ,EAAKgd,KAAI,WACZzB,yBAAwBjd,KAC1Bse,mBAAmBE,EAAAG,oBAAoBjd,EAAI1B,KAAOgB,UAAWsB,QAE7Dic,OAAOjc,IAUhB0a,EAAA/Z,UAAAxB,gBAAe,SAACyD,EAAWD,EAAYlE,KAUvCic,EAAA/Z,UAAA2b,QAAO,SAAC9Z,EAAGC,EAAGC,OACNmB,EAAeC,EAAAkB,UAAUxC,EAAGC,EAAGC,QAC5B3B,UAAUgD,YAAYF,IAAYnG,KACpCqD,UAAUiD,IAAIH,IAGzB6W,EA7LA,CAAsBmB,EAAAvd,iFC7BtBie,EAsBE,CAhBAb,cAAa,gBAQbE,YAAW,cAOXD,cAAa,wtBCafa,EAAA,SAAAvf,GAGK,SACHwf,EAAYpf,OAAZyC,EACE7C,EAAAQ,KAAAC,KAAA,CACEN,aAAcC,EAAQD,aACtBO,wBAAyBN,EAAQM,wBACjCc,WAAYpB,EAAQoB,WACpBsB,MAAO1C,EAAQ0C,MACf5B,MAAOd,EAAQc,cAOjB2B,EAAK4c,aAA6Bpf,IAAnBD,EAAQU,QAAuBV,EAAQU,OAMtD+B,EAAK6c,qBACwBrf,IAA3BD,EAAQ6B,eAA+B7B,EAAQ6B,eAAiB,EAMlEY,EAAKpB,cAAgCpB,IAArBD,EAAQqB,SAAyBrB,EAAQqB,SAAW,SAG9DA,EAAWrB,EAAQqB,gBACrBA,GACFke,EAAAC,OAAOne,EAASkO,YAAYlO,EAAS0b,cAHzB,CAAI,IAAK,MAUvBta,EAAKiB,UAAS,IAAOsB,EAAA/D,QAAUjB,EAAQO,WAAa,GAMpDkC,EAAKgd,QAAO,CAAI,EAAG,GAMnBhd,EAAKgZ,KAAOzb,EAAQ2C,KAAG,GAMvBF,EAAKsD,YAAW,CAAIlF,WAAYb,EAAQa,YASxC4B,EAAKT,WAAahC,EAAQgC,WAAahC,EAAQgC,WAAa,WArEvC0d,EAAAN,EAAAxf,GA2EvBwf,EAAA9b,UAAAC,eAAc,uBACAG,UAAUH,kBAOxB6b,EAAA9b,UAAAK,YAAW,SAACvC,EAAYwC,OAChBF,EAASrD,KAAQyD,0BAA0B1C,GAC7CsC,GACFA,EAAUC,YAAYC,IAa1Bwb,EAAA9b,UAAAqc,kBAAiB,SAACve,EAAY+D,EAAG8X,EAAW2C,OACpClc,EAASrD,KAAQyD,0BAA0B1C,OAC5CsC,EAAS,OACL,UAILiC,EAAMa,EAAcqZ,EADpBC,GAAU,EAEL1a,EAAI6X,EAAUvO,KAAMtJ,GAAK6X,EAAUtO,OAAQvJ,EAAC,IAAA,IAC1CC,EAAI4X,EAAUpO,KAAMxJ,GAAK4X,EAAUnO,OAAQzJ,EAClDmB,EAAeC,EAAAkB,UAAUxC,EAAGC,EAAGC,GAC/Bwa,GAAS,EACLnc,EAAUgD,YAAYF,KAIxBqZ,GAHAla,EAAqDjC,EAAUiD,IAC7DH,IAEYoB,aAAehC,EAAA3E,QAAU0I,UAErCkW,GAA4B,IAAnBD,EAASja,IAGjBka,IACHC,GAAU,UAITA,GAOTV,EAAA9b,UAAAW,uBAAsB,SAAC7C,UACd,GAQTge,EAAA9b,UAAAgB,OAAM,uBACQmX,MAQd2D,EAAA9b,UAAAsb,OAAM,SAACjc,QACI8Y,OAAS9Y,SACX8Y,KAAO9Y,OACPqF,YAQToX,EAAA9b,UAAAmB,UAAS,SAACrD,eACIie,SAMdD,EAAA9b,UAAAyc,eAAc,uBACA1e,SAAS0e,kBAYvBX,EAAA9b,UAAA+C,QAAO,SAAClB,EAAGC,EAAGC,EAAGC,EAAYlE,UACpByD,EAAAiG,YAQTsU,EAAA9b,UAAA0c,YAAW,uBACG3e,UAOd+d,EAAA9b,UAAAoB,yBAAwB,SAACtD,eACbC,cAGIA,SAFLC,EAAAyD,iBAAyB3D,IAWpCge,EAAA9b,UAAAQ,0BAAyB,SAAC1C,UACxBua,EAAAC,OACEzX,EAAAC,WAAU/D,KAAM6D,gBAAiB9C,GACjC,SAEUsC,WAUd0b,EAAA9b,UAAA2D,kBAAiB,SAAC3B,eACJga,iBASdF,EAAA9b,UAAA2c,iBAAgB,SAAC9a,EAAGG,EAAYlE,OACxBC,EAAQhB,KAAQqE,yBAAyBtD,GACzCS,EAAcxB,KAAQ4G,kBAAkB3B,GACxC1D,EAAW2d,EAAAC,OAAOne,EAASkO,YAAYpK,GAAC9E,KAAQof,gBAChC,GAAlB5d,EACKD,EAEA2d,EAAA9H,MAAU7V,EAAUC,EAAcxB,KAAOof,UAapDL,EAAA9b,UAAAmC,+BAA8B,SAACF,EAAW2a,OAClC9e,OACenB,IAAnBigB,EAA+BA,EAAc7f,KAAQ6D,gBACjD7C,EAAQhB,KAAQqE,yBAAyBtD,eACtC+e,YAAc/e,EAAW2S,aAChCxO,EAAYjE,EAAAR,MAAMO,EAAUkE,EAAWnE,IAElCqF,EAAA2Z,iBAAiB7a,EAAWlE,GAAYkE,EAAY,MAO7D6Z,EAAA9b,UAAAyE,MAAK,gBACErE,UAAUqE,SAGjBqX,EAAA9b,UAAA+c,QAAO,gBACAtY,QACLnI,EAAA0D,UAAM+c,QAAOjgB,KAAAC,OAQf+e,EAAA9b,UAAAgd,gBAAe,SAACC,EAAWnf,OACnBsC,EAASrD,KAAQyD,0BAA0B1C,GAC7Cmf,EAAY7c,EAAUuB,gBACxBvB,EAAUuB,cAAgBsb,IAY9BnB,EAAA9b,UAAA2b,QAAO,SAAC9Z,EAAGC,EAAGC,EAAGjE,KACnBge,EA5SA,CAAyBoB,EAAAvf,SAmTzBwf,EAAA,SAAA7gB,GAIK,SACH6e,EAAYR,EAAMtY,OAAlBlD,EACE7C,EAAAQ,KAAAC,KAAM4d,IAAI5d,YAOVoC,EAAKkD,KAAOA,WAbqB+Z,EAAAjB,EAAA7e,GAerC6e,EAfA,CAAqCiC,EAAAzf,SAiBrC0f,EAAexB,iSCvVCyB,EAAiBxf,OAC3BC,EAAWD,EAAWyf,4BACrBxf,IACHA,WAsIFD,EACA0f,EACAC,EACAC,mBApG8Bxf,EAAQsf,EAAaC,EAAcC,OAC3DhK,OAAwB/W,IAAf+gB,EAA2BA,EAAaC,EAAAhgB,QAAOigB,SAExDC,EAAcC,EAAsB5f,EAAQsf,EAAaC,cAEpDM,EAAApgB,QAAQ,CACjBO,OAAQA,EACR8f,OAAQrU,EAAAsU,UAAU/f,EAAQwV,GAC1BmK,YAAaA,EACbvf,SAAUmf,IA8FLS,CADQC,EAAqBrgB,GACL0f,EAAaC,EAAcC,GA5I7CU,CAAoBtgB,GAC/BA,EAAWugB,mBAAmBtgB,IAEzBA,WASOugB,EAAMvgB,EAAUkE,EAAWnE,OACnC+D,EAAII,EAAU,GACd4O,EAAS9S,EAASwgB,mBAAmBtc,GACrCuc,EAAmBL,EAAqBrgB,MACzC6L,EAAA0J,mBAAmBmL,EAAkB3N,UAQjC5O,MAPDwc,EAAa9U,EAAAoE,SAASyQ,GACtBE,EAAa3P,KAAKE,MACrBuP,EAAiB,GAAK3N,EAAO,IAAM4N,UAEtC5N,EAAO,IAAM4N,EAAaC,EACnB3gB,EAAS4gB,yBAAyB9N,EAAQhP,YA8CrC+c,EAAUpiB,OAClBqiB,EAAariB,GAAW,GAExB0B,EAAS2gB,EAAW3gB,QAAU2C,EAAAwC,IAAa,aAAcmG,YAEzDsV,EAAW,CACf5gB,OAAQA,EACRG,QAASwgB,EAAWxgB,QACpBC,SAAUugB,EAAWvgB,SACrBuf,YAAaC,EACX5f,EACA2gB,EAAW1hB,QACX0hB,EAAWvgB,SACXugB,EAAWzgB,2BAGJ2f,EAAApgB,QAASmhB,GAYnB,SACMhB,EACP5f,EACAsf,EACAC,EACAsB,WAEM5hB,OAA0BR,IAAhB6gB,EAA4BA,EAAcwB,EAAAC,iBAEpD9S,EAASxC,EAAA8K,UAAUvW,GACnBgO,EAAQvC,EAAAoE,SAAS7P,GAEjBI,EAAW2d,EAAAC,YACEvf,IAAjB8gB,EAA6BA,EAAeuB,EAAAE,mBAExC9gB,EACJ2gB,EAAoB,EAChBA,EACAhQ,KAAKC,IAAI9C,EAAQ5N,EAAS,GAAI6N,EAAS7N,EAAS,IAEhDoM,EAASvN,EAAU,EACnB0gB,EAAW,IAAOnF,MAAMhO,GACrB7I,EAAI,EAAGA,EAAI6I,IAAU7I,EAC5Bgc,EAAYhc,GAAKzD,EAAgB2Q,KAAKoQ,IAAI,EAAGtd,UAExCgc,WA4BOM,EAAqBrgB,OAE/BI,GADJJ,EAAa+C,EAAAwC,IAAcvF,IACH0L,gBACnBtL,EAAM,KACHkhB,EACH,IAAMve,EAAAwe,gBAAgBC,EAAA3hB,QAAM4hB,SAAYzhB,EAAWqV,mBACtDjV,EAASyL,EAAA6V,gBAAgBJ,GAAOA,EAAMA,EAAMA,UAEvClhB,mLCpKHuhB,EAAY,CAAI,EAAG,EAAG,GAuoB5BC,EAhmBA,WAGK,SACHC,EAAYjjB,OAwBNkjB,KApBD7iB,KACEsB,aAA8B1B,IAApBD,EAAQ2B,QAAwB3B,EAAQ2B,QAAU,EAK9DtB,KACE8iB,aAAenjB,EAAQmhB,YAC5BxF,EAAAC,OACEwH,EAAAC,SAAQhjB,KACD8iB,cAAY,SACPlQ,EAAGC,UACJA,EAAID,KAEb,GAEF,KAKGjT,EAAQsjB,QAAO,IAAA,IACTlU,EAAI,EAAGmU,EAAEljB,KAAQ8iB,aAAanV,OAAS,EAAGoB,EAAImU,IAAMnU,KACtD8T,WAGMC,aAAa/T,GAAC/O,KAAS8iB,aAAa/T,EAAI,KAAO8T,EAAU,CAChEA,OAAajjB,cAHfijB,EAAU7iB,KAAQ8iB,aAAa/T,GAAC/O,KAAS8iB,aAAa/T,EAAI,GAa7D/O,KACEmjB,YAAcN,EAKhB7iB,KACEI,QAAOJ,KAAQ8iB,aAAanV,OAAS,EAKvC3N,KACEojB,aAA6BxjB,IAAnBD,EAAQshB,OAAuBthB,EAAQshB,OAAS,KAK5DjhB,KACEqjB,SAAW,UACQzjB,IAApBD,EAAQsjB,eACLI,SAAW1jB,EAAQsjB,QACxB3H,EAAAC,OAAMvb,KAAMqjB,SAAS1V,QAAM3N,KAAS8iB,aAAanV,OAAQ,SAGrDxM,EAASxB,EAAQwB,YAERvB,IAAXuB,GAAoBnB,KAAUojB,SAAOpjB,KAAUqjB,WAAQrjB,KACpDojB,QAAUxW,EAAAwE,WAAWjQ,IAG5Bma,EAAAC,QAAMvb,KACGojB,SAAOpjB,KAASqjB,UAAQrjB,KAAWojB,UAAOpjB,KAAUqjB,SAC3D,IAMCrjB,KACEsjB,WAAa,UACQ1jB,IAAtBD,EAAQ4jB,iBACLD,WAAa3jB,EAAQ4jB,UAC1BjI,EAAAC,OAAMvb,KAAMsjB,WAAW3V,QAAM3N,KAAS8iB,aAAanV,OAAQ,KAM1D3N,KACEwjB,eACkB5jB,IAArBD,EAAQ4B,SACJ5B,EAAQ4B,SAAQvB,KACVsjB,WAEN,KADArB,EAAAE,kBAEN7G,EAAAC,QAAMvb,KACGwjB,WAASxjB,KAASsjB,YAAUtjB,KAC3BwjB,YAASxjB,KAAUsjB,WAC3B,IAMCtjB,KACEyjB,aAAqB7jB,IAAXuB,EAAuBA,EAAS,KAK5CnB,KACE0jB,gBAAkB,KAKpB1jB,KACE2jB,SAAQ,CAAI,EAAG,GAKjB3jB,KACE4jB,WAAU,CAAI,EAAG,EAAG,EAAG,QAENhkB,IAAlBD,EAAQkkB,MAAmB7jB,KACxB0jB,gBAAkB/jB,EAAQkkB,MAAMvH,KAAG,SAAWrN,EAAMnK,OACjD8X,EAAS,IAAOkH,EAAAljB,QACpBoR,KAAKQ,IAAI,EAAGvD,EAAK,IACjB+C,KAAKC,IAAIhD,EAAK,GAAK,GAAG,GACtB+C,KAAKQ,IAAI,EAAGvD,EAAK,IACjB+C,KAAKC,IAAIhD,EAAK,GAAK,GAAG,OAEpB9N,EAAM,KACF4iB,EAAmB/jB,KAAQmO,0BAA0BhN,EAAQ2D,GACnE8X,EAAUvO,KAAO2D,KAAKC,IAAI8R,EAAoB1V,KAAMuO,EAAUvO,MAC9DuO,EAAUtO,KAAO0D,KAAKQ,IAAIuR,EAAoBzV,KAAMsO,EAAUtO,MAC9DsO,EAAUpO,KAAOwD,KAAKC,IAAI8R,EAAoBvV,KAAMoO,EAAUpO,MAC9DoO,EAAUnO,KAAOuD,KAAKQ,IAAIuR,EAAoBtV,KAAMmO,EAAUnO,aAEzDmO,UAEAzb,GAAMnB,KACVgkB,qBAAqB7iB,UAY9ByhB,EAAA3f,UAAAghB,iBAAgB,SAAC9iB,EAAQ+iB,EAAM3E,WACvB3C,EAAS5c,KAAQmO,0BAA0BhN,EAAQ+iB,GAChDnV,EAAI6N,EAAUvO,KAAM6U,EAAKtG,EAAUtO,KAAMS,GAAKmU,IAAMnU,EAAC,IAAA,IACnDoV,EAAIvH,EAAUpO,KAAM4V,EAAKxH,EAAUnO,KAAM0V,GAAKC,IAAMD,EAC3D5E,EAAQ,CAAE2E,EAAMnV,EAAGoV,KAYzBvB,EAAA3f,UAAAohB,gCAA+B,SAC7Bnf,EACAqa,EACA+E,EACAC,OAEI3H,EAAW7X,EAAGC,EACdwf,EAAkB,KAClB1f,EAAII,EAAU,GAAK,MACE,SAAhBie,aACPpe,EAAIG,EAAU,GACdF,EAAIE,EAAU,IAEdsf,EAAexkB,KAAQuM,mBAAmBrH,EAAWqf,GAEhDzf,GAAC9E,KAASsB,SAAO,IACG,SAAhB6hB,aACPpe,EAAIiN,KAAKyS,MAAM1f,EAAI,GACnBC,EAAIgN,KAAKyS,MAAMzf,EAAI,GACnB4X,EAAYkH,EAAArB,eAAwB1d,EAAGA,EAAGC,EAAGA,EAAGsf,IAEhD1H,EAAS5c,KAAQmO,0BACfqW,EACA1f,EACAwf,GAGA/E,EAASza,EAAG8X,GAAS,OAChB,IAEP9X,SAEG,GAQT8d,EAAA3f,UAAAwJ,UAAS,uBACKgX,SAQdb,EAAA3f,UAAA0Z,WAAU,uBACIvc,SAQdwiB,EAAA3f,UAAAyZ,WAAU,uBACIpb,SASdshB,EAAA3f,UAAAyhB,UAAS,SAAC5f,eACCse,QAAOpjB,KACFojB,aAEAC,SAASve,IAUzB8d,EAAA3f,UAAAgK,cAAa,SAACnI,eACAge,aAAahe,IAQ3B8d,EAAA3f,UAAAyc,eAAc,uBACAoD,cASdF,EAAA3f,UAAA0hB,2BAA0B,SAACzf,EAAWof,EAAeC,MAC/Crf,EAAU,GAAClF,KAASI,QAAO,IACJ,SAAhB+iB,YAAiB,KAClB9U,EAAsB,EAAfnJ,EAAU,GACjBsJ,EAAsB,EAAftJ,EAAU,UAChB4e,EAAArB,eACLpU,EACAA,EAAO,EACPG,EACAA,EAAO,EACP8V,OAGEE,EAAexkB,KAAQuM,mBAC3BrH,EACAqf,GAAUvkB,KAAS4jB,wBAETzV,0BACVqW,EACAtf,EAAU,GAAK,EACfof,UAGG,MAST1B,EAAA3f,UAAA2hB,6BAA4B,SAAC1f,EAAWJ,EAAGwf,MACrCxf,EAAC9E,KAAQI,SAAW0E,EAAC9E,KAAQsB,QAAO,OAC/B,SAGHujB,EAAa3f,EAAU,GACvB4f,EAAa5f,EAAU,GACvB6f,EAAa7f,EAAU,MAEzBJ,IAAM+f,EAAU,OACXf,EAAArB,eACLqC,EACAC,EACAD,EACAC,EACAT,WAIKnB,YAAW,KACZ6B,EAAShT,KAAKoQ,IAAGpiB,KAAMmjB,YAAare,EAAI+f,GACxCxW,EAAO2D,KAAKyS,MAAMK,EAAaE,GAC/BxW,EAAOwD,KAAKyS,MAAMM,EAAaC,MACjClgB,EAAI+f,EAAU,OACTf,EAAArB,eAAwBpU,EAAMA,EAAMG,EAAMA,EAAM8V,OAGnDhW,EAAO0D,KAAKyS,MAAMO,GAAUF,EAAa,IAAM,EAC/CrW,EAAOuD,KAAKyS,MAAMO,GAAUD,EAAa,IAAM,SAC9CjB,EAAArB,eAAwBpU,EAAMC,EAAME,EAAMC,EAAM6V,OAGnDE,EAAexkB,KAAQuM,mBAAmBrH,EAASlF,KAAO4jB,wBACpDzV,0BAA0BqW,EAAiB1f,EAAGwf,IAU5D1B,EAAA3f,UAAAgiB,mBAAkB,SAACngB,EAAG8X,EAAW2H,OACzBtD,EAAMjhB,KAAQ0kB,UAAU5f,GACxBogB,EAAUllB,KAAQiN,cAAcnI,GAChCvD,EAAW2d,EAAAC,OAAMnf,KAAMkP,YAAYpK,GAAC9E,KAAQ2jB,UAC5CtV,EAAO4S,EAAO,GAAKrE,EAAUvO,KAAO9M,EAAS,GAAK2jB,EAClD5W,EAAO2S,EAAO,IAAMrE,EAAUtO,KAAO,GAAK/M,EAAS,GAAK2jB,EACxD1W,EAAOyS,EAAO,GAAKrE,EAAUpO,KAAOjN,EAAS,GAAK2jB,EAClDzW,EAAOwS,EAAO,IAAMrE,EAAUnO,KAAO,GAAKlN,EAAS,GAAK2jB,SACvDtY,EAAA6V,eAAepU,EAAMG,EAAMF,EAAMG,EAAM8V,IAUhD3B,EAAA3f,UAAAkL,0BAAyB,SAAChN,EAAQ2D,EAAGwf,OAC7Bpf,EAAYwd,OACbyC,uBAAuBhkB,EAAO,GAAIA,EAAO,GAAI2D,GAAG,EAAOI,OACtDmJ,EAAOnJ,EAAU,GACjBsJ,EAAOtJ,EAAU,eAClBigB,uBAAuBhkB,EAAO,GAAIA,EAAO,GAAI2D,GAAG,EAAMI,GACpD4e,EAAArB,eACLpU,EACAnJ,EAAU,GACVsJ,EACAtJ,EAAU,GACVof,IAQJ1B,EAAA3f,UAAAue,mBAAkB,SAACtc,OACX+b,EAAMjhB,KAAQ0kB,UAAUxf,EAAU,IAClCggB,EAAUllB,KAAQiN,cAAc/H,EAAU,IAC1C3D,EAAW2d,EAAAC,OAAMnf,KAAMkP,YAAYhK,EAAU,IAAClF,KAAS2jB,iBAE3D1C,EAAO,IAAM/b,EAAU,GAAK,IAAO3D,EAAS,GAAK2jB,EACjDjE,EAAO,IAAM/b,EAAU,GAAK,IAAO3D,EAAS,GAAK2jB,IAYrDtC,EAAA3f,UAAAsJ,mBAAkB,SAACrH,EAAWqf,OACtBtD,EAAMjhB,KAAQ0kB,UAAUxf,EAAU,IAClCggB,EAAUllB,KAAQiN,cAAc/H,EAAU,IAC1C3D,EAAW2d,EAAAC,OAAMnf,KAAMkP,YAAYhK,EAAU,IAAClF,KAAS2jB,UACvDtV,EAAO4S,EAAO,GAAK/b,EAAU,GAAK3D,EAAS,GAAK2jB,EAChD1W,EAAOyS,EAAO,IAAM/b,EAAU,GAAK,GAAK3D,EAAS,GAAK2jB,EACtD5W,EAAOD,EAAO9M,EAAS,GAAK2jB,EAC5BzW,EAAOD,EAAOjN,EAAS,GAAK2jB,SAC3BtY,EAAA6V,eAAepU,EAAMG,EAAMF,EAAMG,EAAM8V,IAchD3B,EAAA3f,UAAAmiB,kCAAiC,SAACC,EAAYH,EAAYjJ,eAC5CqJ,gCACVD,EAAW,GACXA,EAAW,GACXH,GACA,EACAjJ,IAiBJ2G,EAAA3f,UAAAqiB,gCAA+B,SAC7BvgB,EACAC,EACAkgB,EACAK,EACAtJ,OAEMnX,EAAC9E,KAAQ4N,kBAAkBsX,GAC3B9N,EAAQ8N,EAAUllB,KAAQiN,cAAcnI,GACxCmc,EAAMjhB,KAAQ0kB,UAAU5f,GACxBvD,EAAW2d,EAAAC,OAAMnf,KAAMkP,YAAYpK,GAAC9E,KAAQ2jB,UAE5C6B,EAAUD,EAA4B,GAAM,EAC5CE,EAAUF,EAA4B,GAAM,EAC5CG,EAAc1T,KAAKyS,OAAO1f,EAAIkc,EAAO,IAAMiE,EAAaM,GACxDG,EAAc3T,KAAKyS,OAAOxD,EAAO,GAAKjc,GAAKkgB,EAAaO,GAC1DX,EAAc1N,EAAQsO,EAAenkB,EAAS,GAC9CwjB,EAAc3N,EAAQuO,EAAepkB,EAAS,UAE9CgkB,GACFT,EAAa9S,KAAKE,KAAK4S,GAAc,EACrCC,EAAa/S,KAAKE,KAAK6S,GAAc,IAErCD,EAAa9S,KAAKyS,MAAMK,GACxBC,EAAa/S,KAAKyS,MAAMM,IAGnB3e,EAAAqc,eAAwB3d,EAAGggB,EAAYC,EAAY9I,IAkB5D2G,EAAA3f,UAAAkiB,uBAAsB,SAACpgB,EAAGC,EAAGF,EAAGygB,EAA2BtJ,OACnDgF,EAAMjhB,KAAQ0kB,UAAU5f,GACxBogB,EAAUllB,KAAQiN,cAAcnI,GAChCvD,EAAW2d,EAAAC,OAAMnf,KAAMkP,YAAYpK,GAAC9E,KAAQ2jB,UAE5C6B,EAAUD,EAA4B,GAAM,EAC5CE,EAAUF,EAA4B,GAAM,EAC5CG,EAAc1T,KAAKyS,OAAO1f,EAAIkc,EAAO,IAAMiE,EAAaM,GACxDG,EAAc3T,KAAKyS,OAAOxD,EAAO,GAAKjc,GAAKkgB,EAAaO,GAC1DX,EAAaY,EAAcnkB,EAAS,GACpCwjB,EAAaY,EAAcpkB,EAAS,UAEpCgkB,GACFT,EAAa9S,KAAKE,KAAK4S,GAAc,EACrCC,EAAa/S,KAAKE,KAAK6S,GAAc,IAErCD,EAAa9S,KAAKyS,MAAMK,GACxBC,EAAa/S,KAAKyS,MAAMM,IAGnB3e,EAAAqc,eAAwB3d,EAAGggB,EAAYC,EAAY9I,IAW5D2G,EAAA3f,UAAA2e,yBAAwB,SAACyD,EAAYvgB,EAAGmX,eAC1BkJ,uBACVE,EAAW,GACXA,EAAW,GACXvgB,GACA,EACAmX,IAQJ2G,EAAA3f,UAAA2iB,uBAAsB,SAAC1gB,eACT4d,aAAa5d,EAAU,KAWrC0d,EAAA3f,UAAAiM,YAAW,SAACpK,eACD0e,UAASxjB,KACJwjB,eAEAF,WAAWxe,IAQ3B8d,EAAA3f,UAAA4Z,iBAAgB,SAAC/X,eACL4e,qBAKIA,gBAAgB5e,GALL9E,KACXyjB,QAAOzjB,KACVmO,0BAAyBnO,KAAMyjB,QAAS3e,GAC7C,MAcR8d,EAAA3f,UAAA2K,kBAAiB,SAACsX,EAAYW,OACtB/gB,EAAIie,EAAA+C,kBAAiB9lB,KACpB8iB,aACLoC,EACAW,GAAiB,UAEZ7X,EAAAC,MAAMnJ,EAAC9E,KAAOsB,QAAOtB,KAAOI,UAOrCwiB,EAAA3f,UAAA+gB,qBAAoB,SAAC7iB,WACbwM,EAAM3N,KAAQ8iB,aAAanV,OAC3BoY,EAAc,IAAOpK,MAAMhO,GACxB7I,EAAC9E,KAAQsB,QAASwD,EAAI6I,IAAU7I,EACvCihB,EAAejhB,GAAC9E,KAASmO,0BAA0BhN,EAAQ2D,QAExD4e,gBAAkBqC,GAE3BnD,EA9lBA,wKC7CgBoD,EAAmBC,EAAUjlB,OACrCklB,EAAM,SACNC,EAAM,SACNC,EAAM,SACNC,EAAU,0BAQJnhB,EAAWD,EAAYlE,UAC1BmE,EAGI+gB,EACJ7e,QAAQ8e,EAAQhhB,EAAU,GAAGohB,YAC7Blf,QAAQ+e,EAAQjhB,EAAU,GAAGohB,YAC7Blf,QAAQgf,EAAQlhB,EAAU,GAAGohB,YAC7Blf,QAAQif,GAAU,eACXvhB,EAAII,EAAU,GACdqhB,EAAQvlB,EAAS6b,iBAAiB/X,UACxCwW,EAAAC,OAAOgL,EAAO,KACJA,EAAM7O,YAAcxS,EAAU,GAAK,GACpCohB,mBAZD,YAwBJE,EAAoBC,EAAWzlB,WACvC0lB,EAAMD,EAAU9Y,OAChBgZ,EAAgB,IAAOhL,MAAM+K,GAC1B3X,EAAI,EAAGA,EAAI2X,IAAO3X,EACzB4X,EAAiB5X,GAAKiX,EAAmBS,EAAU1X,GAAI/N,mBAShB2lB,UACT,IAA5BA,EAAiBhZ,OACZgZ,EAAiB,YASdzhB,EAAWD,EAAYlE,MAC1BmE,OAGG0hB,EAAIxgB,EAAAygB,KAAc3hB,GAClB4hB,EAAQ9Y,EAAAiG,OAAO2S,EAAGD,EAAiBhZ,eAClCgZ,EAAiBG,GAAO5hB,EAAWD,EAAYlE,KAxBrDgmB,CAA2BJ,YA4CpBK,EAAUlnB,OAClB4B,EAAI,GACNulB,EAAK,sBAAyBC,KAAKpnB,MACnCmnB,EAAK,KAEDE,EAAgBF,EAAM,GAAGG,WAAW,GACpCC,EAAeJ,EAAM,GAAGG,WAAW,GACrCE,OAAQ,MACPA,EAAWH,EAAeG,GAAYD,IAAgBC,EACzD5lB,EAAKgN,KAAK5O,EAAIsH,QAAQ6f,EAAM,GAAIM,OAAOC,aAAaF,YAE/C5lB,KAETulB,EAAK,kBAAqBC,KAAKpnB,GACtB,SAED2nB,EAAOC,SAAST,EAAM,GAAI,IACvBlY,EAAI2Y,SAAST,EAAM,GAAI,IAAKlY,GAAK0Y,EAAM1Y,IAC9CrN,EAAKgN,KAAK5O,EAAIsH,QAAQ6f,EAAM,GAAIlY,EAAEuX,oBAE7B5kB,SAETA,EAAKgN,KAAK5O,GACH4B","sources":["node_modules/ol/src/source/OSM.js","node_modules/ol/src/source/XYZ.js","node_modules/ol/src/source/TileImage.js","node_modules/ol/src/ImageTile.js","node_modules/ol/src/Tile.js","node_modules/ol/src/reproj/Tile.js","node_modules/ol/src/reproj/common.js","node_modules/ol/src/reproj/Triangulation.js","node_modules/ol/src/reproj.js","node_modules/ol/src/source/common.js","node_modules/ol/src/TileCache.js","node_modules/ol/src/structs/LRUCache.js","node_modules/ol/src/tilecoord.js","node_modules/ol/src/source/UrlTile.js","node_modules/ol/src/source/TileEventType.js","node_modules/ol/src/source/Tile.js","node_modules/ol/src/tilegrid.js","node_modules/ol/src/tilegrid/TileGrid.js","node_modules/ol/src/tileurlfunction.js"],"sourcesContent":["/**\n * @module ol/source/OSM\n */\n\nimport XYZ from './XYZ.js';\n\n/**\n * The attribution containing a link to the OpenStreetMap Copyright and License\n * page.\n * @const\n * @type {string}\n * @api\n */\nexport const ATTRIBUTION =\n  '&#169; ' +\n  '<a href=\"https://www.openstreetmap.org/copyright\" target=\"_blank\">OpenStreetMap</a> ' +\n  'contributors.';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.\n * @property {null|string} [crossOrigin='anonymous'] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {boolean} [imageSmoothing=true] Enable image smoothing.\n * @property {number} [maxZoom=19] Max zoom.\n * @property {boolean} [opaque=true] Whether the layer is opaque.\n * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).\n * Higher values can increase reprojection performance, but decrease precision.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is\n * ```js\n * function(imageTile, src) {\n *   imageTile.getImage().src = src;\n * };\n * ```\n * @property {number} [transition=250] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n * @property {string} [url='https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png'] URL template.\n * Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n */\n\n/**\n * @classdesc\n * Layer source for the OpenStreetMap tile server.\n * @api\n */\nclass OSM extends XYZ {\n  /**\n   * @param {Options} [opt_options] Open Street Map options.\n   */\n  constructor(opt_options) {\n    const options = opt_options || {};\n\n    let attributions;\n    if (options.attributions !== undefined) {\n      attributions = options.attributions;\n    } else {\n      attributions = [ATTRIBUTION];\n    }\n\n    const crossOrigin =\n      options.crossOrigin !== undefined ? options.crossOrigin : 'anonymous';\n\n    const url =\n      options.url !== undefined\n        ? options.url\n        : 'https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png';\n\n    super({\n      attributions: attributions,\n      attributionsCollapsible: false,\n      cacheSize: options.cacheSize,\n      crossOrigin: crossOrigin,\n      imageSmoothing: options.imageSmoothing,\n      maxZoom: options.maxZoom !== undefined ? options.maxZoom : 19,\n      opaque: options.opaque !== undefined ? options.opaque : true,\n      reprojectionErrorThreshold: options.reprojectionErrorThreshold,\n      tileLoadFunction: options.tileLoadFunction,\n      transition: options.transition,\n      url: url,\n      wrapX: options.wrapX,\n    });\n  }\n}\n\nexport default OSM;\n","/**\n * @module ol/source/XYZ\n */\n\nimport TileImage from './TileImage.js';\nimport {createXYZ, extentFromProjection} from '../tilegrid.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {boolean} [imageSmoothing=true] Enable image smoothing.\n * @property {boolean} [opaque=false] Whether the layer is opaque.\n * @property {import(\"../proj.js\").ProjectionLike} [projection='EPSG:3857'] Projection.\n * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).\n * Higher values can increase reprojection performance, but decrease precision.\n * @property {number} [maxZoom=42] Optional max zoom level. Not used if `tileGrid` is provided.\n * @property {number} [minZoom=0] Optional min zoom level. Not used if `tileGrid` is provided.\n * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is\n * ```js\n * function(imageTile, src) {\n *   imageTile.getImage().src = src;\n * };\n * ```\n * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service.\n * For example, if the tile service advertizes 256px by 256px tiles but actually sends 512px\n * by 512px images (for retina/hidpi devices) then `tilePixelRatio`\n * should be set to `2`.\n * @property {number|import(\"../size.js\").Size} [tileSize=[256, 256]] The tile size used by the tile service.\n * Not used if `tileGrid` is provided.\n * @property {import(\"../Tile.js\").UrlFunction} [tileUrlFunction] Optional function to get\n * tile URL given a tile coordinate and the projection.\n * Required if `url` or `urls` are not provided.\n * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`,\n * and `{z}` placeholders. A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`,\n * may be used instead of defining each one separately in the `urls` option.\n * @property {Array<string>} [urls] An array of URL templates.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n * @property {number} [transition=250] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n * @property {number} [zDirection=0] Indicate which resolution should be used\n * by a renderer if the view resolution does not match any resolution of the tile source.\n * If 0, the nearest resolution will be used. If 1, the nearest lower resolution\n * will be used. If -1, the nearest higher resolution will be used.\n */\n\n/**\n * @classdesc\n * Layer source for tile data with URLs in a set XYZ format that are\n * defined in a URL template. By default, this follows the widely-used\n * Google grid where `x` 0 and `y` 0 are in the top left. Grids like\n * TMS where `x` 0 and `y` 0 are in the bottom left can be used by\n * using the `{-y}` placeholder in the URL template, so long as the\n * source does not have a custom tile grid. In this case\n * a `tileUrlFunction` can be used, such as:\n * ```js\n *  tileUrlFunction: function(coordinate) {\n *    return 'http://mapserver.com/' + coordinate[0] + '/' +\n *      coordinate[1] + '/' + (-coordinate[2] - 1) + '.png';\n *  }\n * ```\n * @api\n */\nclass XYZ extends TileImage {\n  /**\n   * @param {Options} [opt_options] XYZ options.\n   */\n  constructor(opt_options) {\n    const options = opt_options || {};\n    const projection =\n      options.projection !== undefined ? options.projection : 'EPSG:3857';\n\n    const tileGrid =\n      options.tileGrid !== undefined\n        ? options.tileGrid\n        : createXYZ({\n            extent: extentFromProjection(projection),\n            maxResolution: options.maxResolution,\n            maxZoom: options.maxZoom,\n            minZoom: options.minZoom,\n            tileSize: options.tileSize,\n          });\n\n    super({\n      attributions: options.attributions,\n      cacheSize: options.cacheSize,\n      crossOrigin: options.crossOrigin,\n      imageSmoothing: options.imageSmoothing,\n      opaque: options.opaque,\n      projection: projection,\n      reprojectionErrorThreshold: options.reprojectionErrorThreshold,\n      tileGrid: tileGrid,\n      tileLoadFunction: options.tileLoadFunction,\n      tilePixelRatio: options.tilePixelRatio,\n      tileUrlFunction: options.tileUrlFunction,\n      url: options.url,\n      urls: options.urls,\n      wrapX: options.wrapX !== undefined ? options.wrapX : true,\n      transition: options.transition,\n      attributionsCollapsible: options.attributionsCollapsible,\n      zDirection: options.zDirection,\n    });\n  }\n}\n\nexport default XYZ;\n","/**\n * @module ol/source/TileImage\n */\nimport EventType from '../events/EventType.js';\nimport ImageTile from '../ImageTile.js';\nimport ReprojTile from '../reproj/Tile.js';\nimport TileCache from '../TileCache.js';\nimport TileState from '../TileState.js';\nimport UrlTile from './UrlTile.js';\nimport {ENABLE_RASTER_REPROJECTION} from '../reproj/common.js';\nimport {IMAGE_SMOOTHING_DISABLED} from './common.js';\nimport {equivalent, get as getProjection} from '../proj.js';\nimport {getKey, getKeyZXY} from '../tilecoord.js';\nimport {getForProjection as getTileGridForProjection} from '../tilegrid.js';\nimport {getUid} from '../util.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {boolean} [imageSmoothing=true] Enable image smoothing.\n * @property {boolean} [opaque=false] Whether the layer is opaque.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection. Default is the view projection.\n * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).\n * Higher values can increase reprojection performance, but decrease precision.\n * @property {import(\"./State.js\").default} [state] Source state.\n * @property {typeof import(\"../ImageTile.js\").default} [tileClass] Class used to instantiate image tiles.\n * Default is {@link module:ol/ImageTile~ImageTile}.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is\n * ```js\n * function(imageTile, src) {\n *   imageTile.getImage().src = src;\n * };\n * ```\n * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service. For example, if the tile\n * service advertizes 256px by 256px tiles but actually sends 512px\n * by 512px images (for retina/hidpi devices) then `tilePixelRatio`\n * should be set to `2`.\n * @property {import(\"../Tile.js\").UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.\n * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.\n * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be\n * used instead of defining each one separately in the `urls` option.\n * @property {Array<string>} [urls] An array of URL templates.\n * @property {boolean} [wrapX] Whether to wrap the world horizontally. The default, is to\n * request out-of-bounds tiles from the server. When set to `false`, only one\n * world will be rendered. When set to `true`, tiles will be requested for one\n * world only, but they will be wrapped horizontally to render multiple worlds.\n * @property {number} [transition] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n * @property {string} [key] Optional tile key for proper cache fetching\n * @property {number} [zDirection=0] Indicate which resolution should be used\n * by a renderer if the view resolution does not match any resolution of the tile source.\n * If 0, the nearest resolution will be used. If 1, the nearest lower resolution\n * will be used. If -1, the nearest higher resolution will be used.\n */\n\n/**\n * @classdesc\n * Base class for sources providing images divided into a tile grid.\n *\n * @fires import(\"./Tile.js\").TileSourceEvent\n * @api\n */\nclass TileImage extends UrlTile {\n  /**\n   * @param {!Options} options Image tile options.\n   */\n  constructor(options) {\n    super({\n      attributions: options.attributions,\n      cacheSize: options.cacheSize,\n      opaque: options.opaque,\n      projection: options.projection,\n      state: options.state,\n      tileGrid: options.tileGrid,\n      tileLoadFunction: options.tileLoadFunction\n        ? options.tileLoadFunction\n        : defaultTileLoadFunction,\n      tilePixelRatio: options.tilePixelRatio,\n      tileUrlFunction: options.tileUrlFunction,\n      url: options.url,\n      urls: options.urls,\n      wrapX: options.wrapX,\n      transition: options.transition,\n      key: options.key,\n      attributionsCollapsible: options.attributionsCollapsible,\n      zDirection: options.zDirection,\n    });\n\n    /**\n     * @protected\n     * @type {?string}\n     */\n    this.crossOrigin =\n      options.crossOrigin !== undefined ? options.crossOrigin : null;\n\n    /**\n     * @protected\n     * @type {typeof ImageTile}\n     */\n    this.tileClass =\n      options.tileClass !== undefined ? options.tileClass : ImageTile;\n\n    /**\n     * @protected\n     * @type {!Object<string, TileCache>}\n     */\n    this.tileCacheForProjection = {};\n\n    /**\n     * @protected\n     * @type {!Object<string, import(\"../tilegrid/TileGrid.js\").default>}\n     */\n    this.tileGridForProjection = {};\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.reprojectionErrorThreshold_ = options.reprojectionErrorThreshold;\n\n    /**\n     * @private\n     * @type {object|undefined}\n     */\n    this.contextOptions_ =\n      options.imageSmoothing === false ? IMAGE_SMOOTHING_DISABLED : undefined;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.renderReprojectionEdges_ = false;\n  }\n\n  /**\n   * @return {boolean} Can expire cache.\n   */\n  canExpireCache() {\n    if (!ENABLE_RASTER_REPROJECTION) {\n      return super.canExpireCache();\n    }\n    if (this.tileCache.canExpireCache()) {\n      return true;\n    } else {\n      for (const key in this.tileCacheForProjection) {\n        if (this.tileCacheForProjection[key].canExpireCache()) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @param {!Object<string, boolean>} usedTiles Used tiles.\n   */\n  expireCache(projection, usedTiles) {\n    if (!ENABLE_RASTER_REPROJECTION) {\n      super.expireCache(projection, usedTiles);\n      return;\n    }\n    const usedTileCache = this.getTileCacheForProjection(projection);\n\n    this.tileCache.expireCache(\n      this.tileCache == usedTileCache ? usedTiles : {}\n    );\n    for (const id in this.tileCacheForProjection) {\n      const tileCache = this.tileCacheForProjection[id];\n      tileCache.expireCache(tileCache == usedTileCache ? usedTiles : {});\n    }\n  }\n\n  /**\n   * @return {Object|undefined} Context options.\n   */\n  getContextOptions() {\n    return this.contextOptions_;\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {number} Gutter.\n   */\n  getGutterForProjection(projection) {\n    if (\n      ENABLE_RASTER_REPROJECTION &&\n      this.getProjection() &&\n      projection &&\n      !equivalent(this.getProjection(), projection)\n    ) {\n      return 0;\n    } else {\n      return this.getGutter();\n    }\n  }\n\n  /**\n   * @return {number} Gutter.\n   */\n  getGutter() {\n    return 0;\n  }\n\n  /**\n   * Return the key to be used for all tiles in the source.\n   * @return {string} The key for all tiles.\n   * @protected\n   */\n  getKey() {\n    return (\n      super.getKey() +\n      (this.contextOptions_ ? '\\n' + JSON.stringify(this.contextOptions_) : '')\n    );\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {boolean} Opaque.\n   */\n  getOpaque(projection) {\n    if (\n      ENABLE_RASTER_REPROJECTION &&\n      this.getProjection() &&\n      projection &&\n      !equivalent(this.getProjection(), projection)\n    ) {\n      return false;\n    } else {\n      return super.getOpaque(projection);\n    }\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n   */\n  getTileGridForProjection(projection) {\n    if (!ENABLE_RASTER_REPROJECTION) {\n      return super.getTileGridForProjection(projection);\n    }\n    const thisProj = this.getProjection();\n    if (this.tileGrid && (!thisProj || equivalent(thisProj, projection))) {\n      return this.tileGrid;\n    } else {\n      const projKey = getUid(projection);\n      if (!(projKey in this.tileGridForProjection)) {\n        this.tileGridForProjection[projKey] = getTileGridForProjection(\n          projection\n        );\n      }\n      return this.tileGridForProjection[projKey];\n    }\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../TileCache.js\").default} Tile cache.\n   */\n  getTileCacheForProjection(projection) {\n    if (!ENABLE_RASTER_REPROJECTION) {\n      return super.getTileCacheForProjection(projection);\n    }\n    const thisProj = this.getProjection();\n    if (!thisProj || equivalent(thisProj, projection)) {\n      return this.tileCache;\n    } else {\n      const projKey = getUid(projection);\n      if (!(projKey in this.tileCacheForProjection)) {\n        this.tileCacheForProjection[projKey] = new TileCache(\n          this.tileCache.highWaterMark\n        );\n      }\n      return this.tileCacheForProjection[projKey];\n    }\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @param {string} key The key set on the tile.\n   * @return {!import(\"../Tile.js\").default} Tile.\n   * @private\n   */\n  createTile_(z, x, y, pixelRatio, projection, key) {\n    const tileCoord = [z, x, y];\n    const urlTileCoord = this.getTileCoordForTileUrlFunction(\n      tileCoord,\n      projection\n    );\n    const tileUrl = urlTileCoord\n      ? this.tileUrlFunction(urlTileCoord, pixelRatio, projection)\n      : undefined;\n    const tile = new this.tileClass(\n      tileCoord,\n      tileUrl !== undefined ? TileState.IDLE : TileState.EMPTY,\n      tileUrl !== undefined ? tileUrl : '',\n      this.crossOrigin,\n      this.tileLoadFunction,\n      this.tileOptions\n    );\n    tile.key = key;\n    tile.addEventListener(EventType.CHANGE, this.handleTileChange.bind(this));\n    return tile;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../Tile.js\").default} Tile.\n   */\n  getTile(z, x, y, pixelRatio, projection) {\n    const sourceProjection = this.getProjection();\n    if (\n      !ENABLE_RASTER_REPROJECTION ||\n      !sourceProjection ||\n      !projection ||\n      equivalent(sourceProjection, projection)\n    ) {\n      return this.getTileInternal(\n        z,\n        x,\n        y,\n        pixelRatio,\n        sourceProjection || projection\n      );\n    } else {\n      const cache = this.getTileCacheForProjection(projection);\n      const tileCoord = [z, x, y];\n      let tile;\n      const tileCoordKey = getKey(tileCoord);\n      if (cache.containsKey(tileCoordKey)) {\n        tile = cache.get(tileCoordKey);\n      }\n      const key = this.getKey();\n      if (tile && tile.key == key) {\n        return tile;\n      } else {\n        const sourceTileGrid = this.getTileGridForProjection(sourceProjection);\n        const targetTileGrid = this.getTileGridForProjection(projection);\n        const wrappedTileCoord = this.getTileCoordForTileUrlFunction(\n          tileCoord,\n          projection\n        );\n        const newTile = new ReprojTile(\n          sourceProjection,\n          sourceTileGrid,\n          projection,\n          targetTileGrid,\n          tileCoord,\n          wrappedTileCoord,\n          this.getTilePixelRatio(pixelRatio),\n          this.getGutter(),\n          function (z, x, y, pixelRatio) {\n            return this.getTileInternal(z, x, y, pixelRatio, sourceProjection);\n          }.bind(this),\n          this.reprojectionErrorThreshold_,\n          this.renderReprojectionEdges_,\n          this.contextOptions_\n        );\n        newTile.key = key;\n\n        if (tile) {\n          newTile.interimTile = tile;\n          newTile.refreshInterimChain();\n          cache.replace(tileCoordKey, newTile);\n        } else {\n          cache.set(tileCoordKey, newTile);\n        }\n        return newTile;\n      }\n    }\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {!import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../Tile.js\").default} Tile.\n   * @protected\n   */\n  getTileInternal(z, x, y, pixelRatio, projection) {\n    let tile = null;\n    const tileCoordKey = getKeyZXY(z, x, y);\n    const key = this.getKey();\n    if (!this.tileCache.containsKey(tileCoordKey)) {\n      tile = this.createTile_(z, x, y, pixelRatio, projection, key);\n      this.tileCache.set(tileCoordKey, tile);\n    } else {\n      tile = this.tileCache.get(tileCoordKey);\n      if (tile.key != key) {\n        // The source's params changed. If the tile has an interim tile and if we\n        // can use it then we use it. Otherwise we create a new tile.  In both\n        // cases we attempt to assign an interim tile to the new tile.\n        const interimTile = tile;\n        tile = this.createTile_(z, x, y, pixelRatio, projection, key);\n\n        //make the new tile the head of the list,\n        if (interimTile.getState() == TileState.IDLE) {\n          //the old tile hasn't begun loading yet, and is now outdated, so we can simply discard it\n          tile.interimTile = interimTile.interimTile;\n        } else {\n          tile.interimTile = interimTile;\n        }\n        tile.refreshInterimChain();\n        this.tileCache.replace(tileCoordKey, tile);\n      }\n    }\n    return tile;\n  }\n\n  /**\n   * Sets whether to render reprojection edges or not (usually for debugging).\n   * @param {boolean} render Render the edges.\n   * @api\n   */\n  setRenderReprojectionEdges(render) {\n    if (\n      !ENABLE_RASTER_REPROJECTION ||\n      this.renderReprojectionEdges_ == render\n    ) {\n      return;\n    }\n    this.renderReprojectionEdges_ = render;\n    for (const id in this.tileCacheForProjection) {\n      this.tileCacheForProjection[id].clear();\n    }\n    this.changed();\n  }\n\n  /**\n   * Sets the tile grid to use when reprojecting the tiles to the given\n   * projection instead of the default tile grid for the projection.\n   *\n   * This can be useful when the default tile grid cannot be created\n   * (e.g. projection has no extent defined) or\n   * for optimization reasons (custom tile size, resolutions, ...).\n   *\n   * @param {import(\"../proj.js\").ProjectionLike} projection Projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} tilegrid Tile grid to use for the projection.\n   * @api\n   */\n  setTileGridForProjection(projection, tilegrid) {\n    if (ENABLE_RASTER_REPROJECTION) {\n      const proj = getProjection(projection);\n      if (proj) {\n        const projKey = getUid(proj);\n        if (!(projKey in this.tileGridForProjection)) {\n          this.tileGridForProjection[projKey] = tilegrid;\n        }\n      }\n    }\n  }\n}\n\n/**\n * @param {ImageTile} imageTile Image tile.\n * @param {string} src Source.\n */\nfunction defaultTileLoadFunction(imageTile, src) {\n  /** @type {HTMLImageElement|HTMLVideoElement} */ (imageTile.getImage()).src = src;\n}\n\nexport default TileImage;\n","/**\n * @module ol/ImageTile\n */\nimport Tile from './Tile.js';\nimport TileState from './TileState.js';\nimport {createCanvasContext2D} from './dom.js';\nimport {listenImage} from './Image.js';\n\nclass ImageTile extends Tile {\n  /**\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"./TileState.js\").default} state State.\n   * @param {string} src Image source URI.\n   * @param {?string} crossOrigin Cross origin.\n   * @param {import(\"./Tile.js\").LoadFunction} tileLoadFunction Tile load function.\n   * @param {import(\"./Tile.js\").Options} [opt_options] Tile options.\n   */\n  constructor(\n    tileCoord,\n    state,\n    src,\n    crossOrigin,\n    tileLoadFunction,\n    opt_options\n  ) {\n    super(tileCoord, state, opt_options);\n\n    /**\n     * @private\n     * @type {?string}\n     */\n    this.crossOrigin_ = crossOrigin;\n\n    /**\n     * Image URI\n     *\n     * @private\n     * @type {string}\n     */\n    this.src_ = src;\n\n    this.key = src;\n\n    /**\n     * @private\n     * @type {HTMLImageElement|HTMLCanvasElement}\n     */\n    this.image_ = new Image();\n    if (crossOrigin !== null) {\n      this.image_.crossOrigin = crossOrigin;\n    }\n\n    /**\n     * @private\n     * @type {?function():void}\n     */\n    this.unlisten_ = null;\n\n    /**\n     * @private\n     * @type {import(\"./Tile.js\").LoadFunction}\n     */\n    this.tileLoadFunction_ = tileLoadFunction;\n  }\n\n  /**\n   * Get the HTML image element for this tile (may be a Canvas, Image, or Video).\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @api\n   */\n  getImage() {\n    return this.image_;\n  }\n\n  /**\n   * Tracks loading or read errors.\n   *\n   * @private\n   */\n  handleImageError_() {\n    this.state = TileState.ERROR;\n    this.unlistenImage_();\n    this.image_ = getBlankImage();\n    this.changed();\n  }\n\n  /**\n   * Tracks successful image load.\n   *\n   * @private\n   */\n  handleImageLoad_() {\n    const image = /** @type {HTMLImageElement} */ (this.image_);\n    if (image.naturalWidth && image.naturalHeight) {\n      this.state = TileState.LOADED;\n    } else {\n      this.state = TileState.EMPTY;\n    }\n    this.unlistenImage_();\n    this.changed();\n  }\n\n  /**\n   * Load not yet loaded URI.\n   * @api\n   */\n  load() {\n    if (this.state == TileState.ERROR) {\n      this.state = TileState.IDLE;\n      this.image_ = new Image();\n      if (this.crossOrigin_ !== null) {\n        this.image_.crossOrigin = this.crossOrigin_;\n      }\n    }\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      this.changed();\n      this.tileLoadFunction_(this, this.src_);\n      this.unlisten_ = listenImage(\n        this.image_,\n        this.handleImageLoad_.bind(this),\n        this.handleImageError_.bind(this)\n      );\n    }\n  }\n\n  /**\n   * Discards event handlers which listen for load completion or errors.\n   *\n   * @private\n   */\n  unlistenImage_() {\n    if (this.unlisten_) {\n      this.unlisten_();\n      this.unlisten_ = null;\n    }\n  }\n}\n\n/**\n * Get a 1-pixel blank image.\n * @return {HTMLCanvasElement} Blank image.\n */\nfunction getBlankImage() {\n  const ctx = createCanvasContext2D(1, 1);\n  ctx.fillStyle = 'rgba(0,0,0,0)';\n  ctx.fillRect(0, 0, 1, 1);\n  return ctx.canvas;\n}\n\nexport default ImageTile;\n","/**\n * @module ol/Tile\n */\nimport EventTarget from './events/Target.js';\nimport EventType from './events/EventType.js';\nimport TileState from './TileState.js';\nimport {abstract} from './util.js';\nimport {easeIn} from './easing.js';\n\n/**\n * A function that takes an {@link module:ol/Tile} for the tile and a\n * `{string}` for the url as arguments. The default is\n * ```js\n * source.setTileLoadFunction(function(tile, src) {\n *   tile.getImage().src = src;\n * });\n * ```\n * For more fine grained control, the load function can use fetch or XMLHttpRequest and involve\n * error handling:\n *\n * ```js\n * import TileState from 'ol/TileState';\n *\n * source.setTileLoadFunction(function(tile, src) {\n *   var xhr = new XMLHttpRequest();\n *   xhr.responseType = 'blob';\n *   xhr.addEventListener('loadend', function (evt) {\n *     var data = this.response;\n *     if (data !== undefined) {\n *       tile.getImage().src = URL.createObjectURL(data);\n *     } else {\n *       tile.setState(TileState.ERROR);\n *     }\n *   });\n *   xhr.addEventListener('error', function () {\n *     tile.setState(TileState.ERROR);\n *   });\n *   xhr.open('GET', src);\n *   xhr.send();\n * });\n * ```\n *\n * @typedef {function(Tile, string): void} LoadFunction\n * @api\n */\n\n/**\n * {@link module:ol/source/Tile~Tile} sources use a function of this type to get\n * the url that provides a tile for a given tile coordinate.\n *\n * This function takes an {@link module:ol/tilecoord~TileCoord} for the tile\n * coordinate, a `{number}` representing the pixel ratio and a\n * {@link module:ol/proj/Projection} for the projection  as arguments\n * and returns a `{string}` representing the tile URL, or undefined if no tile\n * should be requested for the passed tile coordinate.\n *\n * @typedef {function(import(\"./tilecoord.js\").TileCoord, number,\n *           import(\"./proj/Projection.js\").default): (string|undefined)} UrlFunction\n * @api\n */\n\n/**\n * @typedef {Object} Options\n * @property {number} [transition=250] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @api\n */\n\n/**\n * @classdesc\n * Base class for tiles.\n *\n * @abstract\n */\nclass Tile extends EventTarget {\n  /**\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"./TileState.js\").default} state State.\n   * @param {Options} [opt_options] Tile options.\n   */\n  constructor(tileCoord, state, opt_options) {\n    super();\n\n    const options = opt_options ? opt_options : {};\n\n    /**\n     * @type {import(\"./tilecoord.js\").TileCoord}\n     */\n    this.tileCoord = tileCoord;\n\n    /**\n     * @protected\n     * @type {import(\"./TileState.js\").default}\n     */\n    this.state = state;\n\n    /**\n     * An \"interim\" tile for this tile. The interim tile may be used while this\n     * one is loading, for \"smooth\" transitions when changing params/dimensions\n     * on the source.\n     * @type {Tile}\n     */\n    this.interimTile = null;\n\n    /**\n     * The tile is available at the highest possible resolution. Subclasses can\n     * set this to `false` initially. Tile load listeners will not be\n     * unregistered before this is set to `true` and a `#changed()` is called.\n     * @type {boolean}\n     */\n    this.hifi = true;\n\n    /**\n     * A key assigned to the tile. This is used by the tile source to determine\n     * if this tile can effectively be used, or if a new tile should be created\n     * and this one be used as an interim tile for this new tile.\n     * @type {string}\n     */\n    this.key = '';\n\n    /**\n     * The duration for the opacity transition.\n     * @type {number}\n     */\n    this.transition_ =\n      options.transition === undefined ? 250 : options.transition;\n\n    /**\n     * Lookup of start times for rendering transitions.  If the start time is\n     * equal to -1, the transition is complete.\n     * @type {Object<string, number>}\n     */\n    this.transitionStarts_ = {};\n  }\n\n  /**\n   * @protected\n   */\n  changed() {\n    this.dispatchEvent(EventType.CHANGE);\n  }\n\n  /**\n   * Called by the tile cache when the tile is removed from the cache due to expiry\n   */\n  release() {}\n\n  /**\n   * @return {string} Key.\n   */\n  getKey() {\n    return this.key + '/' + this.tileCoord;\n  }\n\n  /**\n   * Get the interim tile most suitable for rendering using the chain of interim\n   * tiles. This corresponds to the  most recent tile that has been loaded, if no\n   * such tile exists, the original tile is returned.\n   * @return {!Tile} Best tile for rendering.\n   */\n  getInterimTile() {\n    if (!this.interimTile) {\n      //empty chain\n      return this;\n    }\n    let tile = this.interimTile;\n\n    // find the first loaded tile and return it. Since the chain is sorted in\n    // decreasing order of creation time, there is no need to search the remainder\n    // of the list (all those tiles correspond to older requests and will be\n    // cleaned up by refreshInterimChain)\n    do {\n      if (tile.getState() == TileState.LOADED) {\n        // Show tile immediately instead of fading it in after loading, because\n        // the interim tile is in place already\n        this.transition_ = 0;\n        return tile;\n      }\n      tile = tile.interimTile;\n    } while (tile);\n\n    // we can not find a better tile\n    return this;\n  }\n\n  /**\n   * Goes through the chain of interim tiles and discards sections of the chain\n   * that are no longer relevant.\n   */\n  refreshInterimChain() {\n    if (!this.interimTile) {\n      return;\n    }\n\n    let tile = this.interimTile;\n    let prev = /** @type {Tile} */ (this);\n\n    do {\n      if (tile.getState() == TileState.LOADED) {\n        //we have a loaded tile, we can discard the rest of the list\n        //we would could abort any LOADING tile request\n        //older than this tile (i.e. any LOADING tile following this entry in the chain)\n        tile.interimTile = null;\n        break;\n      } else if (tile.getState() == TileState.LOADING) {\n        //keep this LOADING tile any loaded tiles later in the chain are\n        //older than this tile, so we're still interested in the request\n        prev = tile;\n      } else if (tile.getState() == TileState.IDLE) {\n        //the head of the list is the most current tile, we don't need\n        //to start any other requests for this chain\n        prev.interimTile = tile.interimTile;\n      } else {\n        prev = tile;\n      }\n      tile = prev.interimTile;\n    } while (tile);\n  }\n\n  /**\n   * Get the tile coordinate for this tile.\n   * @return {import(\"./tilecoord.js\").TileCoord} The tile coordinate.\n   * @api\n   */\n  getTileCoord() {\n    return this.tileCoord;\n  }\n\n  /**\n   * @return {import(\"./TileState.js\").default} State.\n   */\n  getState() {\n    return this.state;\n  }\n\n  /**\n   * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,\n   * it is important to set the state correctly to {@link module:ol/TileState~ERROR}\n   * when the tile cannot be loaded. Otherwise the tile cannot be removed from\n   * the tile queue and will block other requests.\n   * @param {import(\"./TileState.js\").default} state State.\n   * @api\n   */\n  setState(state) {\n    if (this.state !== TileState.ERROR && this.state > state) {\n      throw new Error('Tile load sequence violation');\n    }\n    this.state = state;\n    this.changed();\n  }\n\n  /**\n   * Load the image or retry if loading previously failed.\n   * Loading is taken care of by the tile queue, and calling this method is\n   * only needed for preloading or for reloading in case of an error.\n   * @abstract\n   * @api\n   */\n  load() {\n    abstract();\n  }\n\n  /**\n   * Get the alpha value for rendering.\n   * @param {string} id An id for the renderer.\n   * @param {number} time The render frame time.\n   * @return {number} A number between 0 and 1.\n   */\n  getAlpha(id, time) {\n    if (!this.transition_) {\n      return 1;\n    }\n\n    let start = this.transitionStarts_[id];\n    if (!start) {\n      start = time;\n      this.transitionStarts_[id] = start;\n    } else if (start === -1) {\n      return 1;\n    }\n\n    const delta = time - start + 1000 / 60; // avoid rendering at 0\n    if (delta >= this.transition_) {\n      return 1;\n    }\n    return easeIn(delta / this.transition_);\n  }\n\n  /**\n   * Determine if a tile is in an alpha transition.  A tile is considered in\n   * transition if tile.getAlpha() has not yet been called or has been called\n   * and returned 1.\n   * @param {string} id An id for the renderer.\n   * @return {boolean} The tile is in transition.\n   */\n  inTransition(id) {\n    if (!this.transition_) {\n      return false;\n    }\n    return this.transitionStarts_[id] !== -1;\n  }\n\n  /**\n   * Mark a transition as complete.\n   * @param {string} id An id for the renderer.\n   */\n  endTransition(id) {\n    if (this.transition_) {\n      this.transitionStarts_[id] = -1;\n    }\n  }\n}\n\nexport default Tile;\n","/**\n * @module ol/reproj/Tile\n */\nimport {ERROR_THRESHOLD} from './common.js';\n\nimport EventType from '../events/EventType.js';\nimport Tile from '../Tile.js';\nimport TileState from '../TileState.js';\nimport Triangulation from './Triangulation.js';\nimport {\n  calculateSourceExtentResolution,\n  render as renderReprojected,\n} from '../reproj.js';\nimport {clamp} from '../math.js';\nimport {getArea, getIntersection} from '../extent.js';\nimport {listen, unlistenByKey} from '../events.js';\n\n/**\n * @typedef {function(number, number, number, number) : import(\"../Tile.js\").default} FunctionType\n */\n\n/**\n * @classdesc\n * Class encapsulating single reprojected tile.\n * See {@link module:ol/source/TileImage~TileImage}.\n *\n */\nclass ReprojTile extends Tile {\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\n   * @param {import(\"../tilecoord.js\").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {number} gutter Gutter of the source tiles.\n   * @param {FunctionType} getTileFunction\n   *     Function returning source tiles (z, x, y, pixelRatio).\n   * @param {number} [opt_errorThreshold] Acceptable reprojection error (in px).\n   * @param {boolean} [opt_renderEdges] Render reprojection edges.\n   * @param {object} [opt_contextOptions] Properties to set on the canvas context.\n   */\n  constructor(\n    sourceProj,\n    sourceTileGrid,\n    targetProj,\n    targetTileGrid,\n    tileCoord,\n    wrappedTileCoord,\n    pixelRatio,\n    gutter,\n    getTileFunction,\n    opt_errorThreshold,\n    opt_renderEdges,\n    opt_contextOptions\n  ) {\n    super(tileCoord, TileState.IDLE);\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.renderEdges_ = opt_renderEdges !== undefined ? opt_renderEdges : false;\n\n    /**\n     * @private\n     * @type {object}\n     */\n    this.contextOptions_ = opt_contextOptions;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = pixelRatio;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.gutter_ = gutter;\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.canvas_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.sourceTileGrid_ = sourceTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.targetTileGrid_ = targetTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilecoord.js\").TileCoord}\n     */\n    this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;\n\n    /**\n     * @private\n     * @type {!Array<import(\"../Tile.js\").default>}\n     */\n    this.sourceTiles_ = [];\n\n    /**\n     * @private\n     * @type {?Array<import(\"../events.js\").EventsKey>}\n     */\n    this.sourcesListenerKeys_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.sourceZ_ = 0;\n\n    const targetExtent = targetTileGrid.getTileCoordExtent(\n      this.wrappedTileCoord_\n    );\n    const maxTargetExtent = this.targetTileGrid_.getExtent();\n    let maxSourceExtent = this.sourceTileGrid_.getExtent();\n\n    const limitedTargetExtent = maxTargetExtent\n      ? getIntersection(targetExtent, maxTargetExtent)\n      : targetExtent;\n\n    if (getArea(limitedTargetExtent) === 0) {\n      // Tile is completely outside range -> EMPTY\n      // TODO: is it actually correct that the source even creates the tile ?\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const sourceProjExtent = sourceProj.getExtent();\n    if (sourceProjExtent) {\n      if (!maxSourceExtent) {\n        maxSourceExtent = sourceProjExtent;\n      } else {\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n      }\n    }\n\n    const targetResolution = targetTileGrid.getResolution(\n      this.wrappedTileCoord_[0]\n    );\n\n    const sourceResolution = calculateSourceExtentResolution(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      targetResolution\n    );\n\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n      // invalid sourceResolution -> EMPTY\n      // probably edges of the projections when no extent is defined\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const errorThresholdInPixels =\n      opt_errorThreshold !== undefined ? opt_errorThreshold : ERROR_THRESHOLD;\n\n    /**\n     * @private\n     * @type {!import(\"./Triangulation.js\").default}\n     */\n    this.triangulation_ = new Triangulation(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      maxSourceExtent,\n      sourceResolution * errorThresholdInPixels,\n      targetResolution\n    );\n\n    if (this.triangulation_.getTriangles().length === 0) {\n      // no valid triangles -> EMPTY\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);\n    let sourceExtent = this.triangulation_.calculateSourceExtent();\n\n    if (maxSourceExtent) {\n      if (sourceProj.canWrapX()) {\n        sourceExtent[1] = clamp(\n          sourceExtent[1],\n          maxSourceExtent[1],\n          maxSourceExtent[3]\n        );\n        sourceExtent[3] = clamp(\n          sourceExtent[3],\n          maxSourceExtent[1],\n          maxSourceExtent[3]\n        );\n      } else {\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n      }\n    }\n\n    if (!getArea(sourceExtent)) {\n      this.state = TileState.EMPTY;\n    } else {\n      const sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(\n        sourceExtent,\n        this.sourceZ_\n      );\n\n      for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n        for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n          const tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);\n          if (tile) {\n            this.sourceTiles_.push(tile);\n          }\n        }\n      }\n\n      if (this.sourceTiles_.length === 0) {\n        this.state = TileState.EMPTY;\n      }\n    }\n  }\n\n  /**\n   * Get the HTML Canvas element for this tile.\n   * @return {HTMLCanvasElement} Canvas.\n   */\n  getImage() {\n    return this.canvas_;\n  }\n\n  /**\n   * @private\n   */\n  reproject_() {\n    const sources = [];\n    this.sourceTiles_.forEach(\n      function (tile, i, arr) {\n        if (tile && tile.getState() == TileState.LOADED) {\n          sources.push({\n            extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),\n            image: tile.getImage(),\n          });\n        }\n      }.bind(this)\n    );\n    this.sourceTiles_.length = 0;\n\n    if (sources.length === 0) {\n      this.state = TileState.ERROR;\n    } else {\n      const z = this.wrappedTileCoord_[0];\n      const size = this.targetTileGrid_.getTileSize(z);\n      const width = typeof size === 'number' ? size : size[0];\n      const height = typeof size === 'number' ? size : size[1];\n      const targetResolution = this.targetTileGrid_.getResolution(z);\n      const sourceResolution = this.sourceTileGrid_.getResolution(\n        this.sourceZ_\n      );\n\n      const targetExtent = this.targetTileGrid_.getTileCoordExtent(\n        this.wrappedTileCoord_\n      );\n      this.canvas_ = renderReprojected(\n        width,\n        height,\n        this.pixelRatio_,\n        sourceResolution,\n        this.sourceTileGrid_.getExtent(),\n        targetResolution,\n        targetExtent,\n        this.triangulation_,\n        sources,\n        this.gutter_,\n        this.renderEdges_,\n        this.contextOptions_\n      );\n\n      this.state = TileState.LOADED;\n    }\n    this.changed();\n  }\n\n  /**\n   * Load not yet loaded URI.\n   */\n  load() {\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      this.changed();\n\n      let leftToLoad = 0;\n\n      this.sourcesListenerKeys_ = [];\n      this.sourceTiles_.forEach(\n        function (tile, i, arr) {\n          const state = tile.getState();\n          if (state == TileState.IDLE || state == TileState.LOADING) {\n            leftToLoad++;\n\n            const sourceListenKey = listen(\n              tile,\n              EventType.CHANGE,\n              function (e) {\n                const state = tile.getState();\n                if (\n                  state == TileState.LOADED ||\n                  state == TileState.ERROR ||\n                  state == TileState.EMPTY\n                ) {\n                  unlistenByKey(sourceListenKey);\n                  leftToLoad--;\n                  if (leftToLoad === 0) {\n                    this.unlistenSources_();\n                    this.reproject_();\n                  }\n                }\n              },\n              this\n            );\n            this.sourcesListenerKeys_.push(sourceListenKey);\n          }\n        }.bind(this)\n      );\n\n      this.sourceTiles_.forEach(function (tile, i, arr) {\n        const state = tile.getState();\n        if (state == TileState.IDLE) {\n          tile.load();\n        }\n      });\n\n      if (leftToLoad === 0) {\n        setTimeout(this.reproject_.bind(this), 0);\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  unlistenSources_() {\n    this.sourcesListenerKeys_.forEach(unlistenByKey);\n    this.sourcesListenerKeys_ = null;\n  }\n}\n\nexport default ReprojTile;\n","/**\n * @module ol/reproj/common\n */\n\n/**\n * Default maximum allowed threshold  (in pixels) for reprojection\n * triangulation.\n * @type {number}\n */\nexport const ERROR_THRESHOLD = 0.5;\n\n/**\n * Enable automatic reprojection of raster sources. Default is `true`.\n * TODO: decide if we want to expose this as a build flag or remove it\n * @type {boolean}\n */\nexport const ENABLE_RASTER_REPROJECTION = true;\n","/**\n * @module ol/reproj/Triangulation\n */\nimport {\n  boundingExtent,\n  createEmpty,\n  extendCoordinate,\n  getArea,\n  getBottomLeft,\n  getBottomRight,\n  getTopLeft,\n  getTopRight,\n  getWidth,\n  intersects,\n} from '../extent.js';\nimport {getTransform} from '../proj.js';\nimport {log2, modulo} from '../math.js';\n\n/**\n * Single triangle; consists of 3 source points and 3 target points.\n * @typedef {Object} Triangle\n * @property {Array<import(\"../coordinate.js\").Coordinate>} source Source.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} target Target.\n */\n\n/**\n * Maximum number of subdivision steps during raster reprojection triangulation.\n * Prevents high memory usage and large number of proj4 calls (for certain\n * transformations and areas). At most `2*(2^this)` triangles are created for\n * each triangulated extent (tile/image).\n * @type {number}\n */\nconst MAX_SUBDIVISION = 10;\n\n/**\n * Maximum allowed size of triangle relative to world width. When transforming\n * corners of world extent between certain projections, the resulting\n * triangulation seems to have zero error and no subdivision is performed. If\n * the triangle width is more than this (relative to world width; 0-1),\n * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.\n * @type {number}\n */\nconst MAX_TRIANGLE_WIDTH = 0.25;\n\n/**\n * @classdesc\n * Class containing triangulation of the given target extent.\n * Used for determining source data and the reprojection itself.\n */\nclass Triangulation {\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../extent.js\").Extent} targetExtent Target extent to triangulate.\n   * @param {import(\"../extent.js\").Extent} maxSourceExtent Maximal source extent that can be used.\n   * @param {number} errorThreshold Acceptable error (in source units).\n   * @param {?number} opt_destinationResolution The (optional) resolution of the destination.\n   */\n  constructor(\n    sourceProj,\n    targetProj,\n    targetExtent,\n    maxSourceExtent,\n    errorThreshold,\n    opt_destinationResolution\n  ) {\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     * @private\n     */\n    this.sourceProj_ = sourceProj;\n\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     * @private\n     */\n    this.targetProj_ = targetProj;\n\n    /** @type {!Object<string, import(\"../coordinate.js\").Coordinate>} */\n    let transformInvCache = {};\n    const transformInv = getTransform(this.targetProj_, this.sourceProj_);\n\n    /**\n     * @param {import(\"../coordinate.js\").Coordinate} c A coordinate.\n     * @return {import(\"../coordinate.js\").Coordinate} Transformed coordinate.\n     * @private\n     */\n    this.transformInv_ = function (c) {\n      const key = c[0] + '/' + c[1];\n      if (!transformInvCache[key]) {\n        transformInvCache[key] = transformInv(c);\n      }\n      return transformInvCache[key];\n    };\n\n    /**\n     * @type {import(\"../extent.js\").Extent}\n     * @private\n     */\n    this.maxSourceExtent_ = maxSourceExtent;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.errorThresholdSquared_ = errorThreshold * errorThreshold;\n\n    /**\n     * @type {Array<Triangle>}\n     * @private\n     */\n    this.triangles_ = [];\n\n    /**\n     * Indicates that the triangulation crosses edge of the source projection.\n     * @type {boolean}\n     * @private\n     */\n    this.wrapsXInSource_ = false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.canWrapXInSource_ =\n      this.sourceProj_.canWrapX() &&\n      !!maxSourceExtent &&\n      !!this.sourceProj_.getExtent() &&\n      getWidth(maxSourceExtent) == getWidth(this.sourceProj_.getExtent());\n\n    /**\n     * @type {?number}\n     * @private\n     */\n    this.sourceWorldWidth_ = this.sourceProj_.getExtent()\n      ? getWidth(this.sourceProj_.getExtent())\n      : null;\n\n    /**\n     * @type {?number}\n     * @private\n     */\n    this.targetWorldWidth_ = this.targetProj_.getExtent()\n      ? getWidth(this.targetProj_.getExtent())\n      : null;\n\n    const destinationTopLeft = getTopLeft(targetExtent);\n    const destinationTopRight = getTopRight(targetExtent);\n    const destinationBottomRight = getBottomRight(targetExtent);\n    const destinationBottomLeft = getBottomLeft(targetExtent);\n    const sourceTopLeft = this.transformInv_(destinationTopLeft);\n    const sourceTopRight = this.transformInv_(destinationTopRight);\n    const sourceBottomRight = this.transformInv_(destinationBottomRight);\n    const sourceBottomLeft = this.transformInv_(destinationBottomLeft);\n\n    /*\n     * The maxSubdivision controls how many splittings of the target area can\n     * be done. The idea here is to do a linear mapping of the target areas\n     * but the actual overal reprojection (can be) extremely non-linear. The\n     * default value of MAX_SUBDIVISION was chosen based on mapping a 256x256\n     * tile size. However this function is also called to remap canvas rendered\n     * layers which can be much larger. This calculation increases the maxSubdivision\n     * value by the right factor so that each 256x256 pixel area has\n     * MAX_SUBDIVISION divisions.\n     */\n    const maxSubdivision =\n      MAX_SUBDIVISION +\n      (opt_destinationResolution\n        ? Math.max(\n            0,\n            Math.ceil(\n              log2(\n                getArea(targetExtent) /\n                  (opt_destinationResolution *\n                    opt_destinationResolution *\n                    256 *\n                    256)\n              )\n            )\n          )\n        : 0);\n\n    this.addQuad_(\n      destinationTopLeft,\n      destinationTopRight,\n      destinationBottomRight,\n      destinationBottomLeft,\n      sourceTopLeft,\n      sourceTopRight,\n      sourceBottomRight,\n      sourceBottomLeft,\n      maxSubdivision\n    );\n\n    if (this.wrapsXInSource_) {\n      let leftBound = Infinity;\n      this.triangles_.forEach(function (triangle, i, arr) {\n        leftBound = Math.min(\n          leftBound,\n          triangle.source[0][0],\n          triangle.source[1][0],\n          triangle.source[2][0]\n        );\n      });\n\n      // Shift triangles to be as close to `leftBound` as possible\n      // (if the distance is more than `worldWidth / 2` it can be closer.\n      this.triangles_.forEach(\n        function (triangle) {\n          if (\n            Math.max(\n              triangle.source[0][0],\n              triangle.source[1][0],\n              triangle.source[2][0]\n            ) -\n              leftBound >\n            this.sourceWorldWidth_ / 2\n          ) {\n            const newTriangle = [\n              [triangle.source[0][0], triangle.source[0][1]],\n              [triangle.source[1][0], triangle.source[1][1]],\n              [triangle.source[2][0], triangle.source[2][1]],\n            ];\n            if (newTriangle[0][0] - leftBound > this.sourceWorldWidth_ / 2) {\n              newTriangle[0][0] -= this.sourceWorldWidth_;\n            }\n            if (newTriangle[1][0] - leftBound > this.sourceWorldWidth_ / 2) {\n              newTriangle[1][0] -= this.sourceWorldWidth_;\n            }\n            if (newTriangle[2][0] - leftBound > this.sourceWorldWidth_ / 2) {\n              newTriangle[2][0] -= this.sourceWorldWidth_;\n            }\n\n            // Rarely (if the extent contains both the dateline and prime meridian)\n            // the shift can in turn break some triangles.\n            // Detect this here and don't shift in such cases.\n            const minX = Math.min(\n              newTriangle[0][0],\n              newTriangle[1][0],\n              newTriangle[2][0]\n            );\n            const maxX = Math.max(\n              newTriangle[0][0],\n              newTriangle[1][0],\n              newTriangle[2][0]\n            );\n            if (maxX - minX < this.sourceWorldWidth_ / 2) {\n              triangle.source = newTriangle;\n            }\n          }\n        }.bind(this)\n      );\n    }\n\n    transformInvCache = {};\n  }\n\n  /**\n   * Adds triangle to the triangulation.\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n   * @private\n   */\n  addTriangle_(a, b, c, aSrc, bSrc, cSrc) {\n    this.triangles_.push({\n      source: [aSrc, bSrc, cSrc],\n      target: [a, b, c],\n    });\n  }\n\n  /**\n   * Adds quad (points in clock-wise order) to the triangulation\n   * (and reprojects the vertices) if valid.\n   * Performs quad subdivision if needed to increase precision.\n   *\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} d The target d coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} dSrc The source d coordinate.\n   * @param {number} maxSubdivision Maximal allowed subdivision of the quad.\n   * @private\n   */\n  addQuad_(a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {\n    const sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);\n    const sourceCoverageX = this.sourceWorldWidth_\n      ? getWidth(sourceQuadExtent) / this.sourceWorldWidth_\n      : null;\n    const sourceWorldWidth = /** @type {number} */ (this.sourceWorldWidth_);\n\n    // when the quad is wrapped in the source projection\n    // it covers most of the projection extent, but not fully\n    const wrapsX =\n      this.sourceProj_.canWrapX() &&\n      sourceCoverageX > 0.5 &&\n      sourceCoverageX < 1;\n\n    let needsSubdivision = false;\n\n    if (maxSubdivision > 0) {\n      if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {\n        const targetQuadExtent = boundingExtent([a, b, c, d]);\n        const targetCoverageX =\n          getWidth(targetQuadExtent) / this.targetWorldWidth_;\n        needsSubdivision =\n          targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n      }\n      if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {\n        needsSubdivision =\n          sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n      }\n    }\n\n    if (!needsSubdivision && this.maxSourceExtent_) {\n      if (\n        isFinite(sourceQuadExtent[0]) &&\n        isFinite(sourceQuadExtent[1]) &&\n        isFinite(sourceQuadExtent[2]) &&\n        isFinite(sourceQuadExtent[3])\n      ) {\n        if (!intersects(sourceQuadExtent, this.maxSourceExtent_)) {\n          // whole quad outside source projection extent -> ignore\n          return;\n        }\n      }\n    }\n\n    let isNotFinite = 0;\n\n    if (!needsSubdivision) {\n      if (\n        !isFinite(aSrc[0]) ||\n        !isFinite(aSrc[1]) ||\n        !isFinite(bSrc[0]) ||\n        !isFinite(bSrc[1]) ||\n        !isFinite(cSrc[0]) ||\n        !isFinite(cSrc[1]) ||\n        !isFinite(dSrc[0]) ||\n        !isFinite(dSrc[1])\n      ) {\n        if (maxSubdivision > 0) {\n          needsSubdivision = true;\n        } else {\n          // It might be the case that only 1 of the points is infinite. In this case\n          // we can draw a single triangle with the other three points\n          isNotFinite =\n            (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) +\n            (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) +\n            (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) +\n            (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);\n          if (\n            isNotFinite != 1 &&\n            isNotFinite != 2 &&\n            isNotFinite != 4 &&\n            isNotFinite != 8\n          ) {\n            return;\n          }\n        }\n      }\n    }\n\n    if (maxSubdivision > 0) {\n      if (!needsSubdivision) {\n        const center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];\n        const centerSrc = this.transformInv_(center);\n\n        let dx;\n        if (wrapsX) {\n          const centerSrcEstimX =\n            (modulo(aSrc[0], sourceWorldWidth) +\n              modulo(cSrc[0], sourceWorldWidth)) /\n            2;\n          dx = centerSrcEstimX - modulo(centerSrc[0], sourceWorldWidth);\n        } else {\n          dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];\n        }\n        const dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];\n        const centerSrcErrorSquared = dx * dx + dy * dy;\n        needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;\n      }\n      if (needsSubdivision) {\n        if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {\n          // split horizontally (top & bottom)\n          const bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];\n          const bcSrc = this.transformInv_(bc);\n          const da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];\n          const daSrc = this.transformInv_(da);\n\n          this.addQuad_(\n            a,\n            b,\n            bc,\n            da,\n            aSrc,\n            bSrc,\n            bcSrc,\n            daSrc,\n            maxSubdivision - 1\n          );\n          this.addQuad_(\n            da,\n            bc,\n            c,\n            d,\n            daSrc,\n            bcSrc,\n            cSrc,\n            dSrc,\n            maxSubdivision - 1\n          );\n        } else {\n          // split vertically (left & right)\n          const ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];\n          const abSrc = this.transformInv_(ab);\n          const cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];\n          const cdSrc = this.transformInv_(cd);\n\n          this.addQuad_(\n            a,\n            ab,\n            cd,\n            d,\n            aSrc,\n            abSrc,\n            cdSrc,\n            dSrc,\n            maxSubdivision - 1\n          );\n          this.addQuad_(\n            ab,\n            b,\n            c,\n            cd,\n            abSrc,\n            bSrc,\n            cSrc,\n            cdSrc,\n            maxSubdivision - 1\n          );\n        }\n        return;\n      }\n    }\n\n    if (wrapsX) {\n      if (!this.canWrapXInSource_) {\n        return;\n      }\n      this.wrapsXInSource_ = true;\n    }\n\n    // Exactly zero or one of *Src is not finite\n    // The triangles must have the diagonal line as the first side\n    // This is to allow easy code in reproj.s to make it straight for broken\n    // browsers that can't handle diagonal clipping\n    if ((isNotFinite & 0xb) == 0) {\n      this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);\n    }\n    if ((isNotFinite & 0xe) == 0) {\n      this.addTriangle_(a, c, b, aSrc, cSrc, bSrc);\n    }\n    if (isNotFinite) {\n      // Try the other two triangles\n      if ((isNotFinite & 0xd) == 0) {\n        this.addTriangle_(b, d, a, bSrc, dSrc, aSrc);\n      }\n      if ((isNotFinite & 0x7) == 0) {\n        this.addTriangle_(b, d, c, bSrc, dSrc, cSrc);\n      }\n    }\n  }\n\n  /**\n   * Calculates extent of the 'source' coordinates from all the triangles.\n   *\n   * @return {import(\"../extent.js\").Extent} Calculated extent.\n   */\n  calculateSourceExtent() {\n    const extent = createEmpty();\n\n    this.triangles_.forEach(function (triangle, i, arr) {\n      const src = triangle.source;\n      extendCoordinate(extent, src[0]);\n      extendCoordinate(extent, src[1]);\n      extendCoordinate(extent, src[2]);\n    });\n\n    return extent;\n  }\n\n  /**\n   * @return {Array<Triangle>} Array of the calculated triangles.\n   */\n  getTriangles() {\n    return this.triangles_;\n  }\n}\n\nexport default Triangulation;\n","/**\n * @module ol/reproj\n */\nimport {IMAGE_SMOOTHING_DISABLED} from './source/common.js';\nimport {assign} from './obj.js';\nimport {\n  containsCoordinate,\n  createEmpty,\n  extend,\n  forEachCorner,\n  getCenter,\n  getHeight,\n  getTopLeft,\n  getWidth,\n} from './extent.js';\nimport {createCanvasContext2D} from './dom.js';\nimport {getPointResolution, transform} from './proj.js';\nimport {solveLinearSystem} from './math.js';\n\nlet brokenDiagonalRendering_;\n\n/**\n * This draws a small triangle into a canvas by setting the triangle as the clip region\n * and then drawing a (too large) rectangle\n *\n * @param {CanvasRenderingContext2D} ctx The context in which to draw the triangle\n * @param {number} u1 The x-coordinate of the second point. The first point is 0,0.\n * @param {number} v1 The y-coordinate of the second point.\n * @param {number} u2 The x-coordinate of the third point.\n * @param {number} v2 The y-coordinate of the third point.\n */\nfunction drawTestTriangle(ctx, u1, v1, u2, v2) {\n  ctx.beginPath();\n  ctx.moveTo(0, 0);\n  ctx.lineTo(u1, v1);\n  ctx.lineTo(u2, v2);\n  ctx.closePath();\n  ctx.save();\n  ctx.clip();\n  ctx.fillRect(0, 0, Math.max(u1, u2) + 1, Math.max(v1, v2));\n  ctx.restore();\n}\n\n/**\n * Given the data from getImageData, see if the right values appear at the provided offset.\n * Returns true if either the color or transparency is off\n *\n * @param {Uint8ClampedArray} data The data returned from getImageData\n * @param {number} offset The pixel offset from the start of data.\n * @return {boolean} true if the diagonal rendering is broken\n */\nfunction verifyBrokenDiagonalRendering(data, offset) {\n  // the values ought to be close to the rgba(210, 0, 0, 0.75)\n  return (\n    Math.abs(data[offset * 4] - 210) > 2 ||\n    Math.abs(data[offset * 4 + 3] - 0.75 * 255) > 2\n  );\n}\n\n/**\n * Determines if the current browser configuration can render triangular clip regions correctly.\n * This value is cached so the function is only expensive the first time called.\n * Firefox on Windows (as of now) does not if HWA is enabled. See https://bugzilla.mozilla.org/show_bug.cgi?id=1606976\n * IE also doesn't. Chrome works, and everything seems to work on OSX and Android. This function caches the\n * result. I suppose that it is conceivably possible that a browser might flip modes while the app is\n * running, but lets hope not.\n *\n * @return {boolean} true if the Diagonal Rendering is broken.\n */\nfunction isBrokenDiagonalRendering() {\n  if (brokenDiagonalRendering_ === undefined) {\n    const ctx = document.createElement('canvas').getContext('2d');\n    ctx.globalCompositeOperation = 'lighter';\n    ctx.fillStyle = 'rgba(210, 0, 0, 0.75)';\n    drawTestTriangle(ctx, 4, 5, 4, 0);\n    drawTestTriangle(ctx, 4, 5, 0, 5);\n    const data = ctx.getImageData(0, 0, 3, 3).data;\n    brokenDiagonalRendering_ =\n      verifyBrokenDiagonalRendering(data, 0) ||\n      verifyBrokenDiagonalRendering(data, 4) ||\n      verifyBrokenDiagonalRendering(data, 8);\n  }\n\n  return brokenDiagonalRendering_;\n}\n\n/**\n * Calculates ideal resolution to use from the source in order to achieve\n * pixel mapping as close as possible to 1:1 during reprojection.\n * The resolution is calculated regardless of what resolutions\n * are actually available in the dataset (TileGrid, Image, ...).\n *\n * @param {import(\"./proj/Projection.js\").default} sourceProj Source projection.\n * @param {import(\"./proj/Projection.js\").default} targetProj Target projection.\n * @param {import(\"./coordinate.js\").Coordinate} targetCenter Target center.\n * @param {number} targetResolution Target resolution.\n * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.\n */\nexport function calculateSourceResolution(\n  sourceProj,\n  targetProj,\n  targetCenter,\n  targetResolution\n) {\n  const sourceCenter = transform(targetCenter, targetProj, sourceProj);\n\n  // calculate the ideal resolution of the source data\n  let sourceResolution = getPointResolution(\n    targetProj,\n    targetResolution,\n    targetCenter\n  );\n\n  const targetMetersPerUnit = targetProj.getMetersPerUnit();\n  if (targetMetersPerUnit !== undefined) {\n    sourceResolution *= targetMetersPerUnit;\n  }\n  const sourceMetersPerUnit = sourceProj.getMetersPerUnit();\n  if (sourceMetersPerUnit !== undefined) {\n    sourceResolution /= sourceMetersPerUnit;\n  }\n\n  // Based on the projection properties, the point resolution at the specified\n  // coordinates may be slightly different. We need to reverse-compensate this\n  // in order to achieve optimal results.\n\n  const sourceExtent = sourceProj.getExtent();\n  if (!sourceExtent || containsCoordinate(sourceExtent, sourceCenter)) {\n    const compensationFactor =\n      getPointResolution(sourceProj, sourceResolution, sourceCenter) /\n      sourceResolution;\n    if (isFinite(compensationFactor) && compensationFactor > 0) {\n      sourceResolution /= compensationFactor;\n    }\n  }\n\n  return sourceResolution;\n}\n\n/**\n * Calculates ideal resolution to use from the source in order to achieve\n * pixel mapping as close as possible to 1:1 during reprojection.\n * The resolution is calculated regardless of what resolutions\n * are actually available in the dataset (TileGrid, Image, ...).\n *\n * @param {import(\"./proj/Projection.js\").default} sourceProj Source projection.\n * @param {import(\"./proj/Projection.js\").default} targetProj Target projection.\n * @param {import(\"./extent.js\").Extent} targetExtent Target extent\n * @param {number} targetResolution Target resolution.\n * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.\n */\nexport function calculateSourceExtentResolution(\n  sourceProj,\n  targetProj,\n  targetExtent,\n  targetResolution\n) {\n  const targetCenter = getCenter(targetExtent);\n  let sourceResolution = calculateSourceResolution(\n    sourceProj,\n    targetProj,\n    targetCenter,\n    targetResolution\n  );\n\n  if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n    forEachCorner(targetExtent, function (corner) {\n      sourceResolution = calculateSourceResolution(\n        sourceProj,\n        targetProj,\n        corner,\n        targetResolution\n      );\n      return isFinite(sourceResolution) && sourceResolution > 0;\n    });\n  }\n\n  return sourceResolution;\n}\n\n/**\n * @typedef {Object} ImageExtent\n * @property {import(\"./extent.js\").Extent} extent Extent.\n * @property {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image.\n */\n\n/**\n * Renders the source data into new canvas based on the triangulation.\n *\n * @param {number} width Width of the canvas.\n * @param {number} height Height of the canvas.\n * @param {number} pixelRatio Pixel ratio.\n * @param {number} sourceResolution Source resolution.\n * @param {import(\"./extent.js\").Extent} sourceExtent Extent of the data source.\n * @param {number} targetResolution Target resolution.\n * @param {import(\"./extent.js\").Extent} targetExtent Target extent.\n * @param {import(\"./reproj/Triangulation.js\").default} triangulation Calculated triangulation.\n * @param {Array<ImageExtent>} sources Array of sources.\n * @param {number} gutter Gutter of the sources.\n * @param {boolean} [opt_renderEdges] Render reprojection edges.\n * @param {object} [opt_contextOptions] Properties to set on the canvas context.\n * @return {HTMLCanvasElement} Canvas with reprojected data.\n */\nexport function render(\n  width,\n  height,\n  pixelRatio,\n  sourceResolution,\n  sourceExtent,\n  targetResolution,\n  targetExtent,\n  triangulation,\n  sources,\n  gutter,\n  opt_renderEdges,\n  opt_contextOptions\n) {\n  const context = createCanvasContext2D(\n    Math.round(pixelRatio * width),\n    Math.round(pixelRatio * height)\n  );\n  assign(context, opt_contextOptions);\n\n  if (sources.length === 0) {\n    return context.canvas;\n  }\n\n  context.scale(pixelRatio, pixelRatio);\n\n  function pixelRound(value) {\n    return Math.round(value * pixelRatio) / pixelRatio;\n  }\n\n  context.globalCompositeOperation = 'lighter';\n\n  const sourceDataExtent = createEmpty();\n  sources.forEach(function (src, i, arr) {\n    extend(sourceDataExtent, src.extent);\n  });\n\n  const canvasWidthInUnits = getWidth(sourceDataExtent);\n  const canvasHeightInUnits = getHeight(sourceDataExtent);\n  const stitchContext = createCanvasContext2D(\n    Math.round((pixelRatio * canvasWidthInUnits) / sourceResolution),\n    Math.round((pixelRatio * canvasHeightInUnits) / sourceResolution)\n  );\n  assign(stitchContext, opt_contextOptions);\n\n  const stitchScale = pixelRatio / sourceResolution;\n\n  sources.forEach(function (src, i, arr) {\n    const xPos = src.extent[0] - sourceDataExtent[0];\n    const yPos = -(src.extent[3] - sourceDataExtent[3]);\n    const srcWidth = getWidth(src.extent);\n    const srcHeight = getHeight(src.extent);\n\n    // This test should never fail -- but it does. Need to find a fix the upstream condition\n    if (src.image.width > 0 && src.image.height > 0) {\n      stitchContext.drawImage(\n        src.image,\n        gutter,\n        gutter,\n        src.image.width - 2 * gutter,\n        src.image.height - 2 * gutter,\n        xPos * stitchScale,\n        yPos * stitchScale,\n        srcWidth * stitchScale,\n        srcHeight * stitchScale\n      );\n    }\n  });\n\n  const targetTopLeft = getTopLeft(targetExtent);\n\n  triangulation.getTriangles().forEach(function (triangle, i, arr) {\n    /* Calculate affine transform (src -> dst)\n     * Resulting matrix can be used to transform coordinate\n     * from `sourceProjection` to destination pixels.\n     *\n     * To optimize number of context calls and increase numerical stability,\n     * we also do the following operations:\n     * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)\n     * here before solving the linear system so [ui, vi] are pixel coordinates.\n     *\n     * Src points: xi, yi\n     * Dst points: ui, vi\n     * Affine coefficients: aij\n     *\n     * | x0 y0 1  0  0 0 |   |a00|   |u0|\n     * | x1 y1 1  0  0 0 |   |a01|   |u1|\n     * | x2 y2 1  0  0 0 | x |a02| = |u2|\n     * |  0  0 0 x0 y0 1 |   |a10|   |v0|\n     * |  0  0 0 x1 y1 1 |   |a11|   |v1|\n     * |  0  0 0 x2 y2 1 |   |a12|   |v2|\n     */\n    const source = triangle.source;\n    const target = triangle.target;\n    let x0 = source[0][0],\n      y0 = source[0][1];\n    let x1 = source[1][0],\n      y1 = source[1][1];\n    let x2 = source[2][0],\n      y2 = source[2][1];\n    // Make sure that everything is on pixel boundaries\n    const u0 = pixelRound((target[0][0] - targetTopLeft[0]) / targetResolution);\n    const v0 = pixelRound(\n      -(target[0][1] - targetTopLeft[1]) / targetResolution\n    );\n    const u1 = pixelRound((target[1][0] - targetTopLeft[0]) / targetResolution);\n    const v1 = pixelRound(\n      -(target[1][1] - targetTopLeft[1]) / targetResolution\n    );\n    const u2 = pixelRound((target[2][0] - targetTopLeft[0]) / targetResolution);\n    const v2 = pixelRound(\n      -(target[2][1] - targetTopLeft[1]) / targetResolution\n    );\n\n    // Shift all the source points to improve numerical stability\n    // of all the subsequent calculations. The [x0, y0] is used here.\n    // This is also used to simplify the linear system.\n    const sourceNumericalShiftX = x0;\n    const sourceNumericalShiftY = y0;\n    x0 = 0;\n    y0 = 0;\n    x1 -= sourceNumericalShiftX;\n    y1 -= sourceNumericalShiftY;\n    x2 -= sourceNumericalShiftX;\n    y2 -= sourceNumericalShiftY;\n\n    const augmentedMatrix = [\n      [x1, y1, 0, 0, u1 - u0],\n      [x2, y2, 0, 0, u2 - u0],\n      [0, 0, x1, y1, v1 - v0],\n      [0, 0, x2, y2, v2 - v0],\n    ];\n    const affineCoefs = solveLinearSystem(augmentedMatrix);\n    if (!affineCoefs) {\n      return;\n    }\n\n    context.save();\n    context.beginPath();\n\n    if (\n      isBrokenDiagonalRendering() ||\n      opt_contextOptions === IMAGE_SMOOTHING_DISABLED\n    ) {\n      // Make sure that all lines are horizontal or vertical\n      context.moveTo(u1, v1);\n      // This is the diagonal line. Do it in 4 steps\n      const steps = 4;\n      const ud = u0 - u1;\n      const vd = v0 - v1;\n      for (let step = 0; step < steps; step++) {\n        // Go horizontally\n        context.lineTo(\n          u1 + pixelRound(((step + 1) * ud) / steps),\n          v1 + pixelRound((step * vd) / (steps - 1))\n        );\n        // Go vertically\n        if (step != steps - 1) {\n          context.lineTo(\n            u1 + pixelRound(((step + 1) * ud) / steps),\n            v1 + pixelRound(((step + 1) * vd) / (steps - 1))\n          );\n        }\n      }\n      // We are almost at u0r, v0r\n      context.lineTo(u2, v2);\n    } else {\n      context.moveTo(u1, v1);\n      context.lineTo(u0, v0);\n      context.lineTo(u2, v2);\n    }\n\n    context.clip();\n\n    context.transform(\n      affineCoefs[0],\n      affineCoefs[2],\n      affineCoefs[1],\n      affineCoefs[3],\n      u0,\n      v0\n    );\n\n    context.translate(\n      sourceDataExtent[0] - sourceNumericalShiftX,\n      sourceDataExtent[3] - sourceNumericalShiftY\n    );\n\n    context.scale(\n      sourceResolution / pixelRatio,\n      -sourceResolution / pixelRatio\n    );\n\n    context.drawImage(stitchContext.canvas, 0, 0);\n    context.restore();\n  });\n\n  if (opt_renderEdges) {\n    context.save();\n\n    context.globalCompositeOperation = 'source-over';\n    context.strokeStyle = 'black';\n    context.lineWidth = 1;\n\n    triangulation.getTriangles().forEach(function (triangle, i, arr) {\n      const target = triangle.target;\n      const u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;\n      const v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;\n      const u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;\n      const v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;\n      const u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;\n      const v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;\n\n      context.beginPath();\n      context.moveTo(u1, v1);\n      context.lineTo(u0, v0);\n      context.lineTo(u2, v2);\n      context.closePath();\n      context.stroke();\n    });\n\n    context.restore();\n  }\n  return context.canvas;\n}\n","/**\n * @module ol/source/common\n */\n\n/**\n * Default WMS version.\n * @type {string}\n */\nexport const DEFAULT_WMS_VERSION = '1.3.0';\n\n/**\n * Context options to disable image smoothing.\n * @type {Object}\n */\nexport const IMAGE_SMOOTHING_DISABLED = {\n  imageSmoothingEnabled: false,\n  msImageSmoothingEnabled: false,\n};\n","/**\n * @module ol/TileCache\n */\nimport LRUCache from './structs/LRUCache.js';\nimport {fromKey, getKey} from './tilecoord.js';\n\nclass TileCache extends LRUCache {\n  /**\n   * @param {!Object<string, boolean>} usedTiles Used tiles.\n   */\n  expireCache(usedTiles) {\n    while (this.canExpireCache()) {\n      const tile = this.peekLast();\n      if (tile.getKey() in usedTiles) {\n        break;\n      } else {\n        this.pop().release();\n      }\n    }\n  }\n\n  /**\n   * Prune all tiles from the cache that don't have the same z as the newest tile.\n   */\n  pruneExceptNewestZ() {\n    if (this.getCount() === 0) {\n      return;\n    }\n    const key = this.peekFirstKey();\n    const tileCoord = fromKey(key);\n    const z = tileCoord[0];\n    this.forEach(\n      function (tile) {\n        if (tile.tileCoord[0] !== z) {\n          this.remove(getKey(tile.tileCoord));\n          tile.release();\n        }\n      }.bind(this)\n    );\n  }\n}\n\nexport default TileCache;\n","/**\n * @module ol/structs/LRUCache\n */\n\nimport {assert} from '../asserts.js';\n\n/**\n * @typedef {Object} Entry\n * @property {string} key_ Key.\n * @property {Object} newer Newer.\n * @property {Object} older Older.\n * @property {*} value_ Value.\n */\n\n/**\n * @classdesc\n * Implements a Least-Recently-Used cache where the keys do not conflict with\n * Object's properties (e.g. 'hasOwnProperty' is not allowed as a key). Expiring\n * items from the cache is the responsibility of the user.\n *\n * @fires import(\"../events/Event.js\").default\n * @template T\n */\nclass LRUCache {\n  /**\n   * @param {number} [opt_highWaterMark] High water mark.\n   */\n  constructor(opt_highWaterMark) {\n    /**\n     * Desired max cache size after expireCache(). If set to 0, no cache entries\n     * will be pruned at all.\n     * @type {number}\n     */\n    this.highWaterMark =\n      opt_highWaterMark !== undefined ? opt_highWaterMark : 2048;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.count_ = 0;\n\n    /**\n     * @private\n     * @type {!Object<string, Entry>}\n     */\n    this.entries_ = {};\n\n    /**\n     * @private\n     * @type {?Entry}\n     */\n    this.oldest_ = null;\n\n    /**\n     * @private\n     * @type {?Entry}\n     */\n    this.newest_ = null;\n  }\n\n  /**\n   * @return {boolean} Can expire cache.\n   */\n  canExpireCache() {\n    return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;\n  }\n\n  /**\n   * FIXME empty description for jsdoc\n   */\n  clear() {\n    this.count_ = 0;\n    this.entries_ = {};\n    this.oldest_ = null;\n    this.newest_ = null;\n  }\n\n  /**\n   * @param {string} key Key.\n   * @return {boolean} Contains key.\n   */\n  containsKey(key) {\n    return this.entries_.hasOwnProperty(key);\n  }\n\n  /**\n   * @param {function(T, string, LRUCache<T>): ?} f The function\n   *     to call for every entry from the oldest to the newer. This function takes\n   *     3 arguments (the entry value, the entry key and the LRUCache object).\n   *     The return value is ignored.\n   */\n  forEach(f) {\n    let entry = this.oldest_;\n    while (entry) {\n      f(entry.value_, entry.key_, this);\n      entry = entry.newer;\n    }\n  }\n\n  /**\n   * @param {string} key Key.\n   * @param {*} [opt_options] Options (reserved for subclasses).\n   * @return {T} Value.\n   */\n  get(key, opt_options) {\n    const entry = this.entries_[key];\n    assert(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache\n    if (entry === this.newest_) {\n      return entry.value_;\n    } else if (entry === this.oldest_) {\n      this.oldest_ = /** @type {Entry} */ (this.oldest_.newer);\n      this.oldest_.older = null;\n    } else {\n      entry.newer.older = entry.older;\n      entry.older.newer = entry.newer;\n    }\n    entry.newer = null;\n    entry.older = this.newest_;\n    this.newest_.newer = entry;\n    this.newest_ = entry;\n    return entry.value_;\n  }\n\n  /**\n   * Remove an entry from the cache.\n   * @param {string} key The entry key.\n   * @return {T} The removed entry.\n   */\n  remove(key) {\n    const entry = this.entries_[key];\n    assert(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache\n    if (entry === this.newest_) {\n      this.newest_ = /** @type {Entry} */ (entry.older);\n      if (this.newest_) {\n        this.newest_.newer = null;\n      }\n    } else if (entry === this.oldest_) {\n      this.oldest_ = /** @type {Entry} */ (entry.newer);\n      if (this.oldest_) {\n        this.oldest_.older = null;\n      }\n    } else {\n      entry.newer.older = entry.older;\n      entry.older.newer = entry.newer;\n    }\n    delete this.entries_[key];\n    --this.count_;\n    return entry.value_;\n  }\n\n  /**\n   * @return {number} Count.\n   */\n  getCount() {\n    return this.count_;\n  }\n\n  /**\n   * @return {Array<string>} Keys.\n   */\n  getKeys() {\n    const keys = new Array(this.count_);\n    let i = 0;\n    let entry;\n    for (entry = this.newest_; entry; entry = entry.older) {\n      keys[i++] = entry.key_;\n    }\n    return keys;\n  }\n\n  /**\n   * @return {Array<T>} Values.\n   */\n  getValues() {\n    const values = new Array(this.count_);\n    let i = 0;\n    let entry;\n    for (entry = this.newest_; entry; entry = entry.older) {\n      values[i++] = entry.value_;\n    }\n    return values;\n  }\n\n  /**\n   * @return {T} Last value.\n   */\n  peekLast() {\n    return this.oldest_.value_;\n  }\n\n  /**\n   * @return {string} Last key.\n   */\n  peekLastKey() {\n    return this.oldest_.key_;\n  }\n\n  /**\n   * Get the key of the newest item in the cache.  Throws if the cache is empty.\n   * @return {string} The newest key.\n   */\n  peekFirstKey() {\n    return this.newest_.key_;\n  }\n\n  /**\n   * @return {T} value Value.\n   */\n  pop() {\n    const entry = this.oldest_;\n    delete this.entries_[entry.key_];\n    if (entry.newer) {\n      entry.newer.older = null;\n    }\n    this.oldest_ = /** @type {Entry} */ (entry.newer);\n    if (!this.oldest_) {\n      this.newest_ = null;\n    }\n    --this.count_;\n    return entry.value_;\n  }\n\n  /**\n   * @param {string} key Key.\n   * @param {T} value Value.\n   */\n  replace(key, value) {\n    this.get(key); // update `newest_`\n    this.entries_[key].value_ = value;\n  }\n\n  /**\n   * @param {string} key Key.\n   * @param {T} value Value.\n   */\n  set(key, value) {\n    assert(!(key in this.entries_), 16); // Tried to set a value for a key that is used already\n    const entry = {\n      key_: key,\n      newer: null,\n      older: this.newest_,\n      value_: value,\n    };\n    if (!this.newest_) {\n      this.oldest_ = entry;\n    } else {\n      this.newest_.newer = entry;\n    }\n    this.newest_ = entry;\n    this.entries_[key] = entry;\n    ++this.count_;\n  }\n\n  /**\n   * Set a maximum number of entries for the cache.\n   * @param {number} size Cache size.\n   * @api\n   */\n  setSize(size) {\n    this.highWaterMark = size;\n  }\n}\n\nexport default LRUCache;\n","/**\n * @module ol/tilecoord\n */\n\n/**\n * An array of three numbers representing the location of a tile in a tile\n * grid. The order is `z` (zoom level), `x` (column), and `y` (row).\n * @typedef {Array<number>} TileCoord\n * @api\n */\n\n/**\n * @param {number} z Z.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {TileCoord} [opt_tileCoord] Tile coordinate.\n * @return {TileCoord} Tile coordinate.\n */\nexport function createOrUpdate(z, x, y, opt_tileCoord) {\n  if (opt_tileCoord !== undefined) {\n    opt_tileCoord[0] = z;\n    opt_tileCoord[1] = x;\n    opt_tileCoord[2] = y;\n    return opt_tileCoord;\n  } else {\n    return [z, x, y];\n  }\n}\n\n/**\n * @param {number} z Z.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {string} Key.\n */\nexport function getKeyZXY(z, x, y) {\n  return z + '/' + x + '/' + y;\n}\n\n/**\n * Get the key for a tile coord.\n * @param {TileCoord} tileCoord The tile coord.\n * @return {string} Key.\n */\nexport function getKey(tileCoord) {\n  return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);\n}\n\n/**\n * Get a tile coord given a key.\n * @param {string} key The tile coord key.\n * @return {TileCoord} The tile coord.\n */\nexport function fromKey(key) {\n  return key.split('/').map(Number);\n}\n\n/**\n * @param {TileCoord} tileCoord Tile coord.\n * @return {number} Hash.\n */\nexport function hash(tileCoord) {\n  return (tileCoord[1] << tileCoord[0]) + tileCoord[2];\n}\n\n/**\n * @param {TileCoord} tileCoord Tile coordinate.\n * @param {!import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n * @return {boolean} Tile coordinate is within extent and zoom level range.\n */\nexport function withinExtentAndZ(tileCoord, tileGrid) {\n  const z = tileCoord[0];\n  const x = tileCoord[1];\n  const y = tileCoord[2];\n\n  if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {\n    return false;\n  }\n  const tileRange = tileGrid.getFullTileRange(z);\n  if (!tileRange) {\n    return true;\n  } else {\n    return tileRange.containsXY(x, y);\n  }\n}\n","/**\n * @module ol/source/UrlTile\n */\nimport TileEventType from './TileEventType.js';\nimport TileSource, {TileSourceEvent} from './Tile.js';\nimport TileState from '../TileState.js';\nimport {createFromTemplates, expandUrl} from '../tileurlfunction.js';\nimport {getKeyZXY} from '../tilecoord.js';\nimport {getUid} from '../util.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] Cache size.\n * @property {boolean} [opaque=false] Whether the layer is opaque.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection.\n * @property {import(\"./State.js\").default} [state] State.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] TileGrid.\n * @property {import(\"../Tile.js\").LoadFunction} tileLoadFunction TileLoadFunction.\n * @property {number} [tilePixelRatio] TilePixelRatio.\n * @property {import(\"../Tile.js\").UrlFunction} [tileUrlFunction] TileUrlFunction.\n * @property {string} [url] Url.\n * @property {Array<string>} [urls] Urls.\n * @property {boolean} [wrapX=true] WrapX.\n * @property {number} [transition] Transition.\n * @property {string} [key] Key.\n * @property {number} [zDirection=0] ZDirection.\n */\n\n/**\n * @classdesc\n * Base class for sources providing tiles divided into a tile grid over http.\n *\n * @fires import(\"./Tile.js\").TileSourceEvent\n */\nclass UrlTile extends TileSource {\n  /**\n   * @param {Options} options Image tile options.\n   */\n  constructor(options) {\n    super({\n      attributions: options.attributions,\n      cacheSize: options.cacheSize,\n      opaque: options.opaque,\n      projection: options.projection,\n      state: options.state,\n      tileGrid: options.tileGrid,\n      tilePixelRatio: options.tilePixelRatio,\n      wrapX: options.wrapX,\n      transition: options.transition,\n      key: options.key,\n      attributionsCollapsible: options.attributionsCollapsible,\n      zDirection: options.zDirection,\n    });\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.generateTileUrlFunction_ =\n      this.tileUrlFunction === UrlTile.prototype.tileUrlFunction;\n\n    /**\n     * @protected\n     * @type {import(\"../Tile.js\").LoadFunction}\n     */\n    this.tileLoadFunction = options.tileLoadFunction;\n\n    if (options.tileUrlFunction) {\n      this.tileUrlFunction = options.tileUrlFunction;\n    }\n\n    /**\n     * @protected\n     * @type {!Array<string>|null}\n     */\n    this.urls = null;\n\n    if (options.urls) {\n      this.setUrls(options.urls);\n    } else if (options.url) {\n      this.setUrl(options.url);\n    }\n\n    /**\n     * @private\n     * @type {!Object<string, boolean>}\n     */\n    this.tileLoadingKeys_ = {};\n  }\n\n  /**\n   * Return the tile load function of the source.\n   * @return {import(\"../Tile.js\").LoadFunction} TileLoadFunction\n   * @api\n   */\n  getTileLoadFunction() {\n    return this.tileLoadFunction;\n  }\n\n  /**\n   * Return the tile URL function of the source.\n   * @return {import(\"../Tile.js\").UrlFunction} TileUrlFunction\n   * @api\n   */\n  getTileUrlFunction() {\n    return Object.getPrototypeOf(this).tileUrlFunction === this.tileUrlFunction\n      ? this.tileUrlFunction.bind(this)\n      : this.tileUrlFunction;\n  }\n\n  /**\n   * Return the URLs used for this source.\n   * When a tileUrlFunction is used instead of url or urls,\n   * null will be returned.\n   * @return {!Array<string>|null} URLs.\n   * @api\n   */\n  getUrls() {\n    return this.urls;\n  }\n\n  /**\n   * Handle tile change events.\n   * @param {import(\"../events/Event.js\").default} event Event.\n   * @protected\n   */\n  handleTileChange(event) {\n    const tile = /** @type {import(\"../Tile.js\").default} */ (event.target);\n    const uid = getUid(tile);\n    const tileState = tile.getState();\n    let type;\n    if (tileState == TileState.LOADING) {\n      this.tileLoadingKeys_[uid] = true;\n      type = TileEventType.TILELOADSTART;\n    } else if (uid in this.tileLoadingKeys_) {\n      delete this.tileLoadingKeys_[uid];\n      type =\n        tileState == TileState.ERROR\n          ? TileEventType.TILELOADERROR\n          : tileState == TileState.LOADED\n          ? TileEventType.TILELOADEND\n          : undefined;\n    }\n    if (type != undefined) {\n      this.dispatchEvent(new TileSourceEvent(type, tile));\n    }\n  }\n\n  /**\n   * Set the tile load function of the source.\n   * @param {import(\"../Tile.js\").LoadFunction} tileLoadFunction Tile load function.\n   * @api\n   */\n  setTileLoadFunction(tileLoadFunction) {\n    this.tileCache.clear();\n    this.tileLoadFunction = tileLoadFunction;\n    this.changed();\n  }\n\n  /**\n   * Set the tile URL function of the source.\n   * @param {import(\"../Tile.js\").UrlFunction} tileUrlFunction Tile URL function.\n   * @param {string} [key] Optional new tile key for the source.\n   * @api\n   */\n  setTileUrlFunction(tileUrlFunction, key) {\n    this.tileUrlFunction = tileUrlFunction;\n    this.tileCache.pruneExceptNewestZ();\n    if (typeof key !== 'undefined') {\n      this.setKey(key);\n    } else {\n      this.changed();\n    }\n  }\n\n  /**\n   * Set the URL to use for requests.\n   * @param {string} url URL.\n   * @api\n   */\n  setUrl(url) {\n    const urls = expandUrl(url);\n    this.urls = urls;\n    this.setUrls(urls);\n  }\n\n  /**\n   * Set the URLs to use for requests.\n   * @param {Array<string>} urls URLs.\n   * @api\n   */\n  setUrls(urls) {\n    this.urls = urls;\n    const key = urls.join('\\n');\n    if (this.generateTileUrlFunction_) {\n      this.setTileUrlFunction(createFromTemplates(urls, this.tileGrid), key);\n    } else {\n      this.setKey(key);\n    }\n  }\n\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {string|undefined} Tile URL.\n   */\n  tileUrlFunction(tileCoord, pixelRatio, projection) {\n    return undefined;\n  }\n\n  /**\n   * Marks a tile coord as being used, without triggering a load.\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   */\n  useTile(z, x, y) {\n    const tileCoordKey = getKeyZXY(z, x, y);\n    if (this.tileCache.containsKey(tileCoordKey)) {\n      this.tileCache.get(tileCoordKey);\n    }\n  }\n}\n\nexport default UrlTile;\n","/**\n * @module ol/source/TileEventType\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  /**\n   * Triggered when a tile starts loading.\n   * @event module:ol/source/Tile.TileSourceEvent#tileloadstart\n   * @api\n   */\n  TILELOADSTART: 'tileloadstart',\n\n  /**\n   * Triggered when a tile finishes loading, either when its data is loaded,\n   * or when loading was aborted because the tile is no longer needed.\n   * @event module:ol/source/Tile.TileSourceEvent#tileloadend\n   * @api\n   */\n  TILELOADEND: 'tileloadend',\n\n  /**\n   * Triggered if tile loading results in an error.\n   * @event module:ol/source/Tile.TileSourceEvent#tileloaderror\n   * @api\n   */\n  TILELOADERROR: 'tileloaderror',\n};\n","/**\n * @module ol/source/Tile\n */\nimport Event from '../events/Event.js';\nimport Source from './Source.js';\nimport TileCache from '../TileCache.js';\nimport TileState from '../TileState.js';\nimport {abstract} from '../util.js';\nimport {assert} from '../asserts.js';\nimport {equivalent} from '../proj.js';\nimport {getKeyZXY, withinExtentAndZ} from '../tilecoord.js';\nimport {\n  getForProjection as getTileGridForProjection,\n  wrapX,\n} from '../tilegrid.js';\nimport {scale as scaleSize, toSize} from '../size.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] CacheSize.\n * @property {boolean} [opaque=false] Whether the layer is opaque.\n * @property {number} [tilePixelRatio] TilePixelRatio.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection.\n * @property {import(\"./State.js\").default} [state] State.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] TileGrid.\n * @property {boolean} [wrapX=true] WrapX.\n * @property {number} [transition] Transition.\n * @property {string} [key] Key.\n * @property {number} [zDirection=0] ZDirection.\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for sources providing images divided into a tile grid.\n * @abstract\n * @api\n */\nclass TileSource extends Source {\n  /**\n   * @param {Options} options SourceTile source options.\n   */\n  constructor(options) {\n    super({\n      attributions: options.attributions,\n      attributionsCollapsible: options.attributionsCollapsible,\n      projection: options.projection,\n      state: options.state,\n      wrapX: options.wrapX,\n    });\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.opaque_ = options.opaque !== undefined ? options.opaque : false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.tilePixelRatio_ =\n      options.tilePixelRatio !== undefined ? options.tilePixelRatio : 1;\n\n    /**\n     * @protected\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.tileGrid = options.tileGrid !== undefined ? options.tileGrid : null;\n\n    const tileSize = [256, 256];\n    const tileGrid = options.tileGrid;\n    if (tileGrid) {\n      toSize(tileGrid.getTileSize(tileGrid.getMinZoom()), tileSize);\n    }\n\n    /**\n     * @protected\n     * @type {import(\"../TileCache.js\").default}\n     */\n    this.tileCache = new TileCache(options.cacheSize || 0);\n\n    /**\n     * @protected\n     * @type {import(\"../size.js\").Size}\n     */\n    this.tmpSize = [0, 0];\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.key_ = options.key || '';\n\n    /**\n     * @protected\n     * @type {import(\"../Tile.js\").Options}\n     */\n    this.tileOptions = {transition: options.transition};\n\n    /**\n     * zDirection hint, read by the renderer. Indicates which resolution should be used\n     * by a renderer if the views resolution does not match any resolution of the tile source.\n     * If 0, the nearest resolution will be used. If 1, the nearest lower resolution\n     * will be used. If -1, the nearest higher resolution will be used.\n     * @type {number}\n     */\n    this.zDirection = options.zDirection ? options.zDirection : 0;\n  }\n\n  /**\n   * @return {boolean} Can expire cache.\n   */\n  canExpireCache() {\n    return this.tileCache.canExpireCache();\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @param {!Object<string, boolean>} usedTiles Used tiles.\n   */\n  expireCache(projection, usedTiles) {\n    const tileCache = this.getTileCacheForProjection(projection);\n    if (tileCache) {\n      tileCache.expireCache(usedTiles);\n    }\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @param {number} z Zoom level.\n   * @param {import(\"../TileRange.js\").default} tileRange Tile range.\n   * @param {function(import(\"../Tile.js\").default):(boolean|void)} callback Called with each\n   *     loaded tile.  If the callback returns `false`, the tile will not be\n   *     considered loaded.\n   * @return {boolean} The tile range is fully covered with loaded tiles.\n   */\n  forEachLoadedTile(projection, z, tileRange, callback) {\n    const tileCache = this.getTileCacheForProjection(projection);\n    if (!tileCache) {\n      return false;\n    }\n\n    let covered = true;\n    let tile, tileCoordKey, loaded;\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        tileCoordKey = getKeyZXY(z, x, y);\n        loaded = false;\n        if (tileCache.containsKey(tileCoordKey)) {\n          tile = /** @type {!import(\"../Tile.js\").default} */ (tileCache.get(\n            tileCoordKey\n          ));\n          loaded = tile.getState() === TileState.LOADED;\n          if (loaded) {\n            loaded = callback(tile) !== false;\n          }\n        }\n        if (!loaded) {\n          covered = false;\n        }\n      }\n    }\n    return covered;\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {number} Gutter.\n   */\n  getGutterForProjection(projection) {\n    return 0;\n  }\n\n  /**\n   * Return the key to be used for all tiles in the source.\n   * @return {string} The key for all tiles.\n   * @protected\n   */\n  getKey() {\n    return this.key_;\n  }\n\n  /**\n   * Set the value to be used as the key for all tiles in the source.\n   * @param {string} key The key for tiles.\n   * @protected\n   */\n  setKey(key) {\n    if (this.key_ !== key) {\n      this.key_ = key;\n      this.changed();\n    }\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {boolean} Opaque.\n   */\n  getOpaque(projection) {\n    return this.opaque_;\n  }\n\n  /**\n   * @return {Array<number>} Resolutions.\n   */\n  getResolutions() {\n    return this.tileGrid.getResolutions();\n  }\n\n  /**\n   * @abstract\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../Tile.js\").default} Tile.\n   */\n  getTile(z, x, y, pixelRatio, projection) {\n    return abstract();\n  }\n\n  /**\n   * Return the tile grid of the tile source.\n   * @return {import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n   * @api\n   */\n  getTileGrid() {\n    return this.tileGrid;\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n   */\n  getTileGridForProjection(projection) {\n    if (!this.tileGrid) {\n      return getTileGridForProjection(projection);\n    } else {\n      return this.tileGrid;\n    }\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../TileCache.js\").default} Tile cache.\n   * @protected\n   */\n  getTileCacheForProjection(projection) {\n    assert(\n      equivalent(this.getProjection(), projection),\n      68 // A VectorTile source can only be rendered if it has a projection compatible with the view projection.\n    );\n    return this.tileCache;\n  }\n\n  /**\n   * Get the tile pixel ratio for this source. Subclasses may override this\n   * method, which is meant to return a supported pixel ratio that matches the\n   * provided `pixelRatio` as close as possible.\n   * @param {number} pixelRatio Pixel ratio.\n   * @return {number} Tile pixel ratio.\n   */\n  getTilePixelRatio(pixelRatio) {\n    return this.tilePixelRatio_;\n  }\n\n  /**\n   * @param {number} z Z.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../size.js\").Size} Tile size.\n   */\n  getTilePixelSize(z, pixelRatio, projection) {\n    const tileGrid = this.getTileGridForProjection(projection);\n    const tilePixelRatio = this.getTilePixelRatio(pixelRatio);\n    const tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);\n    if (tilePixelRatio == 1) {\n      return tileSize;\n    } else {\n      return scaleSize(tileSize, tilePixelRatio, this.tmpSize);\n    }\n  }\n\n  /**\n   * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate\n   * is outside the resolution and extent range of the tile grid, `null` will be\n   * returned.\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"../proj/Projection.js\").default} [opt_projection] Projection.\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate to be passed to the tileUrlFunction or\n   *     null if no tile URL should be created for the passed `tileCoord`.\n   */\n  getTileCoordForTileUrlFunction(tileCoord, opt_projection) {\n    const projection =\n      opt_projection !== undefined ? opt_projection : this.getProjection();\n    const tileGrid = this.getTileGridForProjection(projection);\n    if (this.getWrapX() && projection.isGlobal()) {\n      tileCoord = wrapX(tileGrid, tileCoord, projection);\n    }\n    return withinExtentAndZ(tileCoord, tileGrid) ? tileCoord : null;\n  }\n\n  /**\n   * Remove all cached tiles from the source. The next render cycle will fetch new tiles.\n   * @api\n   */\n  clear() {\n    this.tileCache.clear();\n  }\n\n  refresh() {\n    this.clear();\n    super.refresh();\n  }\n\n  /**\n   * Increases the cache size if needed\n   * @param {number} tileCount Minimum number of tiles needed.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   */\n  updateCacheSize(tileCount, projection) {\n    const tileCache = this.getTileCacheForProjection(projection);\n    if (tileCount > tileCache.highWaterMark) {\n      tileCache.highWaterMark = tileCount;\n    }\n  }\n\n  /**\n   * Marks a tile coord as being used, without triggering a load.\n   * @abstract\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   */\n  useTile(z, x, y, projection) {}\n}\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/source/Tile~TileSource} instances are instances of this\n * type.\n */\nexport class TileSourceEvent extends Event {\n  /**\n   * @param {string} type Type.\n   * @param {import(\"../Tile.js\").default} tile The tile.\n   */\n  constructor(type, tile) {\n    super(type);\n\n    /**\n     * The tile related to the event.\n     * @type {import(\"../Tile.js\").default}\n     * @api\n     */\n    this.tile = tile;\n  }\n}\n\nexport default TileSource;\n","/**\n * @module ol/tilegrid\n */\nimport Corner from './extent/Corner.js';\nimport TileGrid from './tilegrid/TileGrid.js';\nimport Units from './proj/Units.js';\nimport {DEFAULT_MAX_ZOOM, DEFAULT_TILE_SIZE} from './tilegrid/common.js';\nimport {METERS_PER_UNIT, get as getProjection} from './proj.js';\nimport {\n  containsCoordinate,\n  createOrUpdate,\n  getCorner,\n  getHeight,\n  getWidth,\n} from './extent.js';\nimport {toSize} from './size.js';\n\n/**\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {!TileGrid} Default tile grid for the\n * passed projection.\n */\nexport function getForProjection(projection) {\n  let tileGrid = projection.getDefaultTileGrid();\n  if (!tileGrid) {\n    tileGrid = createForProjection(projection);\n    projection.setDefaultTileGrid(tileGrid);\n  }\n  return tileGrid;\n}\n\n/**\n * @param {TileGrid} tileGrid Tile grid.\n * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {import(\"./tilecoord.js\").TileCoord} Tile coordinate.\n */\nexport function wrapX(tileGrid, tileCoord, projection) {\n  const z = tileCoord[0];\n  const center = tileGrid.getTileCoordCenter(tileCoord);\n  const projectionExtent = extentFromProjection(projection);\n  if (!containsCoordinate(projectionExtent, center)) {\n    const worldWidth = getWidth(projectionExtent);\n    const worldsAway = Math.ceil(\n      (projectionExtent[0] - center[0]) / worldWidth\n    );\n    center[0] += worldWidth * worldsAway;\n    return tileGrid.getTileCoordForCoordAndZ(center, z);\n  } else {\n    return tileCoord;\n  }\n}\n\n/**\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number} [opt_maxZoom] Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size} [opt_tileSize] Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {import(\"./extent/Corner.js\").default} [opt_corner] Extent corner (default is `'top-left'`).\n * @return {!TileGrid} TileGrid instance.\n */\nexport function createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner) {\n  const corner = opt_corner !== undefined ? opt_corner : Corner.TOP_LEFT;\n\n  const resolutions = resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize);\n\n  return new TileGrid({\n    extent: extent,\n    origin: getCorner(extent, corner),\n    resolutions: resolutions,\n    tileSize: opt_tileSize,\n  });\n}\n\n/**\n * @typedef {Object} XYZOptions\n * @property {import(\"./extent.js\").Extent} [extent] Extent for the tile grid. The origin for an XYZ tile grid is the\n * top-left corner of the extent. If `maxResolution` is not provided the zero level of the grid is defined by the resolution\n * at which one tile fits in the provided extent. If not provided, the extent of the EPSG:3857 projection is used.\n * @property {number} [maxResolution] Resolution at level zero.\n * @property {number} [maxZoom] Maximum zoom. The default is `42`. This determines the number of levels\n * in the grid set. For example, a `maxZoom` of 21 means there are 22 levels in the grid set.\n * @property {number} [minZoom=0] Minimum zoom.\n * @property {number|import(\"./size.js\").Size} [tileSize=[256, 256]] Tile size in pixels.\n */\n\n/**\n * Creates a tile grid with a standard XYZ tiling scheme.\n * @param {XYZOptions} [opt_options] Tile grid options.\n * @return {!TileGrid} Tile grid instance.\n * @api\n */\nexport function createXYZ(opt_options) {\n  const xyzOptions = opt_options || {};\n\n  const extent = xyzOptions.extent || getProjection('EPSG:3857').getExtent();\n\n  const gridOptions = {\n    extent: extent,\n    minZoom: xyzOptions.minZoom,\n    tileSize: xyzOptions.tileSize,\n    resolutions: resolutionsFromExtent(\n      extent,\n      xyzOptions.maxZoom,\n      xyzOptions.tileSize,\n      xyzOptions.maxResolution\n    ),\n  };\n  return new TileGrid(gridOptions);\n}\n\n/**\n * Create a resolutions array from an extent.  A zoom factor of 2 is assumed.\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number} [opt_maxZoom] Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size} [opt_tileSize] Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {number} [opt_maxResolution] Resolution at level zero.\n * @return {!Array<number>} Resolutions array.\n */\nfunction resolutionsFromExtent(\n  extent,\n  opt_maxZoom,\n  opt_tileSize,\n  opt_maxResolution\n) {\n  const maxZoom = opt_maxZoom !== undefined ? opt_maxZoom : DEFAULT_MAX_ZOOM;\n\n  const height = getHeight(extent);\n  const width = getWidth(extent);\n\n  const tileSize = toSize(\n    opt_tileSize !== undefined ? opt_tileSize : DEFAULT_TILE_SIZE\n  );\n  const maxResolution =\n    opt_maxResolution > 0\n      ? opt_maxResolution\n      : Math.max(width / tileSize[0], height / tileSize[1]);\n\n  const length = maxZoom + 1;\n  const resolutions = new Array(length);\n  for (let z = 0; z < length; ++z) {\n    resolutions[z] = maxResolution / Math.pow(2, z);\n  }\n  return resolutions;\n}\n\n/**\n * @param {import(\"./proj.js\").ProjectionLike} projection Projection.\n * @param {number} [opt_maxZoom] Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size} [opt_tileSize] Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {import(\"./extent/Corner.js\").default} [opt_corner] Extent corner (default is `'top-left'`).\n * @return {!TileGrid} TileGrid instance.\n */\nexport function createForProjection(\n  projection,\n  opt_maxZoom,\n  opt_tileSize,\n  opt_corner\n) {\n  const extent = extentFromProjection(projection);\n  return createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner);\n}\n\n/**\n * Generate a tile grid extent from a projection.  If the projection has an\n * extent, it is used.  If not, a global extent is assumed.\n * @param {import(\"./proj.js\").ProjectionLike} projection Projection.\n * @return {import(\"./extent.js\").Extent} Extent.\n */\nexport function extentFromProjection(projection) {\n  projection = getProjection(projection);\n  let extent = projection.getExtent();\n  if (!extent) {\n    const half =\n      (180 * METERS_PER_UNIT[Units.DEGREES]) / projection.getMetersPerUnit();\n    extent = createOrUpdate(-half, -half, half, half);\n  }\n  return extent;\n}\n","/**\n * @module ol/tilegrid/TileGrid\n */\nimport TileRange, {\n  createOrUpdate as createOrUpdateTileRange,\n} from '../TileRange.js';\nimport {DEFAULT_TILE_SIZE} from './common.js';\nimport {assert} from '../asserts.js';\nimport {clamp} from '../math.js';\nimport {createOrUpdate, getTopLeft} from '../extent.js';\nimport {createOrUpdate as createOrUpdateTileCoord} from '../tilecoord.js';\nimport {isSorted, linearFindNearest} from '../array.js';\nimport {toSize} from '../size.js';\n\n/**\n * @private\n * @type {import(\"../tilecoord.js\").TileCoord}\n */\nconst tmpTileCoord = [0, 0, 0];\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../extent.js\").Extent} [extent] Extent for the tile grid. No tiles outside this\n * extent will be requested by {@link module:ol/source/Tile} sources. When no `origin` or\n * `origins` are configured, the `origin` will be set to the top-left corner of the extent.\n * @property {number} [minZoom=0] Minimum zoom.\n * @property {import(\"../coordinate.js\").Coordinate} [origin] The tile grid origin, i.e. where the `x`\n * and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left to right and downwards. If not\n * specified, `extent` or `origins` must be provided.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} [origins] Tile grid origins, i.e. where\n * the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If given, the array length\n * should match the length of the `resolutions` array, i.e. each resolution can have a different\n * origin. Tile coordinates increase left to right and downwards. If not specified, `extent` or\n * `origin` must be provided.\n * @property {!Array<number>} resolutions Resolutions. The array index of each resolution needs\n * to match the zoom level. This means that even if a `minZoom` is configured, the resolutions\n * array will have a length of `maxZoom + 1`.\n * @property {Array<import(\"../size.js\").Size>} [sizes] Number of tile rows and columns\n * of the grid for each zoom level. If specified the values\n * define each zoom level's extent together with the `origin` or `origins`.\n * A grid `extent` can be configured in addition, and will further limit the extent\n * for which tile requests are made by sources. If the bottom-left corner of\n * an extent is used as `origin` or `origins`, then the `y` value must be\n * negative because OpenLayers tile coordinates use the top left as the origin.\n * @property {number|import(\"../size.js\").Size} [tileSize] Tile size.\n * Default is `[256, 256]`.\n * @property {Array<import(\"../size.js\").Size>} [tileSizes] Tile sizes. If given, the array length\n * should match the length of the `resolutions` array, i.e. each resolution can have a different\n * tile size.\n */\n\n/**\n * @classdesc\n * Base class for setting the grid pattern for sources accessing tiled-image\n * servers.\n * @api\n */\nclass TileGrid {\n  /**\n   * @param {Options} options Tile grid options.\n   */\n  constructor(options) {\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.minZoom = options.minZoom !== undefined ? options.minZoom : 0;\n\n    /**\n     * @private\n     * @type {!Array<number>}\n     */\n    this.resolutions_ = options.resolutions;\n    assert(\n      isSorted(\n        this.resolutions_,\n        function (a, b) {\n          return b - a;\n        },\n        true\n      ),\n      17\n    ); // `resolutions` must be sorted in descending order\n\n    // check if we've got a consistent zoom factor and origin\n    let zoomFactor;\n    if (!options.origins) {\n      for (let i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {\n        if (!zoomFactor) {\n          zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];\n        } else {\n          if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {\n            zoomFactor = undefined;\n            break;\n          }\n        }\n      }\n    }\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.zoomFactor_ = zoomFactor;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.maxZoom = this.resolutions_.length - 1;\n\n    /**\n     * @private\n     * @type {import(\"../coordinate.js\").Coordinate}\n     */\n    this.origin_ = options.origin !== undefined ? options.origin : null;\n\n    /**\n     * @private\n     * @type {Array<import(\"../coordinate.js\").Coordinate>}\n     */\n    this.origins_ = null;\n    if (options.origins !== undefined) {\n      this.origins_ = options.origins;\n      assert(this.origins_.length == this.resolutions_.length, 20); // Number of `origins` and `resolutions` must be equal\n    }\n\n    const extent = options.extent;\n\n    if (extent !== undefined && !this.origin_ && !this.origins_) {\n      this.origin_ = getTopLeft(extent);\n    }\n\n    assert(\n      (!this.origin_ && this.origins_) || (this.origin_ && !this.origins_),\n      18\n    ); // Either `origin` or `origins` must be configured, never both\n\n    /**\n     * @private\n     * @type {Array<number|import(\"../size.js\").Size>}\n     */\n    this.tileSizes_ = null;\n    if (options.tileSizes !== undefined) {\n      this.tileSizes_ = options.tileSizes;\n      assert(this.tileSizes_.length == this.resolutions_.length, 19); // Number of `tileSizes` and `resolutions` must be equal\n    }\n\n    /**\n     * @private\n     * @type {number|import(\"../size.js\").Size}\n     */\n    this.tileSize_ =\n      options.tileSize !== undefined\n        ? options.tileSize\n        : !this.tileSizes_\n        ? DEFAULT_TILE_SIZE\n        : null;\n    assert(\n      (!this.tileSize_ && this.tileSizes_) ||\n        (this.tileSize_ && !this.tileSizes_),\n      22\n    ); // Either `tileSize` or `tileSizes` must be configured, never both\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.extent_ = extent !== undefined ? extent : null;\n\n    /**\n     * @private\n     * @type {Array<import(\"../TileRange.js\").default>}\n     */\n    this.fullTileRanges_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../size.js\").Size}\n     */\n    this.tmpSize_ = [0, 0];\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.tmpExtent_ = [0, 0, 0, 0];\n\n    if (options.sizes !== undefined) {\n      this.fullTileRanges_ = options.sizes.map(function (size, z) {\n        const tileRange = new TileRange(\n          Math.min(0, size[0]),\n          Math.max(size[0] - 1, -1),\n          Math.min(0, size[1]),\n          Math.max(size[1] - 1, -1)\n        );\n        if (extent) {\n          const restrictedTileRange = this.getTileRangeForExtentAndZ(extent, z);\n          tileRange.minX = Math.max(restrictedTileRange.minX, tileRange.minX);\n          tileRange.maxX = Math.min(restrictedTileRange.maxX, tileRange.maxX);\n          tileRange.minY = Math.max(restrictedTileRange.minY, tileRange.minY);\n          tileRange.maxY = Math.min(restrictedTileRange.maxY, tileRange.maxY);\n        }\n        return tileRange;\n      }, this);\n    } else if (extent) {\n      this.calculateTileRanges_(extent);\n    }\n  }\n\n  /**\n   * Call a function with each tile coordinate for a given extent and zoom level.\n   *\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} zoom Integer zoom level.\n   * @param {function(import(\"../tilecoord.js\").TileCoord): void} callback Function called with each tile coordinate.\n   * @api\n   */\n  forEachTileCoord(extent, zoom, callback) {\n    const tileRange = this.getTileRangeForExtentAndZ(extent, zoom);\n    for (let i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {\n      for (let j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {\n        callback([zoom, i, j]);\n      }\n    }\n  }\n\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {function(number, import(\"../TileRange.js\").default): boolean} callback Callback.\n   * @param {import(\"../TileRange.js\").default} [opt_tileRange] Temporary import(\"../TileRange.js\").default object.\n   * @param {import(\"../extent.js\").Extent} [opt_extent] Temporary import(\"../extent.js\").Extent object.\n   * @return {boolean} Callback succeeded.\n   */\n  forEachTileCoordParentTileRange(\n    tileCoord,\n    callback,\n    opt_tileRange,\n    opt_extent\n  ) {\n    let tileRange, x, y;\n    let tileCoordExtent = null;\n    let z = tileCoord[0] - 1;\n    if (this.zoomFactor_ === 2) {\n      x = tileCoord[1];\n      y = tileCoord[2];\n    } else {\n      tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);\n    }\n    while (z >= this.minZoom) {\n      if (this.zoomFactor_ === 2) {\n        x = Math.floor(x / 2);\n        y = Math.floor(y / 2);\n        tileRange = createOrUpdateTileRange(x, x, y, y, opt_tileRange);\n      } else {\n        tileRange = this.getTileRangeForExtentAndZ(\n          tileCoordExtent,\n          z,\n          opt_tileRange\n        );\n      }\n      if (callback(z, tileRange)) {\n        return true;\n      }\n      --z;\n    }\n    return false;\n  }\n\n  /**\n   * Get the extent for this tile grid, if it was configured.\n   * @return {import(\"../extent.js\").Extent} Extent.\n   * @api\n   */\n  getExtent() {\n    return this.extent_;\n  }\n\n  /**\n   * Get the maximum zoom level for the grid.\n   * @return {number} Max zoom.\n   * @api\n   */\n  getMaxZoom() {\n    return this.maxZoom;\n  }\n\n  /**\n   * Get the minimum zoom level for the grid.\n   * @return {number} Min zoom.\n   * @api\n   */\n  getMinZoom() {\n    return this.minZoom;\n  }\n\n  /**\n   * Get the origin for the grid at the given zoom level.\n   * @param {number} z Integer zoom level.\n   * @return {import(\"../coordinate.js\").Coordinate} Origin.\n   * @api\n   */\n  getOrigin(z) {\n    if (this.origin_) {\n      return this.origin_;\n    } else {\n      return this.origins_[z];\n    }\n  }\n\n  /**\n   * Get the resolution for the given zoom level.\n   * @param {number} z Integer zoom level.\n   * @return {number} Resolution.\n   * @api\n   */\n  getResolution(z) {\n    return this.resolutions_[z];\n  }\n\n  /**\n   * Get the list of resolutions for the tile grid.\n   * @return {Array<number>} Resolutions.\n   * @api\n   */\n  getResolutions() {\n    return this.resolutions_;\n  }\n\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"../TileRange.js\").default} [opt_tileRange] Temporary import(\"../TileRange.js\").default object.\n   * @param {import(\"../extent.js\").Extent} [opt_extent] Temporary import(\"../extent.js\").Extent object.\n   * @return {import(\"../TileRange.js\").default} Tile range.\n   */\n  getTileCoordChildTileRange(tileCoord, opt_tileRange, opt_extent) {\n    if (tileCoord[0] < this.maxZoom) {\n      if (this.zoomFactor_ === 2) {\n        const minX = tileCoord[1] * 2;\n        const minY = tileCoord[2] * 2;\n        return createOrUpdateTileRange(\n          minX,\n          minX + 1,\n          minY,\n          minY + 1,\n          opt_tileRange\n        );\n      }\n      const tileCoordExtent = this.getTileCoordExtent(\n        tileCoord,\n        opt_extent || this.tmpExtent_\n      );\n      return this.getTileRangeForExtentAndZ(\n        tileCoordExtent,\n        tileCoord[0] + 1,\n        opt_tileRange\n      );\n    }\n    return null;\n  }\n\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {number} z Integer zoom level.\n   * @param {import(\"../TileRange.js\").default} [opt_tileRange] Temporary import(\"../TileRange.js\").default object.\n   * @return {import(\"../TileRange.js\").default} Tile range.\n   */\n  getTileRangeForTileCoordAndZ(tileCoord, z, opt_tileRange) {\n    if (z > this.maxZoom || z < this.minZoom) {\n      return null;\n    }\n\n    const tileCoordZ = tileCoord[0];\n    const tileCoordX = tileCoord[1];\n    const tileCoordY = tileCoord[2];\n\n    if (z === tileCoordZ) {\n      return createOrUpdateTileRange(\n        tileCoordX,\n        tileCoordY,\n        tileCoordX,\n        tileCoordY,\n        opt_tileRange\n      );\n    }\n\n    if (this.zoomFactor_) {\n      const factor = Math.pow(this.zoomFactor_, z - tileCoordZ);\n      const minX = Math.floor(tileCoordX * factor);\n      const minY = Math.floor(tileCoordY * factor);\n      if (z < tileCoordZ) {\n        return createOrUpdateTileRange(minX, minX, minY, minY, opt_tileRange);\n      }\n\n      const maxX = Math.floor(factor * (tileCoordX + 1)) - 1;\n      const maxY = Math.floor(factor * (tileCoordY + 1)) - 1;\n      return createOrUpdateTileRange(minX, maxX, minY, maxY, opt_tileRange);\n    }\n\n    const tileCoordExtent = this.getTileCoordExtent(tileCoord, this.tmpExtent_);\n    return this.getTileRangeForExtentAndZ(tileCoordExtent, z, opt_tileRange);\n  }\n\n  /**\n   * Get the extent for a tile range.\n   * @param {number} z Integer zoom level.\n   * @param {import(\"../TileRange.js\").default} tileRange Tile range.\n   * @param {import(\"../extent.js\").Extent} [opt_extent] Temporary import(\"../extent.js\").Extent object.\n   * @return {import(\"../extent.js\").Extent} Extent.\n   */\n  getTileRangeExtent(z, tileRange, opt_extent) {\n    const origin = this.getOrigin(z);\n    const resolution = this.getResolution(z);\n    const tileSize = toSize(this.getTileSize(z), this.tmpSize_);\n    const minX = origin[0] + tileRange.minX * tileSize[0] * resolution;\n    const maxX = origin[0] + (tileRange.maxX + 1) * tileSize[0] * resolution;\n    const minY = origin[1] + tileRange.minY * tileSize[1] * resolution;\n    const maxY = origin[1] + (tileRange.maxY + 1) * tileSize[1] * resolution;\n    return createOrUpdate(minX, minY, maxX, maxY, opt_extent);\n  }\n\n  /**\n   * Get a tile range for the given extent and integer zoom level.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} z Integer zoom level.\n   * @param {import(\"../TileRange.js\").default} [opt_tileRange] Temporary tile range object.\n   * @return {import(\"../TileRange.js\").default} Tile range.\n   */\n  getTileRangeForExtentAndZ(extent, z, opt_tileRange) {\n    const tileCoord = tmpTileCoord;\n    this.getTileCoordForXYAndZ_(extent[0], extent[3], z, false, tileCoord);\n    const minX = tileCoord[1];\n    const minY = tileCoord[2];\n    this.getTileCoordForXYAndZ_(extent[2], extent[1], z, true, tileCoord);\n    return createOrUpdateTileRange(\n      minX,\n      tileCoord[1],\n      minY,\n      tileCoord[2],\n      opt_tileRange\n    );\n  }\n\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @return {import(\"../coordinate.js\").Coordinate} Tile center.\n   */\n  getTileCoordCenter(tileCoord) {\n    const origin = this.getOrigin(tileCoord[0]);\n    const resolution = this.getResolution(tileCoord[0]);\n    const tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);\n    return [\n      origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution,\n      origin[1] - (tileCoord[2] + 0.5) * tileSize[1] * resolution,\n    ];\n  }\n\n  /**\n   * Get the extent of a tile coordinate.\n   *\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"../extent.js\").Extent} [opt_extent] Temporary extent object.\n   * @return {import(\"../extent.js\").Extent} Extent.\n   * @api\n   */\n  getTileCoordExtent(tileCoord, opt_extent) {\n    const origin = this.getOrigin(tileCoord[0]);\n    const resolution = this.getResolution(tileCoord[0]);\n    const tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);\n    const minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;\n    const minY = origin[1] - (tileCoord[2] + 1) * tileSize[1] * resolution;\n    const maxX = minX + tileSize[0] * resolution;\n    const maxY = minY + tileSize[1] * resolution;\n    return createOrUpdate(minX, minY, maxX, maxY, opt_extent);\n  }\n\n  /**\n   * Get the tile coordinate for the given map coordinate and resolution.  This\n   * method considers that coordinates that intersect tile boundaries should be\n   * assigned the higher tile coordinate.\n   *\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {number} resolution Resolution.\n   * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Destination import(\"../tilecoord.js\").TileCoord object.\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n   * @api\n   */\n  getTileCoordForCoordAndResolution(coordinate, resolution, opt_tileCoord) {\n    return this.getTileCoordForXYAndResolution_(\n      coordinate[0],\n      coordinate[1],\n      resolution,\n      false,\n      opt_tileCoord\n    );\n  }\n\n  /**\n   * Note that this method should not be called for resolutions that correspond\n   * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {number} resolution Resolution (for a non-integer zoom level).\n   * @param {boolean} reverseIntersectionPolicy Instead of letting edge\n   *     intersections go to the higher tile coordinate, let edge intersections\n   *     go to the lower tile coordinate.\n   * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Temporary import(\"../tilecoord.js\").TileCoord object.\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n   * @private\n   */\n  getTileCoordForXYAndResolution_(\n    x,\n    y,\n    resolution,\n    reverseIntersectionPolicy,\n    opt_tileCoord\n  ) {\n    const z = this.getZForResolution(resolution);\n    const scale = resolution / this.getResolution(z);\n    const origin = this.getOrigin(z);\n    const tileSize = toSize(this.getTileSize(z), this.tmpSize_);\n\n    const adjustX = reverseIntersectionPolicy ? 0.5 : 0;\n    const adjustY = reverseIntersectionPolicy ? 0.5 : 0;\n    const xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);\n    const yFromOrigin = Math.floor((origin[1] - y) / resolution + adjustY);\n    let tileCoordX = (scale * xFromOrigin) / tileSize[0];\n    let tileCoordY = (scale * yFromOrigin) / tileSize[1];\n\n    if (reverseIntersectionPolicy) {\n      tileCoordX = Math.ceil(tileCoordX) - 1;\n      tileCoordY = Math.ceil(tileCoordY) - 1;\n    } else {\n      tileCoordX = Math.floor(tileCoordX);\n      tileCoordY = Math.floor(tileCoordY);\n    }\n\n    return createOrUpdateTileCoord(z, tileCoordX, tileCoordY, opt_tileCoord);\n  }\n\n  /**\n   * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,\n   * they should have separate implementations.  This method is for integer zoom\n   * levels.  The other method should only be called for resolutions corresponding\n   * to non-integer zoom levels.\n   * @param {number} x Map x coordinate.\n   * @param {number} y Map y coordinate.\n   * @param {number} z Integer zoom level.\n   * @param {boolean} reverseIntersectionPolicy Instead of letting edge\n   *     intersections go to the higher tile coordinate, let edge intersections\n   *     go to the lower tile coordinate.\n   * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Temporary import(\"../tilecoord.js\").TileCoord object.\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n   * @private\n   */\n  getTileCoordForXYAndZ_(x, y, z, reverseIntersectionPolicy, opt_tileCoord) {\n    const origin = this.getOrigin(z);\n    const resolution = this.getResolution(z);\n    const tileSize = toSize(this.getTileSize(z), this.tmpSize_);\n\n    const adjustX = reverseIntersectionPolicy ? 0.5 : 0;\n    const adjustY = reverseIntersectionPolicy ? 0.5 : 0;\n    const xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);\n    const yFromOrigin = Math.floor((origin[1] - y) / resolution + adjustY);\n    let tileCoordX = xFromOrigin / tileSize[0];\n    let tileCoordY = yFromOrigin / tileSize[1];\n\n    if (reverseIntersectionPolicy) {\n      tileCoordX = Math.ceil(tileCoordX) - 1;\n      tileCoordY = Math.ceil(tileCoordY) - 1;\n    } else {\n      tileCoordX = Math.floor(tileCoordX);\n      tileCoordY = Math.floor(tileCoordY);\n    }\n\n    return createOrUpdateTileCoord(z, tileCoordX, tileCoordY, opt_tileCoord);\n  }\n\n  /**\n   * Get a tile coordinate given a map coordinate and zoom level.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {number} z Zoom level.\n   * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Destination import(\"../tilecoord.js\").TileCoord object.\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n   * @api\n   */\n  getTileCoordForCoordAndZ(coordinate, z, opt_tileCoord) {\n    return this.getTileCoordForXYAndZ_(\n      coordinate[0],\n      coordinate[1],\n      z,\n      false,\n      opt_tileCoord\n    );\n  }\n\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @return {number} Tile resolution.\n   */\n  getTileCoordResolution(tileCoord) {\n    return this.resolutions_[tileCoord[0]];\n  }\n\n  /**\n   * Get the tile size for a zoom level. The type of the return value matches the\n   * `tileSize` or `tileSizes` that the tile grid was configured with. To always\n   * get an `import(\"../size.js\").Size`, run the result through `import(\"../size.js\").Size.toSize()`.\n   * @param {number} z Z.\n   * @return {number|import(\"../size.js\").Size} Tile size.\n   * @api\n   */\n  getTileSize(z) {\n    if (this.tileSize_) {\n      return this.tileSize_;\n    } else {\n      return this.tileSizes_[z];\n    }\n  }\n\n  /**\n   * @param {number} z Zoom level.\n   * @return {import(\"../TileRange.js\").default} Extent tile range for the specified zoom level.\n   */\n  getFullTileRange(z) {\n    if (!this.fullTileRanges_) {\n      return this.extent_\n        ? this.getTileRangeForExtentAndZ(this.extent_, z)\n        : null;\n    } else {\n      return this.fullTileRanges_[z];\n    }\n  }\n\n  /**\n   * @param {number} resolution Resolution.\n   * @param {number} [opt_direction] If 0, the nearest resolution will be used.\n   *     If 1, the nearest lower resolution will be used. If -1, the nearest\n   *     higher resolution will be used. Default is 0.\n   * @return {number} Z.\n   * @api\n   */\n  getZForResolution(resolution, opt_direction) {\n    const z = linearFindNearest(\n      this.resolutions_,\n      resolution,\n      opt_direction || 0\n    );\n    return clamp(z, this.minZoom, this.maxZoom);\n  }\n\n  /**\n   * @param {!import(\"../extent.js\").Extent} extent Extent for this tile grid.\n   * @private\n   */\n  calculateTileRanges_(extent) {\n    const length = this.resolutions_.length;\n    const fullTileRanges = new Array(length);\n    for (let z = this.minZoom; z < length; ++z) {\n      fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);\n    }\n    this.fullTileRanges_ = fullTileRanges;\n  }\n}\n\nexport default TileGrid;\n","/**\n * @module ol/tileurlfunction\n */\nimport {assert} from './asserts.js';\nimport {modulo} from './math.js';\nimport {hash as tileCoordHash} from './tilecoord.js';\n\n/**\n * @param {string} template Template.\n * @param {import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n * @return {import(\"./Tile.js\").UrlFunction} Tile URL function.\n */\nexport function createFromTemplate(template, tileGrid) {\n  const zRegEx = /\\{z\\}/g;\n  const xRegEx = /\\{x\\}/g;\n  const yRegEx = /\\{y\\}/g;\n  const dashYRegEx = /\\{-y\\}/g;\n  return (\n    /**\n     * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile Coordinate.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"./proj/Projection.js\").default} projection Projection.\n     * @return {string|undefined} Tile URL.\n     */\n    function (tileCoord, pixelRatio, projection) {\n      if (!tileCoord) {\n        return undefined;\n      } else {\n        return template\n          .replace(zRegEx, tileCoord[0].toString())\n          .replace(xRegEx, tileCoord[1].toString())\n          .replace(yRegEx, tileCoord[2].toString())\n          .replace(dashYRegEx, function () {\n            const z = tileCoord[0];\n            const range = tileGrid.getFullTileRange(z);\n            assert(range, 55); // The {-y} placeholder requires a tile grid with extent\n            const y = range.getHeight() - tileCoord[2] - 1;\n            return y.toString();\n          });\n      }\n    }\n  );\n}\n\n/**\n * @param {Array<string>} templates Templates.\n * @param {import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n * @return {import(\"./Tile.js\").UrlFunction} Tile URL function.\n */\nexport function createFromTemplates(templates, tileGrid) {\n  const len = templates.length;\n  const tileUrlFunctions = new Array(len);\n  for (let i = 0; i < len; ++i) {\n    tileUrlFunctions[i] = createFromTemplate(templates[i], tileGrid);\n  }\n  return createFromTileUrlFunctions(tileUrlFunctions);\n}\n\n/**\n * @param {Array<import(\"./Tile.js\").UrlFunction>} tileUrlFunctions Tile URL Functions.\n * @return {import(\"./Tile.js\").UrlFunction} Tile URL function.\n */\nexport function createFromTileUrlFunctions(tileUrlFunctions) {\n  if (tileUrlFunctions.length === 1) {\n    return tileUrlFunctions[0];\n  }\n  return (\n    /**\n     * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile Coordinate.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"./proj/Projection.js\").default} projection Projection.\n     * @return {string|undefined} Tile URL.\n     */\n    function (tileCoord, pixelRatio, projection) {\n      if (!tileCoord) {\n        return undefined;\n      } else {\n        const h = tileCoordHash(tileCoord);\n        const index = modulo(h, tileUrlFunctions.length);\n        return tileUrlFunctions[index](tileCoord, pixelRatio, projection);\n      }\n    }\n  );\n}\n\n/**\n * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @param {number} pixelRatio Pixel ratio.\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {string|undefined} Tile URL.\n */\nexport function nullTileUrlFunction(tileCoord, pixelRatio, projection) {\n  return undefined;\n}\n\n/**\n * @param {string} url URL.\n * @return {Array<string>} Array of urls.\n */\nexport function expandUrl(url) {\n  const urls = [];\n  let match = /\\{([a-z])-([a-z])\\}/.exec(url);\n  if (match) {\n    // char range\n    const startCharCode = match[1].charCodeAt(0);\n    const stopCharCode = match[2].charCodeAt(0);\n    let charCode;\n    for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {\n      urls.push(url.replace(match[0], String.fromCharCode(charCode)));\n    }\n    return urls;\n  }\n  match = /\\{(\\d+)-(\\d+)\\}/.exec(url);\n  if (match) {\n    // number range\n    const stop = parseInt(match[2], 10);\n    for (let i = parseInt(match[1], 10); i <= stop; i++) {\n      urls.push(url.replace(match[0], i.toString()));\n    }\n    return urls;\n  }\n  urls.push(url);\n  return urls;\n}\n"],"names":["$ff8235042efbfb69f46b35131190fa2b$export$bd9c1867755cf54e","$ff8235042efbfb69f46b35131190fa2b$export$9099ad97b570f7c","_super","OSM","opt_options","attributions","options","undefined","crossOrigin","url","call","this","attributionsCollapsible","cacheSize","imageSmoothing","maxZoom","opaque","reprojectionErrorThreshold","tileLoadFunction","transition","wrapX","$ff8235042efbfb69f46b35131190fa2b$var$__extends","$7HPSR","default","$fd3ab3577c0c67d5f04f77f7494fe563$export$9099ad97b570f7c","XYZ","projection","tileGrid","$lH692","createXYZ","extent","extentFromProjection","maxResolution","minZoom","tileSize","tilePixelRatio","tileUrlFunction","urls","zDirection","$fd3ab3577c0c67d5f04f77f7494fe563$var$__extends","$7mdfN","$f1c529d0542d6a8d6fa77a64fa516101$var$defaultTileLoadFunction","imageTile","src","getImage","$f1c529d0542d6a8d6fa77a64fa516101$export$9099ad97b570f7c","TileImage","_this","state","key","tileClass","$3c9Cv","tileCacheForProjection","tileGridForProjection","reprojectionErrorThreshold_","contextOptions_","$6OFkd","IMAGE_SMOOTHING_DISABLED","renderReprojectionEdges_","$f1c529d0542d6a8d6fa77a64fa516101$var$__extends","prototype","canExpireCache","$6ee7O","ENABLE_RASTER_REPROJECTION","tileCache","expireCache","usedTiles","usedTileCache","getTileCacheForProjection","id","getContextOptions","getGutterForProjection","getProjection","$2vjin","equivalent","getGutter","getKey","JSON","stringify","getOpaque","getTileGridForProjection","thisProj","projKey","$6fegY","getUid","getForProjection","$3ZuCK","highWaterMark","createTile_","z","x","y","pixelRatio","tileCoord","urlTileCoord","getTileCoordForTileUrlFunction","tileUrl","tile","$dgki0","IDLE","EMPTY","tileOptions","addEventListener","$65ADj","CHANGE","handleTileChange","bind","getTile","sourceProjection","cache","tileCoordKey","$68k5U","containsKey","get","sourceTileGrid","targetTileGrid","wrappedTileCoord","newTile","$4CBNI","getTilePixelRatio","z1","x1","y1","pixelRatio1","getTileInternal","interimTile","refreshInterimChain","replace","set","getKeyZXY","getState","setRenderReprojectionEdges","render","clear","changed","setTileGridForProjection","tilegrid","proj","$38yss","$69031f3b45b1bb2d223c45e6bbe47b36$export$9099ad97b570f7c","ImageTile","crossOrigin_","src_","image_","Image","unlisten_","tileLoadFunction_","$69031f3b45b1bb2d223c45e6bbe47b36$var$__extends","handleImageError_","ctx","ERROR","unlistenImage_","$4eVqD","createCanvasContext2D","fillStyle","fillRect","canvas","handleImageLoad_","image","naturalWidth","naturalHeight","LOADED","load","LOADING","$1s8C5","listenImage","$3mLAE","$6ea2e09c0ee686e4fcf344e90f929221$export$9099ad97b570f7c","Tile","hifi","transition_","transitionStarts_","$6ea2e09c0ee686e4fcf344e90f929221$var$__extends","dispatchEvent","release","getInterimTile","prev","getTileCoord","setState","Error","abstract","getAlpha","time","start","delta","$46UD2","easeIn","inTransition","endTransition","$4GA14","$97e37be8733b1927a1ed959b854a8d18$export$9099ad97b570f7c","ReprojTile","sourceProj","targetProj","gutter","getTileFunction","opt_errorThreshold","opt_renderEdges","opt_contextOptions","renderEdges_","pixelRatio_","gutter_","canvas_","sourceTileGrid_","targetTileGrid_","wrappedTileCoord_","sourceTiles_","sourcesListenerKeys_","sourceZ_","targetExtent","getTileCoordExtent","maxTargetExtent","getExtent","maxSourceExtent","limitedTargetExtent","$4lmw7","getIntersection","getArea","sourceProjExtent","targetResolution","getResolution","sourceResolution","$3QjR9","calculateSourceExtentResolution","isFinite","errorThresholdInPixels","ERROR_THRESHOLD","triangulation_","$1Lyf3","getTriangles","length","getZForResolution","sourceExtent","calculateSourceExtent","canWrapX","$4qq0p","clamp","sourceRange","getTileRangeForExtentAndZ","srcX","minX","maxX","srcY","minY","maxY","push","$97e37be8733b1927a1ed959b854a8d18$var$__extends","reproject_","sources","forEach","i","arr","size","getTileSize","width","height","leftToLoad_1","sourceListenKey_1","$3H2uZ","listen","e","state1","unlistenByKey","unlistenSources_","setTimeout","$ccae6107414727602b88e317bb258801$export$b13dc73603ac3121","$ccae6107414727602b88e317bb258801$export$8d8dd84cf36b9041","$3a0ea260bd0161734cb5e603b9086c9d$export$9099ad97b570f7c","Triangulation","errorThreshold","opt_destinationResolution","sourceProj_","targetProj_","transformInvCache","transformInv","getTransform","transformInv_","c","maxSourceExtent_","errorThresholdSquared_","triangles_","wrapsXInSource_","canWrapXInSource_","getWidth","sourceWorldWidth_","targetWorldWidth_","destinationTopLeft","getTopLeft","destinationTopRight","getTopRight","destinationBottomRight","getBottomRight","destinationBottomLeft","getBottomLeft","sourceTopLeft","sourceTopRight","sourceBottomRight","sourceBottomLeft","maxSubdivision","Math","max","ceil","log2","addQuad_","leftBound_1","Infinity","triangle","min","source","newTriangle","addTriangle_","a","b","aSrc","bSrc","cSrc","target","d","dSrc","sourceQuadExtent","boundingExtent","sourceCoverageX","sourceWorldWidth","wrapsX","needsSubdivision","isGlobal","targetQuadExtent","intersects","isNotFinite","center","centerSrc","dx","modulo","dy","abs","bc","bcSrc","da","daSrc","ab","abSrc","cd","cdSrc","createEmpty","extendCoordinate","$7e4c33869bbc09ad771e58efcd7791e2$var$brokenDiagonalRendering_","$7e4c33869bbc09ad771e58efcd7791e2$var$drawTestTriangle","u1","v1","u2","v2","beginPath","moveTo","lineTo","closePath","save","clip","restore","$7e4c33869bbc09ad771e58efcd7791e2$var$verifyBrokenDiagonalRendering","data","offset","$7e4c33869bbc09ad771e58efcd7791e2$export$fbbff54b3c32db8d","targetCenter","sourceCenter","transform","getPointResolution","targetMetersPerUnit","getMetersPerUnit","sourceMetersPerUnit","containsCoordinate","compensationFactor","$7e4c33869bbc09ad771e58efcd7791e2$export$ed73ddd0371d87e2","getCenter","forEachCorner","corner","$7e4c33869bbc09ad771e58efcd7791e2$export$792a797b69be0d58","triangulation","context","round","$6RQ94","assign","pixelRound","value","scale","globalCompositeOperation","sourceDataExtent","extend","canvasWidthInUnits","canvasHeightInUnits","getHeight","stitchContext","stitchScale","xPos","yPos","srcWidth","srcHeight","drawImage","targetTopLeft","x0","y0","x2","y2","u0","v0","sourceNumericalShiftX","sourceNumericalShiftY","augmentedMatrix","affineCoefs","solveLinearSystem","document","createElement","getContext","getImageData","$7e4c33869bbc09ad771e58efcd7791e2$var$isBrokenDiagonalRendering","ud","vd","step","steps","translate","strokeStyle","lineWidth","stroke","$dffde8f1acde674bc74a24601c2788a7$export$5f986e3acaff8610","imageSmoothingEnabled","msImageSmoothingEnabled","$8328c42c04c9adada69111ec662476d9$export$9099ad97b570f7c","TileCache","$8328c42c04c9adada69111ec662476d9$var$__extends","peekLast","pop","pruneExceptNewestZ","getCount","peekFirstKey","fromKey","remove","$uoaF3","$101ae72fedfe330e8897d118e958a8b6$export$9099ad97b570f7c","LRUCache","opt_highWaterMark","count_","entries_","oldest_","newest_","hasOwnProperty","f","entry","value_","key_","newer","$1mHUI","assert","older","getKeys","keys","Array","getValues","values","peekLastKey","setSize","$c98d704946f2a3a0e1335bd43bccb465$export$ea8082d0226d35a5","opt_tileCoord","$c98d704946f2a3a0e1335bd43bccb465$export$1039fb0288fd71e3","$c98d704946f2a3a0e1335bd43bccb465$export$a0f0ccbe5bbc0789","$c98d704946f2a3a0e1335bd43bccb465$export$5208a752d34424e5","split","map","Number","$c98d704946f2a3a0e1335bd43bccb465$export$4639c7f2947f4458","$c98d704946f2a3a0e1335bd43bccb465$export$b46b80619528d4e5","getMinZoom","getMaxZoom","tileRange","getFullTileRange","containsXY","$671acdd0ca89710db49a7e8e41335e8e$export$9099ad97b570f7c","UrlTile","generateTileUrlFunction_","setUrls","setUrl","tileLoadingKeys_","$671acdd0ca89710db49a7e8e41335e8e$var$__extends","getTileLoadFunction","getTileUrlFunction","Object","getPrototypeOf","getUrls","event","type","uid","tileState","$3oO9h","TILELOADSTART","TILELOADERROR","TILELOADEND","$6gvkl","TileSourceEvent","setTileLoadFunction","setTileUrlFunction","setKey","$7pR3g","expandUrl","join","createFromTemplates","useTile","$6fb7cf65abcfc8d879372ec2dca0d0b8$export$9099ad97b570f7c","$cde35ab3df9629f8ffd26ea2f187b41e$var$TileSource","TileSource","opaque_","tilePixelRatio_","$43BI1","toSize","tmpSize","$cde35ab3df9629f8ffd26ea2f187b41e$var$__extends","forEachLoadedTile","callback","loaded","covered","getResolutions","getTileGrid","getTilePixelSize","opt_projection","getWrapX","withinExtentAndZ","refresh","updateCacheSize","tileCount","$3f7LD","$cde35ab3df9629f8ffd26ea2f187b41e$export$8434c8db61edbf9d","$0qSof","$cde35ab3df9629f8ffd26ea2f187b41e$export$9099ad97b570f7c","$0b7f50deff6bfc90c8b239d5ceca7010$export$115502f69f929231","getDefaultTileGrid","opt_maxZoom","opt_tileSize","opt_corner","$4nuo6","TOP_LEFT","resolutions","$0b7f50deff6bfc90c8b239d5ceca7010$var$resolutionsFromExtent","$ttXX0","origin","getCorner","$0b7f50deff6bfc90c8b239d5ceca7010$export$57c49ef1657592d4","$0b7f50deff6bfc90c8b239d5ceca7010$export$9666e825b22d806d","$0b7f50deff6bfc90c8b239d5ceca7010$export$6dfef52f91d4f582","setDefaultTileGrid","$0b7f50deff6bfc90c8b239d5ceca7010$export$5a0d9577a24f3c5b","getTileCoordCenter","projectionExtent","worldWidth","worldsAway","getTileCoordForCoordAndZ","$0b7f50deff6bfc90c8b239d5ceca7010$export$5731532c605ee56","xyzOptions","gridOptions","opt_maxResolution","$5TQMR","DEFAULT_MAX_ZOOM","DEFAULT_TILE_SIZE","pow","half","METERS_PER_UNIT","$6MSva","DEGREES","createOrUpdate","$0f9feaa19e1db86e91525f400c1bbfa1$var$tmpTileCoord","$0f9feaa19e1db86e91525f400c1bbfa1$export$9099ad97b570f7c","TileGrid","zoomFactor","resolutions_","$3MevS","isSorted","origins","ii","zoomFactor_","origin_","origins_","tileSizes_","tileSizes","tileSize_","extent_","fullTileRanges_","tmpSize_","tmpExtent_","sizes","$3f7wY","restrictedTileRange","calculateTileRanges_","forEachTileCoord","zoom","j","jj","forEachTileCoordParentTileRange","opt_tileRange","opt_extent","tileCoordExtent","floor","getOrigin","getTileCoordChildTileRange","getTileRangeForTileCoordAndZ","tileCoordZ","tileCoordX","tileCoordY","factor","getTileRangeExtent","resolution","getTileCoordForXYAndZ_","getTileCoordForCoordAndResolution","coordinate","getTileCoordForXYAndResolution_","reverseIntersectionPolicy","adjustX","adjustY","xFromOrigin","yFromOrigin","getTileCoordResolution","opt_direction","linearFindNearest","fullTileRanges","$f3b33fdefe65058178a4b532c7b3f14b$export$ee162149bf998c0f","template","zRegEx","xRegEx","yRegEx","dashYRegEx","toString","range","$f3b33fdefe65058178a4b532c7b3f14b$export$2d2faeb2e9d58b93","templates","len","tileUrlFunctions","h","hash","index","$f3b33fdefe65058178a4b532c7b3f14b$export$c6a04e0c49b28953","$f3b33fdefe65058178a4b532c7b3f14b$export$47abe479fba0e55d","match","exec","startCharCode","charCodeAt","stopCharCode","charCode","String","fromCharCode","stop_1","parseInt"],"version":3,"file":"extent-constrained.4d5b3e95.js.map"}