{"mappings":"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","sources":["node_modules/ol/src/layer/Heatmap.js","node_modules/ol/src/renderer/webgl/PointsLayer.js","node_modules/ol/src/source/VectorEventType.js","node_modules/ol/src/webgl/Buffer.js","node_modules/ol/src/webgl.js","node_modules/ol/src/renderer/webgl/Layer.js","node_modules/ol/src/webgl/Helper.js","node_modules/ol/src/webgl/ContextEventType.js","node_modules/ol/src/webgl/PostProcessingPass.js","node_modules/ol/src/vec/mat4.js","node_modules/ol/src/webgl/RenderTarget.js","node_modules/ol/src/worker/webgl.js"],"sourcesContent":["/**\n * @module ol/layer/Heatmap\n */\nimport VectorLayer from './Vector.js';\nimport WebGLPointsLayerRenderer from '../renderer/webgl/PointsLayer.js';\nimport {assign} from '../obj.js';\nimport {clamp} from '../math.js';\nimport {createCanvasContext2D} from '../dom.js';\nimport {getChangeEventType} from '../Object.js';\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {Array<string>} [gradient=['#00f', '#0ff', '#0f0', '#ff0', '#f00']] The color gradient\n * of the heatmap, specified as an array of CSS color strings.\n * @property {number} [radius=8] Radius size in pixels.\n * @property {number} [blur=15] Blur size in pixels.\n * @property {string|function(import(\"../Feature.js\").default):number} [weight='weight'] The feature\n * attribute to use for the weight or a function that returns a weight from a feature. Weight values\n * should range from 0 to 1 (and values outside will be clamped to that range).\n * @property {import(\"../source/Vector.js\").default} [source] Source.\n */\n\n/**\n * @enum {string}\n * @private\n */\nconst Property = {\n  BLUR: 'blur',\n  GRADIENT: 'gradient',\n  RADIUS: 'radius',\n};\n\n/**\n * @const\n * @type {Array<string>}\n */\nconst DEFAULT_GRADIENT = ['#00f', '#0ff', '#0f0', '#ff0', '#f00'];\n\n/**\n * @classdesc\n * Layer for rendering vector data as a heatmap.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @fires import(\"../render/Event.js\").RenderEvent\n * @extends {VectorLayer<import(\"../source/Vector.js\").default>}\n * @api\n */\nclass Heatmap extends VectorLayer {\n  /**\n   * @param {Options} [opt_options] Options.\n   */\n  constructor(opt_options) {\n    const options = opt_options ? opt_options : {};\n\n    const baseOptions = assign({}, options);\n\n    delete baseOptions.gradient;\n    delete baseOptions.radius;\n    delete baseOptions.blur;\n    delete baseOptions.weight;\n    super(baseOptions);\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.gradient_ = null;\n\n    this.addEventListener(\n      getChangeEventType(Property.GRADIENT),\n      this.handleGradientChanged_\n    );\n\n    this.setGradient(options.gradient ? options.gradient : DEFAULT_GRADIENT);\n\n    this.setBlur(options.blur !== undefined ? options.blur : 15);\n\n    this.setRadius(options.radius !== undefined ? options.radius : 8);\n\n    const weight = options.weight ? options.weight : 'weight';\n    if (typeof weight === 'string') {\n      this.weightFunction_ = function (feature) {\n        return feature.get(weight);\n      };\n    } else {\n      this.weightFunction_ = weight;\n    }\n\n    // For performance reasons, don't sort the features before rendering.\n    // The render order is not relevant for a heatmap representation.\n    this.setRenderOrder(null);\n  }\n\n  /**\n   * Return the blur size in pixels.\n   * @return {number} Blur size in pixels.\n   * @api\n   * @observable\n   */\n  getBlur() {\n    return /** @type {number} */ (this.get(Property.BLUR));\n  }\n\n  /**\n   * Return the gradient colors as array of strings.\n   * @return {Array<string>} Colors.\n   * @api\n   * @observable\n   */\n  getGradient() {\n    return /** @type {Array<string>} */ (this.get(Property.GRADIENT));\n  }\n\n  /**\n   * Return the size of the radius in pixels.\n   * @return {number} Radius size in pixel.\n   * @api\n   * @observable\n   */\n  getRadius() {\n    return /** @type {number} */ (this.get(Property.RADIUS));\n  }\n\n  /**\n   * @private\n   */\n  handleGradientChanged_() {\n    this.gradient_ = createGradient(this.getGradient());\n  }\n\n  /**\n   * Set the blur size in pixels.\n   * @param {number} blur Blur size in pixels.\n   * @api\n   * @observable\n   */\n  setBlur(blur) {\n    this.set(Property.BLUR, blur);\n  }\n\n  /**\n   * Set the gradient colors as array of strings.\n   * @param {Array<string>} colors Gradient.\n   * @api\n   * @observable\n   */\n  setGradient(colors) {\n    this.set(Property.GRADIENT, colors);\n  }\n\n  /**\n   * Set the size of the radius in pixels.\n   * @param {number} radius Radius size in pixel.\n   * @api\n   * @observable\n   */\n  setRadius(radius) {\n    this.set(Property.RADIUS, radius);\n  }\n\n  /**\n   * Create a renderer for this layer.\n   * @return {WebGLPointsLayerRenderer} A layer renderer.\n   */\n  createRenderer() {\n    return new WebGLPointsLayerRenderer(this, {\n      className: this.getClassName(),\n      attributes: [\n        {\n          name: 'weight',\n          callback: function (feature) {\n            const weight = this.weightFunction_(feature);\n            return weight !== undefined ? clamp(weight, 0, 1) : 1;\n          }.bind(this),\n        },\n      ],\n      vertexShader: `\n        precision mediump float;\n        uniform mat4 u_projectionMatrix;\n        uniform mat4 u_offsetScaleMatrix;\n        uniform float u_size;\n        attribute vec2 a_position;\n        attribute float a_index;\n        attribute float a_weight;\n\n        varying vec2 v_texCoord;\n        varying float v_weight;\n\n        void main(void) {\n          mat4 offsetMatrix = u_offsetScaleMatrix;\n          float offsetX = a_index == 0.0 || a_index == 3.0 ? -u_size / 2.0 : u_size / 2.0;\n          float offsetY = a_index == 0.0 || a_index == 1.0 ? -u_size / 2.0 : u_size / 2.0;\n          vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);\n          gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\n          float u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;\n          float v = a_index == 0.0 || a_index == 1.0 ? 0.0 : 1.0;\n          v_texCoord = vec2(u, v);\n          v_weight = a_weight;\n        }`,\n      fragmentShader: `\n        precision mediump float;\n        uniform float u_blurSlope;\n\n        varying vec2 v_texCoord;\n        varying float v_weight;\n\n        void main(void) {\n          vec2 texCoord = v_texCoord * 2.0 - vec2(1.0, 1.0);\n          float sqRadius = texCoord.x * texCoord.x + texCoord.y * texCoord.y;\n          float value = (1.0 - sqrt(sqRadius)) * u_blurSlope;\n          float alpha = smoothstep(0.0, 1.0, value) * v_weight;\n          gl_FragColor = vec4(alpha, alpha, alpha, alpha);\n        }`,\n      hitVertexShader: `\n        precision mediump float;\n        uniform mat4 u_projectionMatrix;\n        uniform mat4 u_offsetScaleMatrix;\n        uniform float u_size;\n        attribute vec2 a_position;\n        attribute float a_index;\n        attribute float a_weight;\n        attribute vec4 a_hitColor;\n\n        varying vec2 v_texCoord;\n        varying float v_weight;\n        varying vec4 v_hitColor;\n\n        void main(void) {\n          mat4 offsetMatrix = u_offsetScaleMatrix;\n          float offsetX = a_index == 0.0 || a_index == 3.0 ? -u_size / 2.0 : u_size / 2.0;\n          float offsetY = a_index == 0.0 || a_index == 1.0 ? -u_size / 2.0 : u_size / 2.0;\n          vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);\n          gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\n          float u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;\n          float v = a_index == 0.0 || a_index == 1.0 ? 0.0 : 1.0;\n          v_texCoord = vec2(u, v);\n          v_hitColor = a_hitColor;\n          v_weight = a_weight;\n        }`,\n      hitFragmentShader: `\n        precision mediump float;\n        uniform float u_blurSlope;\n\n        varying vec2 v_texCoord;\n        varying float v_weight;\n        varying vec4 v_hitColor;\n\n        void main(void) {\n          vec2 texCoord = v_texCoord * 2.0 - vec2(1.0, 1.0);\n          float sqRadius = texCoord.x * texCoord.x + texCoord.y * texCoord.y;\n          float value = (1.0 - sqrt(sqRadius)) * u_blurSlope;\n          float alpha = smoothstep(0.0, 1.0, value) * v_weight;\n          if (alpha < 0.05) {\n            discard;\n          }\n\n          gl_FragColor = v_hitColor;\n        }`,\n      uniforms: {\n        u_size: function () {\n          return (this.get(Property.RADIUS) + this.get(Property.BLUR)) * 2;\n        }.bind(this),\n        u_blurSlope: function () {\n          return (\n            this.get(Property.RADIUS) / Math.max(1, this.get(Property.BLUR))\n          );\n        }.bind(this),\n      },\n      postProcesses: [\n        {\n          fragmentShader: `\n            precision mediump float;\n\n            uniform sampler2D u_image;\n            uniform sampler2D u_gradientTexture;\n\n            varying vec2 v_texCoord;\n\n            void main() {\n              vec4 color = texture2D(u_image, v_texCoord);\n              gl_FragColor.a = color.a;\n              gl_FragColor.rgb = texture2D(u_gradientTexture, vec2(0.5, color.a)).rgb;\n              gl_FragColor.rgb *= gl_FragColor.a;\n            }`,\n          uniforms: {\n            u_gradientTexture: function () {\n              return this.gradient_;\n            }.bind(this),\n          },\n        },\n      ],\n    });\n  }\n\n  renderDeclutter() {}\n}\n\n/**\n * @param {Array<string>} colors A list of colored.\n * @return {HTMLCanvasElement} canvas with gradient texture.\n */\nfunction createGradient(colors) {\n  const width = 1;\n  const height = 256;\n  const context = createCanvasContext2D(width, height);\n\n  const gradient = context.createLinearGradient(0, 0, width, height);\n  const step = 1 / (colors.length - 1);\n  for (let i = 0, ii = colors.length; i < ii; ++i) {\n    gradient.addColorStop(i * step, colors[i]);\n  }\n\n  context.fillStyle = gradient;\n  context.fillRect(0, 0, width, height);\n\n  return context.canvas;\n}\n\nexport default Heatmap;\n","/**\n * @module ol/renderer/webgl/PointsLayer\n */\nimport BaseVector from '../../layer/BaseVector.js';\nimport GeometryType from '../../geom/GeometryType.js';\nimport VectorEventType from '../../source/VectorEventType.js';\nimport ViewHint from '../../ViewHint.js';\nimport WebGLArrayBuffer from '../../webgl/Buffer.js';\nimport WebGLLayerRenderer, {\n  WebGLWorkerMessageType,\n  colorDecodeId,\n  colorEncodeId,\n} from './Layer.js';\nimport WebGLRenderTarget from '../../webgl/RenderTarget.js';\nimport {ARRAY_BUFFER, DYNAMIC_DRAW, ELEMENT_ARRAY_BUFFER} from '../../webgl.js';\nimport {AttributeType, DefaultUniform} from '../../webgl/Helper.js';\nimport {\n  apply as applyTransform,\n  create as createTransform,\n  makeInverse as makeInverseTransform,\n  multiply as multiplyTransform,\n} from '../../transform.js';\nimport {assert} from '../../asserts.js';\nimport {buffer, createEmpty, equals} from '../../extent.js';\nimport {create as createWebGLWorker} from '../../worker/webgl.js';\nimport {getUid} from '../../util.js';\nimport {listen, unlistenByKey} from '../../events.js';\n\n/**\n * @typedef {Object} CustomAttribute A description of a custom attribute to be passed on to the GPU, with a value different\n * for each feature.\n * @property {string} name Attribute name.\n * @property {function(import(\"../../Feature\").default, Object<string, *>):number} callback This callback computes the numerical value of the\n * attribute for a given feature (properties are available as 2nd arg for quicker access).\n */\n\n/**\n * @typedef {Object} FeatureCacheItem Object that holds a reference to a feature, its geometry and properties. Used to optimize\n * rebuildBuffers by accessing these objects quicker.\n * @property {import(\"../../Feature\").default} feature Feature\n * @property {Object<string, *>} properties Feature properties\n * @property {import(\"../../geom\").Geometry} geometry Feature geometry\n */\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the canvas element.\n * @property {Array<CustomAttribute>} [attributes] These attributes will be read from the features in the source and then\n * passed to the GPU. The `name` property of each attribute will serve as its identifier:\n *  * In the vertex shader as an `attribute` by prefixing it with `a_`\n *  * In the fragment shader as a `varying` by prefixing it with `v_`\n * Please note that these can only be numerical values.\n * @property {string} vertexShader Vertex shader source, mandatory.\n * @property {string} fragmentShader Fragment shader source, mandatory.\n * @property {string} [hitVertexShader] Vertex shader source for hit detection rendering.\n * @property {string} [hitFragmentShader] Fragment shader source for hit detection rendering.\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process steps\n * Please note that `u_texture` is reserved for the main texture slot.\n * @property {Array<import(\"./Layer\").PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n\n/**\n * @classdesc\n * WebGL vector renderer optimized for points.\n * All features will be rendered as quads (two triangles forming a square). New data will be flushed to the GPU\n * every time the vector source changes.\n *\n * You need to provide vertex and fragment shaders for rendering. This can be done using\n * {@link module:ol/webgl/ShaderBuilder} utilities. These shaders shall expect a `a_position` attribute\n * containing the screen-space projected center of the quad, as well as a `a_index` attribute\n * whose value (0, 1, 2 or 3) indicates which quad vertex is currently getting processed (see structure below).\n *\n * To include variable attributes in the shaders, you need to declare them using the `attributes` property of\n * the options object like so:\n * ```js\n * new WebGLPointsLayerRenderer(layer, {\n *   attributes: [\n *     {\n *       name: 'size',\n *       callback: function(feature) {\n *         // compute something with the feature\n *       }\n *     },\n *     {\n *       name: 'weight',\n *       callback: function(feature) {\n *         // compute something with the feature\n *       }\n *     },\n *   ],\n *   vertexShader:\n *     // shader using attribute a_weight and a_size\n *   fragmentShader:\n *     // shader using varying v_weight and v_size\n * ```\n *\n * To enable hit detection, you must as well provide dedicated shaders using the `hitVertexShader`\n * and `hitFragmentShader` properties. These shall expect the `a_hitColor` attribute to contain\n * the final color that will have to be output for hit detection to work.\n *\n * The following uniform is used for the main texture: `u_texture`.\n *\n * Please note that the main shader output should have premultiplied alpha, otherwise visual anomalies may occur.\n *\n * Points are rendered as quads with the following structure:\n *\n * ```\n *   (u0, v1)      (u1, v1)\n *  [3]----------[2]\n *   |`           |\n *   |  `         |\n *   |    `       |\n *   |      `     |\n *   |        `   |\n *   |          ` |\n *  [0]----------[1]\n *   (u0, v0)      (u1, v0)\n *  ```\n *\n * This uses {@link module:ol/webgl/Helper~WebGLHelper} internally.\n *\n * @api\n */\nclass WebGLPointsLayerRenderer extends WebGLLayerRenderer {\n  /**\n   * @param {import(\"../../layer/Layer.js\").default} layer Layer.\n   * @param {Options} options Options.\n   */\n  constructor(layer, options) {\n    const uniforms = options.uniforms || {};\n    const projectionMatrixTransform = createTransform();\n    uniforms[DefaultUniform.PROJECTION_MATRIX] = projectionMatrixTransform;\n\n    super(layer, {\n      className: options.className,\n      uniforms: uniforms,\n      postProcesses: options.postProcesses,\n    });\n\n    this.sourceRevision_ = -1;\n\n    this.verticesBuffer_ = new WebGLArrayBuffer(ARRAY_BUFFER, DYNAMIC_DRAW);\n    this.hitVerticesBuffer_ = new WebGLArrayBuffer(ARRAY_BUFFER, DYNAMIC_DRAW);\n    this.indicesBuffer_ = new WebGLArrayBuffer(\n      ELEMENT_ARRAY_BUFFER,\n      DYNAMIC_DRAW\n    );\n\n    this.program_ = this.helper.getProgram(\n      options.fragmentShader,\n      options.vertexShader\n    );\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.hitDetectionEnabled_ =\n      options.hitFragmentShader && options.hitVertexShader ? true : false;\n\n    this.hitProgram_ =\n      this.hitDetectionEnabled_ &&\n      this.helper.getProgram(\n        options.hitFragmentShader,\n        options.hitVertexShader\n      );\n\n    const customAttributes = options.attributes\n      ? options.attributes.map(function (attribute) {\n          return {\n            name: 'a_' + attribute.name,\n            size: 1,\n            type: AttributeType.FLOAT,\n          };\n        })\n      : [];\n\n    /**\n     * A list of attributes used by the renderer. By default only the position and\n     * index of the vertex (0 to 3) are required.\n     * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n     */\n    this.attributes = [\n      {\n        name: 'a_position',\n        size: 2,\n        type: AttributeType.FLOAT,\n      },\n      {\n        name: 'a_index',\n        size: 1,\n        type: AttributeType.FLOAT,\n      },\n    ].concat(customAttributes);\n\n    /**\n     * A list of attributes used for hit detection.\n     * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n     */\n    this.hitDetectionAttributes = [\n      {\n        name: 'a_position',\n        size: 2,\n        type: AttributeType.FLOAT,\n      },\n      {\n        name: 'a_index',\n        size: 1,\n        type: AttributeType.FLOAT,\n      },\n      {\n        name: 'a_hitColor',\n        size: 4,\n        type: AttributeType.FLOAT,\n      },\n      {\n        name: 'a_featureUid',\n        size: 1,\n        type: AttributeType.FLOAT,\n      },\n    ].concat(customAttributes);\n\n    this.customAttributes = options.attributes ? options.attributes : [];\n\n    this.previousExtent_ = createEmpty();\n\n    /**\n     * This transform is updated on every frame and is the composition of:\n     * - invert of the world->screen transform that was used when rebuilding buffers (see `this.renderTransform_`)\n     * - current world->screen transform\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.currentTransform_ = projectionMatrixTransform;\n\n    /**\n     * This transform is updated when buffers are rebuilt and converts world space coordinates to screen space\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.renderTransform_ = createTransform();\n\n    /**\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.invertRenderTransform_ = createTransform();\n\n    /**\n     * @type {Float32Array}\n     * @private\n     */\n    this.renderInstructions_ = new Float32Array(0);\n\n    /**\n     * These instructions are used for hit detection\n     * @type {Float32Array}\n     * @private\n     */\n    this.hitRenderInstructions_ = new Float32Array(0);\n\n    /**\n     * @type {WebGLRenderTarget}\n     * @private\n     */\n    this.hitRenderTarget_ =\n      this.hitDetectionEnabled_ && new WebGLRenderTarget(this.helper);\n\n    this.worker_ = createWebGLWorker();\n    this.worker_.addEventListener(\n      'message',\n      /**\n       * @param {*} event Event.\n       * @this {WebGLPointsLayerRenderer}\n       */\n      function (event) {\n        const received = event.data;\n        if (received.type === WebGLWorkerMessageType.GENERATE_BUFFERS) {\n          const projectionTransform = received.projectionTransform;\n          if (received.hitDetection) {\n            this.hitVerticesBuffer_.fromArrayBuffer(received.vertexBuffer);\n            this.helper.flushBufferData(this.hitVerticesBuffer_);\n          } else {\n            this.verticesBuffer_.fromArrayBuffer(received.vertexBuffer);\n            this.helper.flushBufferData(this.verticesBuffer_);\n          }\n          this.indicesBuffer_.fromArrayBuffer(received.indexBuffer);\n          this.helper.flushBufferData(this.indicesBuffer_);\n\n          this.renderTransform_ = projectionTransform;\n          makeInverseTransform(\n            this.invertRenderTransform_,\n            this.renderTransform_\n          );\n          if (received.hitDetection) {\n            this.hitRenderInstructions_ = new Float32Array(\n              event.data.renderInstructions\n            );\n          } else {\n            this.renderInstructions_ = new Float32Array(\n              event.data.renderInstructions\n            );\n          }\n\n          this.getLayer().changed();\n        }\n      }.bind(this)\n    );\n\n    /**\n     * This object will be updated when the source changes. Key is uid.\n     * @type {Object<string, FeatureCacheItem>}\n     * @private\n     */\n    this.featureCache_ = {};\n\n    /**\n     * Amount of features in the cache.\n     * @type {number}\n     * @private\n     */\n    this.featureCount_ = 0;\n\n    const source = this.getLayer().getSource();\n    this.sourceListenKeys_ = [\n      listen(\n        source,\n        VectorEventType.ADDFEATURE,\n        this.handleSourceFeatureAdded_,\n        this\n      ),\n      listen(\n        source,\n        VectorEventType.CHANGEFEATURE,\n        this.handleSourceFeatureChanged_,\n        this\n      ),\n      listen(\n        source,\n        VectorEventType.REMOVEFEATURE,\n        this.handleSourceFeatureDelete_,\n        this\n      ),\n      listen(\n        source,\n        VectorEventType.CLEAR,\n        this.handleSourceFeatureClear_,\n        this\n      ),\n    ];\n    source.forEachFeature(\n      function (feature) {\n        this.featureCache_[getUid(feature)] = {\n          feature: feature,\n          properties: feature.getProperties(),\n          geometry: feature.getGeometry(),\n        };\n        this.featureCount_++;\n      }.bind(this)\n    );\n  }\n\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureAdded_(event) {\n    const feature = event.feature;\n    this.featureCache_[getUid(feature)] = {\n      feature: feature,\n      properties: feature.getProperties(),\n      geometry: feature.getGeometry(),\n    };\n    this.featureCount_++;\n  }\n\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureChanged_(event) {\n    const feature = event.feature;\n    this.featureCache_[getUid(feature)] = {\n      feature: feature,\n      properties: feature.getProperties(),\n      geometry: feature.getGeometry(),\n    };\n  }\n\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureDelete_(event) {\n    const feature = event.feature;\n    delete this.featureCache_[getUid(feature)];\n    this.featureCount_--;\n  }\n\n  /**\n   * @private\n   */\n  handleSourceFeatureClear_() {\n    this.featureCache_ = {};\n    this.featureCount_ = 0;\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @return {HTMLElement} The rendered element.\n   */\n  renderFrame(frameState) {\n    this.preRender(frameState);\n\n    const renderCount = this.indicesBuffer_.getSize();\n    this.helper.drawElements(0, renderCount);\n    this.helper.finalizeDraw(frameState);\n    const canvas = this.helper.getCanvas();\n\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const opacity = layerState.opacity;\n    if (opacity !== parseFloat(canvas.style.opacity)) {\n      canvas.style.opacity = String(opacity);\n    }\n\n    if (this.hitDetectionEnabled_) {\n      this.renderHitDetection(frameState);\n      this.hitRenderTarget_.clearCachedData();\n    }\n\n    this.postRender(frameState);\n\n    return canvas;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    const layer = this.getLayer();\n    const vectorSource = layer.getSource();\n    const viewState = frameState.viewState;\n    const viewNotMoving =\n      !frameState.viewHints[ViewHint.ANIMATING] &&\n      !frameState.viewHints[ViewHint.INTERACTING];\n    const extentChanged = !equals(this.previousExtent_, frameState.extent);\n    const sourceChanged = this.sourceRevision_ < vectorSource.getRevision();\n\n    if (sourceChanged) {\n      this.sourceRevision_ = vectorSource.getRevision();\n    }\n\n    if (viewNotMoving && (extentChanged || sourceChanged)) {\n      const projection = viewState.projection;\n      const resolution = viewState.resolution;\n\n      const renderBuffer =\n        layer instanceof BaseVector ? layer.getRenderBuffer() : 0;\n      const extent = buffer(frameState.extent, renderBuffer * resolution);\n      vectorSource.loadFeatures(extent, resolution, projection);\n\n      this.rebuildBuffers_(frameState);\n      this.previousExtent_ = frameState.extent.slice();\n    }\n\n    // apply the current projection transform with the invert of the one used to fill buffers\n    this.helper.makeProjectionTransform(frameState, this.currentTransform_);\n    multiplyTransform(this.currentTransform_, this.invertRenderTransform_);\n\n    this.helper.useProgram(this.program_);\n    this.helper.prepareDraw(frameState);\n\n    // write new data\n    this.helper.bindBuffer(this.verticesBuffer_);\n    this.helper.bindBuffer(this.indicesBuffer_);\n\n    this.helper.enableAttributes(this.attributes);\n\n    return true;\n  }\n\n  /**\n   * Rebuild internal webgl buffers based on current view extent; costly, should not be called too much\n   * @param {import(\"../../PluggableMap\").FrameState} frameState Frame state.\n   * @private\n   */\n  rebuildBuffers_(frameState) {\n    // saves the projection transform for the current frame state\n    const projectionTransform = createTransform();\n    this.helper.makeProjectionTransform(frameState, projectionTransform);\n\n    // here we anticipate the amount of render instructions that we well generate\n    // this can be done since we know that for normal render we only have x, y as base instructions,\n    // and x, y, r, g, b, a and featureUid for hit render instructions\n    // and we also know the amount of custom attributes to append to these\n    const totalInstructionsCount =\n      (2 + this.customAttributes.length) * this.featureCount_;\n    if (\n      !this.renderInstructions_ ||\n      this.renderInstructions_.length !== totalInstructionsCount\n    ) {\n      this.renderInstructions_ = new Float32Array(totalInstructionsCount);\n    }\n    if (this.hitDetectionEnabled_) {\n      const totalHitInstructionsCount =\n        (7 + this.customAttributes.length) * this.featureCount_;\n      if (\n        !this.hitRenderInstructions_ ||\n        this.hitRenderInstructions_.length !== totalHitInstructionsCount\n      ) {\n        this.hitRenderInstructions_ = new Float32Array(\n          totalHitInstructionsCount\n        );\n      }\n    }\n\n    // loop on features to fill the buffer\n    let featureCache, geometry;\n    const tmpCoords = [];\n    const tmpColor = [];\n    let renderIndex = 0;\n    let hitIndex = 0;\n    let hitColor;\n    for (const featureUid in this.featureCache_) {\n      featureCache = this.featureCache_[featureUid];\n      geometry = /** @type {import(\"../../geom\").Point} */ (featureCache.geometry);\n      if (!geometry || geometry.getType() !== GeometryType.POINT) {\n        continue;\n      }\n\n      tmpCoords[0] = geometry.getFlatCoordinates()[0];\n      tmpCoords[1] = geometry.getFlatCoordinates()[1];\n      applyTransform(projectionTransform, tmpCoords);\n\n      hitColor = colorEncodeId(hitIndex + 6, tmpColor);\n\n      this.renderInstructions_[renderIndex++] = tmpCoords[0];\n      this.renderInstructions_[renderIndex++] = tmpCoords[1];\n\n      // for hit detection, the feature uid is saved in the opacity value\n      // and the index of the opacity value is encoded in the color values\n      if (this.hitDetectionEnabled_) {\n        this.hitRenderInstructions_[hitIndex++] = tmpCoords[0];\n        this.hitRenderInstructions_[hitIndex++] = tmpCoords[1];\n        this.hitRenderInstructions_[hitIndex++] = hitColor[0];\n        this.hitRenderInstructions_[hitIndex++] = hitColor[1];\n        this.hitRenderInstructions_[hitIndex++] = hitColor[2];\n        this.hitRenderInstructions_[hitIndex++] = hitColor[3];\n        this.hitRenderInstructions_[hitIndex++] = Number(featureUid);\n      }\n\n      // pushing custom attributes\n      let value;\n      for (let j = 0; j < this.customAttributes.length; j++) {\n        value = this.customAttributes[j].callback(\n          featureCache.feature,\n          featureCache.properties\n        );\n        this.renderInstructions_[renderIndex++] = value;\n        if (this.hitDetectionEnabled_) {\n          this.hitRenderInstructions_[hitIndex++] = value;\n        }\n      }\n    }\n\n    /** @type {import('./Layer').WebGLWorkerGenerateBuffersMessage} */\n    const message = {\n      type: WebGLWorkerMessageType.GENERATE_BUFFERS,\n      renderInstructions: this.renderInstructions_.buffer,\n      customAttributesCount: this.customAttributes.length,\n    };\n    // additional properties will be sent back as-is by the worker\n    message['projectionTransform'] = projectionTransform;\n    this.worker_.postMessage(message, [this.renderInstructions_.buffer]);\n    this.renderInstructions_ = null;\n\n    /** @type {import('./Layer').WebGLWorkerGenerateBuffersMessage} */\n    if (this.hitDetectionEnabled_) {\n      const hitMessage = {\n        type: WebGLWorkerMessageType.GENERATE_BUFFERS,\n        renderInstructions: this.hitRenderInstructions_.buffer,\n        customAttributesCount: 5 + this.customAttributes.length,\n      };\n      hitMessage['projectionTransform'] = projectionTransform;\n      hitMessage['hitDetection'] = true;\n      this.worker_.postMessage(hitMessage, [\n        this.hitRenderInstructions_.buffer,\n      ]);\n      this.hitRenderInstructions_ = null;\n    }\n  }\n\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    callback,\n    matches\n  ) {\n    assert(this.hitDetectionEnabled_, 66);\n    if (!this.hitRenderInstructions_) {\n      return undefined;\n    }\n\n    const pixel = applyTransform(\n      frameState.coordinateToPixelTransform,\n      coordinate.slice()\n    );\n\n    const data = this.hitRenderTarget_.readPixel(pixel[0] / 2, pixel[1] / 2);\n    const color = [data[0] / 255, data[1] / 255, data[2] / 255, data[3] / 255];\n    const index = colorDecodeId(color);\n    const opacity = this.hitRenderInstructions_[index];\n    const uid = Math.floor(opacity).toString();\n\n    const source = this.getLayer().getSource();\n    const feature = source.getFeatureByUid(uid);\n    if (feature) {\n      return callback(feature, this.getLayer(), null);\n    }\n    return undefined;\n  }\n\n  /**\n   * Render the hit detection data to the corresponding render target\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState current frame state\n   */\n  renderHitDetection(frameState) {\n    // skip render entirely if vertex buffers not ready/generated yet\n    if (!this.hitVerticesBuffer_.getSize()) {\n      return;\n    }\n\n    this.hitRenderTarget_.setSize([\n      Math.floor(frameState.size[0] / 2),\n      Math.floor(frameState.size[1] / 2),\n    ]);\n\n    this.helper.useProgram(this.hitProgram_);\n    this.helper.prepareDrawToRenderTarget(\n      frameState,\n      this.hitRenderTarget_,\n      true\n    );\n\n    this.helper.bindBuffer(this.hitVerticesBuffer_);\n    this.helper.bindBuffer(this.indicesBuffer_);\n\n    this.helper.enableAttributes(this.hitDetectionAttributes);\n\n    const renderCount = this.indicesBuffer_.getSize();\n    this.helper.drawElements(0, renderCount);\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    this.worker_.terminate();\n    this.layer_ = null;\n    this.sourceListenKeys_.forEach(function (key) {\n      unlistenByKey(key);\n    });\n    this.sourceListenKeys_ = null;\n    super.disposeInternal();\n  }\n}\n\nexport default WebGLPointsLayerRenderer;\n","/**\n * @module ol/source/VectorEventType\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  /**\n   * Triggered when a feature is added to the source.\n   * @event module:ol/source/Vector.VectorSourceEvent#addfeature\n   * @api\n   */\n  ADDFEATURE: 'addfeature',\n\n  /**\n   * Triggered when a feature is updated.\n   * @event module:ol/source/Vector.VectorSourceEvent#changefeature\n   * @api\n   */\n  CHANGEFEATURE: 'changefeature',\n\n  /**\n   * Triggered when the clear method is called on the source.\n   * @event module:ol/source/Vector.VectorSourceEvent#clear\n   * @api\n   */\n  CLEAR: 'clear',\n\n  /**\n   * Triggered when a feature is removed from the source.\n   * See {@link module:ol/source/Vector#clear source.clear()} for exceptions.\n   * @event module:ol/source/Vector.VectorSourceEvent#removefeature\n   * @api\n   */\n  REMOVEFEATURE: 'removefeature',\n\n  /**\n   * Triggered when features starts loading.\n   * @event module:ol/source/Vector.VectorSourceEvent#featuresloadstart\n   * @api\n   */\n  FEATURESLOADSTART: 'featuresloadstart',\n\n  /**\n   * Triggered when features finishes loading.\n   * @event module:ol/source/Vector.VectorSourceEvent#featuresloadend\n   * @api\n   */\n  FEATURESLOADEND: 'featuresloadend',\n\n  /**\n   * Triggered if feature loading results in an error.\n   * @event module:ol/source/Vector.VectorSourceEvent#featuresloaderror\n   * @api\n   */\n  FEATURESLOADERROR: 'featuresloaderror',\n};\n","/**\n * @module ol/webgl/Buffer\n */\nimport {ARRAY_BUFFER, ELEMENT_ARRAY_BUFFER} from '../webgl.js';\nimport {DYNAMIC_DRAW, STATIC_DRAW, STREAM_DRAW} from '../webgl.js';\nimport {assert} from '../asserts.js';\n\n/**\n * Used to describe the intended usage for the data: `STATIC_DRAW`, `STREAM_DRAW`\n * or `DYNAMIC_DRAW`.\n * @enum {number}\n */\nexport const BufferUsage = {\n  STATIC_DRAW: STATIC_DRAW,\n  STREAM_DRAW: STREAM_DRAW,\n  DYNAMIC_DRAW: DYNAMIC_DRAW,\n};\n\n/**\n * @classdesc\n * Object used to store an array of data as well as usage information for that data.\n * Stores typed arrays internally, either Float32Array or Uint16/32Array depending on\n * the buffer type (ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER) and available extensions.\n *\n * To populate the array, you can either use:\n * * A size using `#ofSize(buffer)`\n * * An `ArrayBuffer` object using `#fromArrayBuffer(buffer)`\n * * A plain array using `#fromArray(array)`\n *\n * Note:\n * See the documentation of [WebGLRenderingContext.bufferData](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData)\n * for more info on buffer usage.\n * @api\n */\nclass WebGLArrayBuffer {\n  /**\n   * @param {number} type Buffer type, either ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER.\n   * @param {number} [opt_usage] Intended usage, either `STATIC_DRAW`, `STREAM_DRAW` or `DYNAMIC_DRAW`.\n   * Default is `DYNAMIC_DRAW`.\n   */\n  constructor(type, opt_usage) {\n    /**\n     * @private\n     * @type {Float32Array|Uint32Array}\n     */\n    this.array = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.type = type;\n\n    assert(type === ARRAY_BUFFER || type === ELEMENT_ARRAY_BUFFER, 62);\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.usage = opt_usage !== undefined ? opt_usage : BufferUsage.STATIC_DRAW;\n  }\n\n  /**\n   * Populates the buffer with an array of the given size (all values will be zeroes).\n   * @param {number} size Array size\n   */\n  ofSize(size) {\n    this.array = new (getArrayClassForType(this.type))(size);\n  }\n\n  /**\n   * Populates the buffer with an array of the given size (all values will be zeroes).\n   * @param {Array<number>} array Numerical array\n   */\n  fromArray(array) {\n    this.array = getArrayClassForType(this.type).from(array);\n  }\n\n  /**\n   * Populates the buffer with a raw binary array buffer.\n   * @param {ArrayBuffer} buffer Raw binary buffer to populate the array with. Note that this buffer must have been\n   * initialized for the same typed array class.\n   */\n  fromArrayBuffer(buffer) {\n    this.array = new (getArrayClassForType(this.type))(buffer);\n  }\n\n  /**\n   * @return {number} Buffer type.\n   */\n  getType() {\n    return this.type;\n  }\n\n  /**\n   * Will return null if the buffer was not initialized\n   * @return {Float32Array|Uint32Array} Array.\n   */\n  getArray() {\n    return this.array;\n  }\n\n  /**\n   * @return {number} Usage.\n   */\n  getUsage() {\n    return this.usage;\n  }\n\n  /**\n   * Will return 0 if the buffer is not initialized\n   * @return {number} Array size\n   */\n  getSize() {\n    return this.array ? this.array.length : 0;\n  }\n}\n\n/**\n * Returns a typed array constructor based on the given buffer type\n * @param {number} type Buffer type, either ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER.\n * @return {Float32ArrayConstructor|Uint32ArrayConstructor} The typed array class to use for this buffer.\n */\nexport function getArrayClassForType(type) {\n  switch (type) {\n    case ARRAY_BUFFER:\n      return Float32Array;\n    case ELEMENT_ARRAY_BUFFER:\n      return Uint32Array;\n    default:\n      return Float32Array;\n  }\n}\n\nexport default WebGLArrayBuffer;\n","/**\n * @module ol/webgl\n */\n\n/**\n * Constants taken from goog.webgl\n */\n\n/**\n * Used by {@link module:ol/webgl/Helper~WebGLHelper} for buffers containing vertices data, such as\n * position, color, texture coordinate, etc. These vertices are then referenced by an index buffer\n * to be drawn on screen (see {@link module:ol/webgl.ELEMENT_ARRAY_BUFFER}).\n * @const\n * @type {number}\n * @api\n */\nexport const ARRAY_BUFFER = 0x8892;\n\n/**\n * Used by {@link module:ol/webgl/Helper~WebGLHelper} for buffers containing indices data.\n * Index buffers are essentially lists of references to vertices defined in a vertex buffer\n * (see {@link module:ol/webgl.ARRAY_BUFFER}), and define the primitives (triangles) to be drawn.\n * @const\n * @type {number}\n * @api\n */\nexport const ELEMENT_ARRAY_BUFFER = 0x8893;\n\n/**\n * Used by {link module:ol/webgl/Buffer~WebGLArrayBuffer}.\n * @const\n * @type {number}\n * @api\n */\nexport const STREAM_DRAW = 0x88e0;\n\n/**\n * Used by {link module:ol/webgl/Buffer~WebGLArrayBuffer}.\n * @const\n * @type {number}\n * @api\n */\nexport const STATIC_DRAW = 0x88e4;\n\n/**\n * Used by {link module:ol/webgl/Buffer~WebGLArrayBuffer}.\n * @const\n * @type {number}\n * @api\n */\nexport const DYNAMIC_DRAW = 0x88e8;\n\n/**\n * @const\n * @type {number}\n */\nexport const UNSIGNED_BYTE = 0x1401;\n\n/**\n * @const\n * @type {number}\n */\nexport const UNSIGNED_SHORT = 0x1403;\n\n/**\n * @const\n * @type {number}\n */\nexport const UNSIGNED_INT = 0x1405;\n\n/**\n * @const\n * @type {number}\n */\nexport const FLOAT = 0x1406;\n\n/** end of goog.webgl constants\n */\n\n/**\n * @const\n * @type {Array<string>}\n */\nconst CONTEXT_IDS = ['experimental-webgl', 'webgl', 'webkit-3d', 'moz-webgl'];\n\n/**\n * @param {HTMLCanvasElement} canvas Canvas.\n * @param {Object} [opt_attributes] Attributes.\n * @return {WebGLRenderingContext} WebGL rendering context.\n */\nexport function getContext(canvas, opt_attributes) {\n  const ii = CONTEXT_IDS.length;\n  for (let i = 0; i < ii; ++i) {\n    try {\n      const context = canvas.getContext(CONTEXT_IDS[i], opt_attributes);\n      if (context) {\n        return /** @type {!WebGLRenderingContext} */ (context);\n      }\n    } catch (e) {\n      // pass\n    }\n  }\n  return null;\n}\n\n/**\n * @type {Array<string>}\n */\nlet supportedExtensions;\n\n/**\n * @return {Array<string>} List of supported WebGL extensions.\n */\nexport function getSupportedExtensions() {\n  if (!supportedExtensions) {\n    const canvas = document.createElement('canvas');\n    const gl = getContext(canvas);\n    if (gl) {\n      supportedExtensions = gl.getSupportedExtensions();\n    }\n  }\n  return supportedExtensions;\n}\n","/**\n * @module ol/renderer/webgl/Layer\n */\nimport LayerRenderer from '../Layer.js';\nimport RenderEvent from '../../render/Event.js';\nimport RenderEventType from '../../render/EventType.js';\nimport WebGLHelper from '../../webgl/Helper.js';\n\n/**\n * @enum {string}\n */\nexport const WebGLWorkerMessageType = {\n  GENERATE_BUFFERS: 'GENERATE_BUFFERS',\n};\n\n/**\n * @typedef {Object} WebGLWorkerGenerateBuffersMessage\n * This message will trigger the generation of a vertex and an index buffer based on the given render instructions.\n * When the buffers are generated, the worked will send a message of the same type to the main thread, with\n * the generated buffers in it.\n * Note that any addition properties present in the message *will* be sent back to the main thread.\n * @property {WebGLWorkerMessageType} type Message type\n * @property {ArrayBuffer} renderInstructions Render instructions raw binary buffer.\n * @property {ArrayBuffer} [vertexBuffer] Vertices array raw binary buffer (sent by the worker).\n * @property {ArrayBuffer} [indexBuffer] Indices array raw binary buffer (sent by the worker).\n * @property {number} [customAttributesCount] Amount of custom attributes count in the render instructions.\n */\n\n/**\n * @typedef {Object} PostProcessesOptions\n * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than\n * the main canvas that will then be sampled up (useful for saving resource on blur steps).\n * @property {string} [vertexShader] Vertex shader source\n * @property {string} [fragmentShader] Fragment shader source\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process step\n */\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the canvas element.\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process steps\n * @property {Array<PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n\n/**\n * @classdesc\n * Base WebGL renderer class.\n * Holds all logic related to data manipulation & some common rendering logic\n * @template {import(\"../../layer/Layer.js\").default} LayerType\n */\nclass WebGLLayerRenderer extends LayerRenderer {\n  /**\n   * @param {LayerType} layer Layer.\n   * @param {Options} [opt_options] Options.\n   */\n  constructor(layer, opt_options) {\n    super(layer);\n\n    const options = opt_options || {};\n\n    /**\n     * @type {WebGLHelper}\n     * @protected\n     */\n    this.helper = new WebGLHelper({\n      postProcesses: options.postProcesses,\n      uniforms: options.uniforms,\n    });\n\n    if (options.className !== undefined) {\n      this.helper.getCanvas().className = options.className;\n    }\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    this.helper.dispose();\n    super.disposeInternal();\n  }\n\n  /**\n   * @param {import(\"../../render/EventType.js\").default} type Event type.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @private\n   */\n  dispatchRenderEvent_(type, frameState) {\n    const layer = this.getLayer();\n    if (layer.hasListener(type)) {\n      // RenderEvent does not get a context or an inversePixelTransform, because WebGL allows much less direct editing than Canvas2d does.\n      const event = new RenderEvent(type, null, frameState, null);\n      layer.dispatchEvent(event);\n    }\n  }\n\n  /**\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  preRender(frameState) {\n    this.dispatchRenderEvent_(RenderEventType.PRERENDER, frameState);\n  }\n\n  /**\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  postRender(frameState) {\n    this.dispatchRenderEvent_(RenderEventType.POSTRENDER, frameState);\n  }\n}\n\nconst tmpArray_ = [];\nconst bufferPositions_ = {vertexPosition: 0, indexPosition: 0};\n\nfunction writePointVertex(buffer, pos, x, y, index) {\n  buffer[pos + 0] = x;\n  buffer[pos + 1] = y;\n  buffer[pos + 2] = index;\n}\n\n/**\n * An object holding positions both in an index and a vertex buffer.\n * @typedef {Object} BufferPositions\n * @property {number} vertexPosition Position in the vertex buffer\n * @property {number} indexPosition Position in the index buffer\n */\n\n/**\n * Pushes a quad (two triangles) based on a point geometry\n * @param {Float32Array} instructions Array of render instructions for points.\n * @param {number} elementIndex Index from which render instructions will be read.\n * @param {Float32Array} vertexBuffer Buffer in the form of a typed array.\n * @param {Uint32Array} indexBuffer Buffer in the form of a typed array.\n * @param {number} customAttributesCount Amount of custom attributes for each element.\n * @param {BufferPositions} [bufferPositions] Buffer write positions; if not specified, positions will be set at 0.\n * @return {BufferPositions} New buffer positions where to write next\n * @property {number} vertexPosition New position in the vertex buffer where future writes should start.\n * @property {number} indexPosition New position in the index buffer where future writes should start.\n * @private\n */\nexport function writePointFeatureToBuffers(\n  instructions,\n  elementIndex,\n  vertexBuffer,\n  indexBuffer,\n  customAttributesCount,\n  bufferPositions\n) {\n  // This is for x, y and index\n  const baseVertexAttrsCount = 3;\n  const baseInstructionsCount = 2;\n  const stride = baseVertexAttrsCount + customAttributesCount;\n\n  const x = instructions[elementIndex + 0];\n  const y = instructions[elementIndex + 1];\n\n  // read custom numerical attributes on the feature\n  const customAttrs = tmpArray_;\n  customAttrs.length = customAttributesCount;\n  for (let i = 0; i < customAttrs.length; i++) {\n    customAttrs[i] = instructions[elementIndex + baseInstructionsCount + i];\n  }\n\n  let vPos = bufferPositions ? bufferPositions.vertexPosition : 0;\n  let iPos = bufferPositions ? bufferPositions.indexPosition : 0;\n  const baseIndex = vPos / stride;\n\n  // push vertices for each of the four quad corners (first standard then custom attributes)\n  writePointVertex(vertexBuffer, vPos, x, y, 0);\n  customAttrs.length &&\n    vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n\n  writePointVertex(vertexBuffer, vPos, x, y, 1);\n  customAttrs.length &&\n    vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n\n  writePointVertex(vertexBuffer, vPos, x, y, 2);\n  customAttrs.length &&\n    vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n\n  writePointVertex(vertexBuffer, vPos, x, y, 3);\n  customAttrs.length &&\n    vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n\n  indexBuffer[iPos++] = baseIndex;\n  indexBuffer[iPos++] = baseIndex + 1;\n  indexBuffer[iPos++] = baseIndex + 3;\n  indexBuffer[iPos++] = baseIndex + 1;\n  indexBuffer[iPos++] = baseIndex + 2;\n  indexBuffer[iPos++] = baseIndex + 3;\n\n  bufferPositions_.vertexPosition = vPos;\n  bufferPositions_.indexPosition = iPos;\n\n  return bufferPositions_;\n}\n\n/**\n * Returns a texture of 1x1 pixel, white\n * @private\n * @return {ImageData} Image data.\n */\nexport function getBlankImageData() {\n  const canvas = document.createElement('canvas');\n  const image = canvas.getContext('2d').createImageData(1, 1);\n  image.data[0] = 255;\n  image.data[1] = 255;\n  image.data[2] = 255;\n  image.data[3] = 255;\n  return image;\n}\n\n/**\n * Generates a color array based on a numerical id\n * Note: the range for each component is 0 to 1 with 256 steps\n * @param {number} id Id\n * @param {Array<number>} [opt_array] Reusable array\n * @return {Array<number>} Color array containing the encoded id\n */\nexport function colorEncodeId(id, opt_array) {\n  const array = opt_array || [];\n  const radix = 256;\n  const divide = radix - 1;\n  array[0] = Math.floor(id / radix / radix / radix) / divide;\n  array[1] = (Math.floor(id / radix / radix) % radix) / divide;\n  array[2] = (Math.floor(id / radix) % radix) / divide;\n  array[3] = (id % radix) / divide;\n  return array;\n}\n\n/**\n * Reads an id from a color-encoded array\n * Note: the expected range for each component is 0 to 1 with 256 steps.\n * @param {Array<number>} color Color array containing the encoded id\n * @return {number} Decoded id\n */\nexport function colorDecodeId(color) {\n  let id = 0;\n  const radix = 256;\n  const mult = radix - 1;\n  id += Math.round(color[0] * radix * radix * radix * mult);\n  id += Math.round(color[1] * radix * radix * mult);\n  id += Math.round(color[2] * radix * mult);\n  id += Math.round(color[3] * mult);\n  return id;\n}\n\nexport default WebGLLayerRenderer;\n","/**\n * @module ol/webgl/Helper\n */\nimport ContextEventType from '../webgl/ContextEventType.js';\nimport Disposable from '../Disposable.js';\nimport WebGLPostProcessingPass from './PostProcessingPass.js';\nimport {\n  FLOAT,\n  UNSIGNED_BYTE,\n  UNSIGNED_INT,\n  UNSIGNED_SHORT,\n  getContext,\n  getSupportedExtensions,\n} from '../webgl.js';\nimport {assert} from '../asserts.js';\nimport {clear} from '../obj.js';\nimport {\n  compose as composeTransform,\n  create as createTransform,\n  reset as resetTransform,\n  rotate as rotateTransform,\n  scale as scaleTransform,\n} from '../transform.js';\nimport {create, fromTransform} from '../vec/mat4.js';\nimport {getUid} from '../util.js';\nimport {includes} from '../array.js';\n\n/**\n * @typedef {Object} BufferCacheEntry\n * @property {import(\"./Buffer.js\").default} buffer Buffer.\n * @property {WebGLBuffer} webGlBuffer WebGlBuffer.\n */\n\n/**\n * Shader types, either `FRAGMENT_SHADER` or `VERTEX_SHADER`.\n * @enum {number}\n */\nexport const ShaderType = {\n  FRAGMENT_SHADER: 0x8b30,\n  VERTEX_SHADER: 0x8b31,\n};\n\n/**\n * Uniform names used in the default shaders: `PROJECTION_MATRIX`, `OFFSET_SCALE_MATRIX`.\n * and `OFFSET_ROTATION_MATRIX`.\n * @enum {string}\n */\nexport const DefaultUniform = {\n  PROJECTION_MATRIX: 'u_projectionMatrix',\n  OFFSET_SCALE_MATRIX: 'u_offsetScaleMatrix',\n  OFFSET_ROTATION_MATRIX: 'u_offsetRotateMatrix',\n  TIME: 'u_time',\n  ZOOM: 'u_zoom',\n  RESOLUTION: 'u_resolution',\n};\n\n/**\n * Attribute types, either `UNSIGNED_BYTE`, `UNSIGNED_SHORT`, `UNSIGNED_INT` or `FLOAT`\n * Note: an attribute stored in a `Float32Array` should be of type `FLOAT`.\n * @enum {number}\n */\nexport const AttributeType = {\n  UNSIGNED_BYTE: UNSIGNED_BYTE,\n  UNSIGNED_SHORT: UNSIGNED_SHORT,\n  UNSIGNED_INT: UNSIGNED_INT,\n  FLOAT: FLOAT,\n};\n\n/**\n * Description of an attribute in a buffer\n * @typedef {Object} AttributeDescription\n * @property {string} name Attribute name to use in shaders\n * @property {number} size Number of components per attributes\n * @property {AttributeType} [type] Attribute type, i.e. number of bytes used to store the value. This is\n * determined by the class of typed array which the buffer uses (eg. `Float32Array` for a `FLOAT` attribute).\n * Default is `FLOAT`.\n */\n\n/**\n * @typedef {number|Array<number>|HTMLCanvasElement|HTMLImageElement|ImageData|import(\"../transform\").Transform} UniformLiteralValue\n */\n\n/**\n * Uniform value can be a number, array of numbers (2 to 4), canvas element or a callback returning\n * one of the previous types.\n * @typedef {UniformLiteralValue|function(import(\"../PluggableMap.js\").FrameState):UniformLiteralValue} UniformValue\n */\n\n/**\n * @typedef {Object} PostProcessesOptions\n * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than\n * the main canvas which will then be sampled up (useful for saving resource on blur steps).\n * @property {string} [vertexShader] Vertex shader source\n * @property {string} [fragmentShader] Fragment shader source\n * @property {Object<string,UniformValue>} [uniforms] Uniform definitions for the post process step\n */\n\n/**\n * @typedef {Object} Options\n * @property {Object<string,UniformValue>} [uniforms] Uniform definitions; property names must match the uniform\n * names in the provided or default shaders.\n * @property {Array<PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n\n/**\n * @typedef {Object} UniformInternalDescription\n * @property {string} name Name\n * @property {UniformValue} [value] Value\n * @property {WebGLTexture} [texture] Texture\n * @private\n */\n\n/**\n * @classdesc\n * This class is intended to provide low-level functions related to WebGL rendering, so that accessing\n * directly the WebGL API should not be required anymore.\n *\n * Several operations are handled by the `WebGLHelper` class:\n *\n * ### Define custom shaders and uniforms\n *\n *   *Shaders* are low-level programs executed on the GPU and written in GLSL. There are two types of shaders:\n *\n *   Vertex shaders are used to manipulate the position and attribute of *vertices* of rendered primitives (ie. corners of a square).\n *   Outputs are:\n *\n *   * `gl_Position`: position of the vertex in screen space\n *\n *   * Varyings usually prefixed with `v_` are passed on to the fragment shader\n *\n *   Fragment shaders are used to control the actual color of the pixels drawn on screen. Their only output is `gl_FragColor`.\n *\n *   Both shaders can take *uniforms* or *attributes* as input. Attributes are explained later. Uniforms are common, read-only values that\n *   can be changed at every frame and can be of type float, arrays of float or images.\n *\n *   Shaders must be compiled and assembled into a program like so:\n *   ```js\n *   // here we simply create two shaders and assemble them in a program which is then used\n *   // for subsequent rendering calls\n *   const vertexShader = new WebGLVertex(VERTEX_SHADER);\n *   const fragmentShader = new WebGLFragment(FRAGMENT_SHADER);\n *   const program = this.context.getProgram(fragmentShader, vertexShader);\n *   helper.useProgram(this.program);\n *   ```\n *\n *   Uniforms are defined using the `uniforms` option and can either be explicit values or callbacks taking the frame state as argument.\n *   You can also change their value along the way like so:\n *   ```js\n *   helper.setUniformFloatValue('u_value', valueAsNumber);\n *   ```\n *\n * ### Defining post processing passes\n *\n *   *Post processing* describes the act of rendering primitives to a texture, and then rendering this texture to the final canvas\n *   while applying special effects in screen space.\n *   Typical uses are: blurring, color manipulation, depth of field, filtering...\n *\n *   The `WebGLHelper` class offers the possibility to define post processes at creation time using the `postProcesses` option.\n *   A post process step accepts the following options:\n *\n *   * `fragmentShader` and `vertexShader`: text literals in GLSL language that will be compiled and used in the post processing step.\n *   * `uniforms`: uniforms can be defined for the post processing steps just like for the main render.\n *   * `scaleRatio`: allows using an intermediate texture smaller or higher than the final canvas in the post processing step.\n *     This is typically used in blur steps to reduce the performance overhead by using an already downsampled texture as input.\n *\n *   The {@link module:ol/webgl/PostProcessingPass~WebGLPostProcessingPass} class is used internally, refer to its documentation for more info.\n *\n * ### Binding WebGL buffers and flushing data into them\n *\n *   Data that must be passed to the GPU has to be transferred using {@link module:ol/webgl/Buffer~WebGLArrayBuffer} objects.\n *   A buffer has to be created only once, but must be bound every time the buffer content will be used for rendering.\n *   This is done using {@link bindBuffer}.\n *   When the buffer's array content has changed, the new data has to be flushed to the GPU memory; this is done using\n *   {@link flushBufferData}. Note: this operation is expensive and should be done as infrequently as possible.\n *\n *   When binding an array buffer, a `target` parameter must be given: it should be either {@link module:ol/webgl.ARRAY_BUFFER}\n *   (if the buffer contains vertices data) or {@link module:ol/webgl.ELEMENT_ARRAY_BUFFER} (if the buffer contains indices data).\n *\n *   Examples below:\n *   ```js\n *   // at initialization phase\n *   const verticesBuffer = new WebGLArrayBuffer([], DYNAMIC_DRAW);\n *   const indicesBuffer = new WebGLArrayBuffer([], DYNAMIC_DRAW);\n *\n *   // when array values have changed\n *   helper.flushBufferData(ARRAY_BUFFER, this.verticesBuffer);\n *   helper.flushBufferData(ELEMENT_ARRAY_BUFFER, this.indicesBuffer);\n *\n *   // at rendering phase\n *   helper.bindBuffer(ARRAY_BUFFER, this.verticesBuffer);\n *   helper.bindBuffer(ELEMENT_ARRAY_BUFFER, this.indicesBuffer);\n *   ```\n *\n * ### Specifying attributes\n *\n *   The GPU only receives the data as arrays of numbers. These numbers must be handled differently depending on what it describes (position, texture coordinate...).\n *   Attributes are used to specify these uses. Use {@link enableAttributeArray_} and either\n *   the default attribute names in {@link module:ol/webgl/Helper.DefaultAttrib} or custom ones.\n *\n *   Please note that you will have to specify the type and offset of the attributes in the data array. You can refer to the documentation of [WebGLRenderingContext.vertexAttribPointer](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer) for more explanation.\n *   ```js\n *   // here we indicate that the data array has the following structure:\n *   // [posX, posY, offsetX, offsetY, texCoordU, texCoordV, posX, posY, ...]\n *   helper.enableAttributes([\n *     {\n *        name: 'a_position',\n *        size: 2\n *     },\n *     {\n *       name: 'a_offset',\n *       size: 2\n *     },\n *     {\n *       name: 'a_texCoord',\n *       size: 2\n *     }\n *   ])\n *   ```\n *\n * ### Rendering primitives\n *\n *   Once all the steps above have been achieved, rendering primitives to the screen is done using {@link prepareDraw}, {@link drawElements} and {@link finalizeDraw}.\n *   ```js\n *   // frame preparation step\n *   helper.prepareDraw(frameState);\n *\n *   // call this for every data array that has to be rendered on screen\n *   helper.drawElements(0, this.indicesBuffer.getArray().length);\n *\n *   // finalize the rendering by applying post processes\n *   helper.finalizeDraw(frameState);\n *   ```\n *\n * For an example usage of this class, refer to {@link module:ol/renderer/webgl/PointsLayer~WebGLPointsLayerRenderer}.\n *\n *\n * @api\n */\nclass WebGLHelper extends Disposable {\n  /**\n   * @param {Options} [opt_options] Options.\n   */\n  constructor(opt_options) {\n    super();\n    const options = opt_options || {};\n\n    /** @private */\n    this.boundHandleWebGLContextLost_ = this.handleWebGLContextLost.bind(this);\n\n    /** @private */\n    this.boundHandleWebGLContextRestored_ = this.handleWebGLContextRestored.bind(\n      this\n    );\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.canvas_ = document.createElement('canvas');\n    this.canvas_.style.position = 'absolute';\n    this.canvas_.style.left = '0';\n\n    /**\n     * @private\n     * @type {WebGLRenderingContext}\n     */\n    this.gl_ = getContext(this.canvas_);\n    const gl = this.getGL();\n\n    /**\n     * @private\n     * @type {!Object<string, BufferCacheEntry>}\n     */\n    this.bufferCache_ = {};\n\n    /**\n     * @private\n     * @type {WebGLProgram}\n     */\n    this.currentProgram_ = null;\n\n    assert(includes(getSupportedExtensions(), 'OES_element_index_uint'), 63);\n    gl.getExtension('OES_element_index_uint');\n\n    this.canvas_.addEventListener(\n      ContextEventType.LOST,\n      this.boundHandleWebGLContextLost_\n    );\n    this.canvas_.addEventListener(\n      ContextEventType.RESTORED,\n      this.boundHandleWebGLContextRestored_\n    );\n\n    /**\n     * @private\n     * @type {import(\"../transform.js\").Transform}\n     */\n    this.offsetRotateMatrix_ = createTransform();\n\n    /**\n     * @private\n     * @type {import(\"../transform.js\").Transform}\n     */\n    this.offsetScaleMatrix_ = createTransform();\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.tmpMat4_ = create();\n\n    /**\n     * @private\n     * @type {Object<string, WebGLUniformLocation>}\n     */\n    this.uniformLocations_ = {};\n\n    /**\n     * @private\n     * @type {Object<string, number>}\n     */\n    this.attribLocations_ = {};\n\n    /**\n     * Holds info about custom uniforms used in the post processing pass.\n     * If the uniform is a texture, the WebGL Texture object will be stored here.\n     * @type {Array<UniformInternalDescription>}\n     * @private\n     */\n    this.uniforms_ = [];\n    if (options.uniforms) {\n      for (const name in options.uniforms) {\n        this.uniforms_.push({\n          name: name,\n          value: options.uniforms[name],\n        });\n      }\n    }\n\n    /**\n     * An array of PostProcessingPass objects is kept in this variable, built from the steps provided in the\n     * options. If no post process was given, a default one is used (so as not to have to make an exception to\n     * the frame buffer logic).\n     * @type {Array<WebGLPostProcessingPass>}\n     * @private\n     */\n    this.postProcessPasses_ = options.postProcesses\n      ? options.postProcesses.map(function (options) {\n          return new WebGLPostProcessingPass({\n            webGlContext: gl,\n            scaleRatio: options.scaleRatio,\n            vertexShader: options.vertexShader,\n            fragmentShader: options.fragmentShader,\n            uniforms: options.uniforms,\n          });\n        })\n      : [new WebGLPostProcessingPass({webGlContext: gl})];\n\n    /**\n     * @type {string|null}\n     * @private\n     */\n    this.shaderCompileErrors_ = null;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.startTime_ = Date.now();\n  }\n\n  /**\n   * Just bind the buffer if it's in the cache. Otherwise create\n   * the WebGL buffer, bind it, populate it, and add an entry to\n   * the cache.\n   * @param {import(\"./Buffer\").default} buffer Buffer.\n   * @api\n   */\n  bindBuffer(buffer) {\n    const gl = this.getGL();\n    const bufferKey = getUid(buffer);\n    let bufferCache = this.bufferCache_[bufferKey];\n    if (!bufferCache) {\n      const webGlBuffer = gl.createBuffer();\n      bufferCache = {\n        buffer: buffer,\n        webGlBuffer: webGlBuffer,\n      };\n      this.bufferCache_[bufferKey] = bufferCache;\n    }\n    gl.bindBuffer(buffer.getType(), bufferCache.webGlBuffer);\n  }\n\n  /**\n   * Update the data contained in the buffer array; this is required for the\n   * new data to be rendered\n   * @param {import(\"./Buffer\").default} buffer Buffer.\n   * @api\n   */\n  flushBufferData(buffer) {\n    const gl = this.getGL();\n    this.bindBuffer(buffer);\n    gl.bufferData(buffer.getType(), buffer.getArray(), buffer.getUsage());\n  }\n\n  /**\n   * @param {import(\"./Buffer.js\").default} buf Buffer.\n   */\n  deleteBuffer(buf) {\n    const gl = this.getGL();\n    const bufferKey = getUid(buf);\n    const bufferCacheEntry = this.bufferCache_[bufferKey];\n    if (bufferCacheEntry && !gl.isContextLost()) {\n      gl.deleteBuffer(bufferCacheEntry.webGlBuffer);\n    }\n    delete this.bufferCache_[bufferKey];\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    this.canvas_.removeEventListener(\n      ContextEventType.LOST,\n      this.boundHandleWebGLContextLost_\n    );\n    this.canvas_.removeEventListener(\n      ContextEventType.RESTORED,\n      this.boundHandleWebGLContextRestored_\n    );\n  }\n\n  /**\n   * Clear the buffer & set the viewport to draw.\n   * Post process passes will be initialized here, the first one being bound as a render target for\n   * subsequent draw calls.\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState current frame state\n   * @api\n   */\n  prepareDraw(frameState) {\n    const gl = this.getGL();\n    const canvas = this.getCanvas();\n    const size = frameState.size;\n    const pixelRatio = frameState.pixelRatio;\n\n    canvas.width = size[0] * pixelRatio;\n    canvas.height = size[1] * pixelRatio;\n    canvas.style.width = size[0] + 'px';\n    canvas.style.height = size[1] + 'px';\n\n    gl.useProgram(this.currentProgram_);\n\n    // loop backwards in post processes list\n    for (let i = this.postProcessPasses_.length - 1; i >= 0; i--) {\n      this.postProcessPasses_[i].init(frameState);\n    }\n\n    gl.bindTexture(gl.TEXTURE_2D, null);\n\n    gl.clearColor(0.0, 0.0, 0.0, 0.0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    gl.enable(gl.BLEND);\n    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n\n    gl.useProgram(this.currentProgram_);\n    this.applyFrameState(frameState);\n    this.applyUniforms(frameState);\n  }\n\n  /**\n   * Clear the render target & bind it for future draw operations.\n   * This is similar to `prepareDraw`, only post processes will not be applied.\n   * Note: the whole viewport will be drawn to the render target, regardless of its size.\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState current frame state\n   * @param {import(\"./RenderTarget.js\").default} renderTarget Render target to draw to\n   * @param {boolean} [opt_disableAlphaBlend] If true, no alpha blending will happen.\n   */\n  prepareDrawToRenderTarget(frameState, renderTarget, opt_disableAlphaBlend) {\n    const gl = this.getGL();\n    const size = renderTarget.getSize();\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, renderTarget.getFramebuffer());\n    gl.viewport(0, 0, size[0], size[1]);\n    gl.bindTexture(gl.TEXTURE_2D, renderTarget.getTexture());\n    gl.clearColor(0.0, 0.0, 0.0, 0.0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    gl.enable(gl.BLEND);\n    gl.blendFunc(\n      gl.ONE,\n      opt_disableAlphaBlend ? gl.ZERO : gl.ONE_MINUS_SRC_ALPHA\n    );\n\n    gl.useProgram(this.currentProgram_);\n    this.applyFrameState(frameState);\n    this.applyUniforms(frameState);\n  }\n\n  /**\n   * Execute a draw call based on the currently bound program, texture, buffers, attributes.\n   * @param {number} start Start index.\n   * @param {number} end End index.\n   * @api\n   */\n  drawElements(start, end) {\n    const gl = this.getGL();\n    const elementType = gl.UNSIGNED_INT;\n    const elementSize = 4;\n\n    const numItems = end - start;\n    const offsetInBytes = start * elementSize;\n    gl.drawElements(gl.TRIANGLES, numItems, elementType, offsetInBytes);\n  }\n\n  /**\n   * Apply the successive post process passes which will eventually render to the actual canvas.\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState current frame state\n   * @api\n   */\n  finalizeDraw(frameState) {\n    // apply post processes using the next one as target\n    for (let i = 0; i < this.postProcessPasses_.length; i++) {\n      this.postProcessPasses_[i].apply(\n        frameState,\n        this.postProcessPasses_[i + 1] || null\n      );\n    }\n  }\n\n  /**\n   * @return {HTMLCanvasElement} Canvas.\n   * @api\n   */\n  getCanvas() {\n    return this.canvas_;\n  }\n\n  /**\n   * Get the WebGL rendering context\n   * @return {WebGLRenderingContext} The rendering context.\n   * @api\n   */\n  getGL() {\n    return this.gl_;\n  }\n\n  /**\n   * Sets the default matrix uniforms for a given frame state. This is called internally in `prepareDraw`.\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n   * @private\n   */\n  applyFrameState(frameState) {\n    const size = frameState.size;\n    const rotation = frameState.viewState.rotation;\n\n    const offsetScaleMatrix = resetTransform(this.offsetScaleMatrix_);\n    scaleTransform(offsetScaleMatrix, 2 / size[0], 2 / size[1]);\n\n    const offsetRotateMatrix = resetTransform(this.offsetRotateMatrix_);\n    if (rotation !== 0) {\n      rotateTransform(offsetRotateMatrix, -rotation);\n    }\n\n    this.setUniformMatrixValue(\n      DefaultUniform.OFFSET_SCALE_MATRIX,\n      fromTransform(this.tmpMat4_, offsetScaleMatrix)\n    );\n    this.setUniformMatrixValue(\n      DefaultUniform.OFFSET_ROTATION_MATRIX,\n      fromTransform(this.tmpMat4_, offsetRotateMatrix)\n    );\n\n    this.setUniformFloatValue(\n      DefaultUniform.TIME,\n      (Date.now() - this.startTime_) * 0.001\n    );\n    this.setUniformFloatValue(DefaultUniform.ZOOM, frameState.viewState.zoom);\n    this.setUniformFloatValue(\n      DefaultUniform.RESOLUTION,\n      frameState.viewState.resolution\n    );\n  }\n\n  /**\n   * Sets the custom uniforms based on what was given in the constructor. This is called internally in `prepareDraw`.\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n   * @private\n   */\n  applyUniforms(frameState) {\n    const gl = this.getGL();\n\n    let value;\n    let textureSlot = 0;\n    this.uniforms_.forEach(\n      function (uniform) {\n        value =\n          typeof uniform.value === 'function'\n            ? uniform.value(frameState)\n            : uniform.value;\n\n        // apply value based on type\n        if (\n          value instanceof HTMLCanvasElement ||\n          value instanceof HTMLImageElement ||\n          value instanceof ImageData\n        ) {\n          // create a texture & put data\n          if (!uniform.texture) {\n            uniform.prevValue = undefined;\n            uniform.texture = gl.createTexture();\n          }\n          gl.activeTexture(gl[`TEXTURE${textureSlot}`]);\n          gl.bindTexture(gl.TEXTURE_2D, uniform.texture);\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\n          const imageReady =\n            !(value instanceof HTMLImageElement) ||\n            /** @type {HTMLImageElement} */ (value).complete;\n          if (imageReady && uniform.prevValue !== value) {\n            uniform.prevValue = value;\n            gl.texImage2D(\n              gl.TEXTURE_2D,\n              0,\n              gl.RGBA,\n              gl.RGBA,\n              gl.UNSIGNED_BYTE,\n              value\n            );\n          }\n\n          // fill texture slots by increasing index\n          gl.uniform1i(this.getUniformLocation(uniform.name), textureSlot++);\n        } else if (Array.isArray(value) && value.length === 6) {\n          this.setUniformMatrixValue(\n            uniform.name,\n            fromTransform(this.tmpMat4_, value)\n          );\n        } else if (Array.isArray(value) && value.length <= 4) {\n          switch (value.length) {\n            case 2:\n              gl.uniform2f(\n                this.getUniformLocation(uniform.name),\n                value[0],\n                value[1]\n              );\n              return;\n            case 3:\n              gl.uniform3f(\n                this.getUniformLocation(uniform.name),\n                value[0],\n                value[1],\n                value[2]\n              );\n              return;\n            case 4:\n              gl.uniform4f(\n                this.getUniformLocation(uniform.name),\n                value[0],\n                value[1],\n                value[2],\n                value[3]\n              );\n              return;\n            default:\n              return;\n          }\n        } else if (typeof value === 'number') {\n          gl.uniform1f(this.getUniformLocation(uniform.name), value);\n        }\n      }.bind(this)\n    );\n  }\n\n  /**\n   * Use a program.  If the program is already in use, this will return `false`.\n   * @param {WebGLProgram} program Program.\n   * @return {boolean} Changed.\n   * @api\n   */\n  useProgram(program) {\n    if (program == this.currentProgram_) {\n      return false;\n    } else {\n      const gl = this.getGL();\n      gl.useProgram(program);\n      this.currentProgram_ = program;\n      this.uniformLocations_ = {};\n      this.attribLocations_ = {};\n      return true;\n    }\n  }\n\n  /**\n   * Will attempt to compile a vertex or fragment shader based on source\n   * On error, the shader will be returned but\n   * `gl.getShaderParameter(shader, gl.COMPILE_STATUS)` will return `true`\n   * Use `gl.getShaderInfoLog(shader)` to have details\n   * @param {string} source Shader source\n   * @param {ShaderType} type VERTEX_SHADER or FRAGMENT_SHADER\n   * @return {WebGLShader} Shader object\n   */\n  compileShader(source, type) {\n    const gl = this.getGL();\n    const shader = gl.createShader(type);\n    gl.shaderSource(shader, source);\n    gl.compileShader(shader);\n    return shader;\n  }\n\n  /**\n   * Create a program for a vertex and fragment shader.  Throws if shader compilation fails.\n   * @param {string} fragmentShaderSource Fragment shader source.\n   * @param {string} vertexShaderSource Vertex shader source.\n   * @return {WebGLProgram} Program\n   * @api\n   */\n  getProgram(fragmentShaderSource, vertexShaderSource) {\n    const gl = this.getGL();\n\n    const fragmentShader = this.compileShader(\n      fragmentShaderSource,\n      gl.FRAGMENT_SHADER\n    );\n\n    const vertexShader = this.compileShader(\n      vertexShaderSource,\n      gl.VERTEX_SHADER\n    );\n\n    const program = gl.createProgram();\n    gl.attachShader(program, fragmentShader);\n    gl.attachShader(program, vertexShader);\n    gl.linkProgram(program);\n\n    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\n      const message = `Fragment shader compliation failed: ${gl.getShaderInfoLog(\n        fragmentShader\n      )}`;\n      throw new Error(message);\n    }\n    gl.deleteShader(fragmentShader);\n\n    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\n      const message = `Vertex shader compilation failed: ${gl.getShaderInfoLog(\n        vertexShader\n      )}`;\n      throw new Error(message);\n    }\n    gl.deleteShader(vertexShader);\n\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n      const message = `GL program linking failed: ${gl.getShaderInfoLog(\n        vertexShader\n      )}`;\n      throw new Error(message);\n    }\n\n    return program;\n  }\n\n  /**\n   * Will get the location from the shader or the cache\n   * @param {string} name Uniform name\n   * @return {WebGLUniformLocation} uniformLocation\n   * @api\n   */\n  getUniformLocation(name) {\n    if (this.uniformLocations_[name] === undefined) {\n      this.uniformLocations_[name] = this.getGL().getUniformLocation(\n        this.currentProgram_,\n        name\n      );\n    }\n    return this.uniformLocations_[name];\n  }\n\n  /**\n   * Will get the location from the shader or the cache\n   * @param {string} name Attribute name\n   * @return {number} attribLocation\n   * @api\n   */\n  getAttributeLocation(name) {\n    if (this.attribLocations_[name] === undefined) {\n      this.attribLocations_[name] = this.getGL().getAttribLocation(\n        this.currentProgram_,\n        name\n      );\n    }\n    return this.attribLocations_[name];\n  }\n\n  /**\n   * Modifies the given transform to apply the rotation/translation/scaling of the given frame state.\n   * The resulting transform can be used to convert world space coordinates to view coordinates.\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {import(\"../transform\").Transform} transform Transform to update.\n   * @return {import(\"../transform\").Transform} The updated transform object.\n   * @api\n   */\n  makeProjectionTransform(frameState, transform) {\n    const size = frameState.size;\n    const rotation = frameState.viewState.rotation;\n    const resolution = frameState.viewState.resolution;\n    const center = frameState.viewState.center;\n\n    resetTransform(transform);\n    composeTransform(\n      transform,\n      0,\n      0,\n      2 / (resolution * size[0]),\n      2 / (resolution * size[1]),\n      -rotation,\n      -center[0],\n      -center[1]\n    );\n    return transform;\n  }\n\n  /**\n   * Give a value for a standard float uniform\n   * @param {string} uniform Uniform name\n   * @param {number} value Value\n   * @api\n   */\n  setUniformFloatValue(uniform, value) {\n    this.getGL().uniform1f(this.getUniformLocation(uniform), value);\n  }\n\n  /**\n   * Give a value for a standard matrix4 uniform\n   * @param {string} uniform Uniform name\n   * @param {Array<number>} value Matrix value\n   * @api\n   */\n  setUniformMatrixValue(uniform, value) {\n    this.getGL().uniformMatrix4fv(\n      this.getUniformLocation(uniform),\n      false,\n      value\n    );\n  }\n\n  /**\n   * Will set the currently bound buffer to an attribute of the shader program. Used by `#enableAttributes`\n   * internally.\n   * @param {string} attribName Attribute name\n   * @param {number} size Number of components per attributes\n   * @param {number} type UNSIGNED_INT, UNSIGNED_BYTE, UNSIGNED_SHORT or FLOAT\n   * @param {number} stride Stride in bytes (0 means attribs are packed)\n   * @param {number} offset Offset in bytes\n   * @private\n   */\n  enableAttributeArray_(attribName, size, type, stride, offset) {\n    const location = this.getAttributeLocation(attribName);\n    // the attribute has not been found in the shaders; do not enable it\n    if (location < 0) {\n      return;\n    }\n    this.getGL().enableVertexAttribArray(location);\n    this.getGL().vertexAttribPointer(\n      location,\n      size,\n      type,\n      false,\n      stride,\n      offset\n    );\n  }\n\n  /**\n   * Will enable the following attributes to be read from the currently bound buffer,\n   * i.e. tell the GPU where to read the different attributes in the buffer. An error in the\n   * size/type/order of attributes will most likely break the rendering and throw a WebGL exception.\n   * @param {Array<AttributeDescription>} attributes Ordered list of attributes to read from the buffer\n   * @api\n   */\n  enableAttributes(attributes) {\n    const stride = computeAttributesStride(attributes);\n    let offset = 0;\n    for (let i = 0; i < attributes.length; i++) {\n      const attr = attributes[i];\n      this.enableAttributeArray_(\n        attr.name,\n        attr.size,\n        attr.type || FLOAT,\n        stride,\n        offset\n      );\n      offset += attr.size * getByteSizeFromType(attr.type);\n    }\n  }\n\n  /**\n   * WebGL context was lost\n   * @private\n   */\n  handleWebGLContextLost() {\n    clear(this.bufferCache_);\n    this.currentProgram_ = null;\n  }\n\n  /**\n   * WebGL context was restored\n   * @private\n   */\n  handleWebGLContextRestored() {}\n\n  /**\n   * Will create or reuse a given webgl texture and apply the given size. If no image data\n   * specified, the texture will be empty, otherwise image data will be used and the `size`\n   * parameter will be ignored.\n   * Note: wrap parameters are set to clamp to edge, min filter is set to linear.\n   * @param {Array<number>} size Expected size of the texture\n   * @param {ImageData|HTMLImageElement|HTMLCanvasElement} [opt_data] Image data/object to bind to the texture\n   * @param {WebGLTexture} [opt_texture] Existing texture to reuse\n   * @return {WebGLTexture} The generated texture\n   * @api\n   */\n  createTexture(size, opt_data, opt_texture) {\n    const gl = this.getGL();\n    const texture = opt_texture || gl.createTexture();\n\n    // set params & size\n    const level = 0;\n    const internalFormat = gl.RGBA;\n    const border = 0;\n    const format = gl.RGBA;\n    const type = gl.UNSIGNED_BYTE;\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    if (opt_data) {\n      gl.texImage2D(\n        gl.TEXTURE_2D,\n        level,\n        internalFormat,\n        format,\n        type,\n        opt_data\n      );\n    } else {\n      gl.texImage2D(\n        gl.TEXTURE_2D,\n        level,\n        internalFormat,\n        size[0],\n        size[1],\n        border,\n        format,\n        type,\n        null\n      );\n    }\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\n    return texture;\n  }\n}\n\n/**\n * Compute a stride in bytes based on a list of attributes\n * @param {Array<AttributeDescription>} attributes Ordered list of attributes\n * @return {number} Stride, ie amount of values for each vertex in the vertex buffer\n * @api\n */\nexport function computeAttributesStride(attributes) {\n  let stride = 0;\n  for (let i = 0; i < attributes.length; i++) {\n    const attr = attributes[i];\n    stride += attr.size * getByteSizeFromType(attr.type);\n  }\n  return stride;\n}\n\n/**\n * Computes the size in byte of an attribute type.\n * @param {AttributeType} type Attribute type\n * @return {number} The size in bytes\n */\nfunction getByteSizeFromType(type) {\n  switch (type) {\n    case AttributeType.UNSIGNED_BYTE:\n      return Uint8Array.BYTES_PER_ELEMENT;\n    case AttributeType.UNSIGNED_SHORT:\n      return Uint16Array.BYTES_PER_ELEMENT;\n    case AttributeType.UNSIGNED_INT:\n      return Uint32Array.BYTES_PER_ELEMENT;\n    case AttributeType.FLOAT:\n    default:\n      return Float32Array.BYTES_PER_ELEMENT;\n  }\n}\n\nexport default WebGLHelper;\n","/**\n * @module ol/webgl/ContextEventType\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  LOST: 'webglcontextlost',\n  RESTORED: 'webglcontextrestored',\n};\n","/**\n * @module ol/webgl/PostProcessingPass\n */\n\nconst DEFAULT_VERTEX_SHADER = `\n  precision mediump float;\n  \n  attribute vec2 a_position;\n  varying vec2 v_texCoord;\n  varying vec2 v_screenCoord;\n  \n  uniform vec2 u_screenSize;\n   \n  void main() {\n    v_texCoord = a_position * 0.5 + 0.5;\n    v_screenCoord = v_texCoord * u_screenSize;\n    gl_Position = vec4(a_position, 0.0, 1.0);\n  }\n`;\n\nconst DEFAULT_FRAGMENT_SHADER = `\n  precision mediump float;\n   \n  uniform sampler2D u_image;\n   \n  varying vec2 v_texCoord;\n   \n  void main() {\n    gl_FragColor = texture2D(u_image, v_texCoord);\n  }\n`;\n\n/**\n * @typedef {Object} Options\n * @property {WebGLRenderingContext} webGlContext WebGL context; mandatory.\n * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than\n * the main canvas that will then be sampled up (useful for saving resource on blur steps).\n * @property {string} [vertexShader] Vertex shader source\n * @property {string} [fragmentShader] Fragment shader source\n * @property {Object<string,import(\"./Helper\").UniformValue>} [uniforms] Uniform definitions for the post process step\n */\n\n/**\n * @typedef {Object} UniformInternalDescription\n * @property {import(\"./Helper\").UniformValue} value Value\n * @property {number} location Location\n * @property {WebGLTexture} [texture] Texture\n * @private\n */\n\n/**\n * @classdesc\n * This class is used to define Post Processing passes with custom shaders and uniforms.\n * This is used internally by {@link module:ol/webgl/Helper~WebGLHelper}.\n *\n * Please note that the final output on the DOM canvas is expected to have premultiplied alpha, which means that\n * a pixel which is 100% red with an opacity of 50% must have a color of (r=0.5, g=0, b=0, a=0.5).\n * Failing to provide pixel colors with premultiplied alpha will result in render anomalies.\n *\n * The default post-processing pass does *not* multiply color values with alpha value, it expects color values to be\n * premultiplied.\n *\n * Default shaders are shown hereafter:\n *\n * * Vertex shader:\n *\n *   ```\n *   precision mediump float;\n *\n *   attribute vec2 a_position;\n *   varying vec2 v_texCoord;\n *   varying vec2 v_screenCoord;\n *\n *   uniform vec2 u_screenSize;\n *\n *   void main() {\n *     v_texCoord = a_position * 0.5 + 0.5;\n *     v_screenCoord = v_texCoord * u_screenSize;\n *     gl_Position = vec4(a_position, 0.0, 1.0);\n *   }\n *   ```\n *\n * * Fragment shader:\n *\n *   ```\n *   precision mediump float;\n *\n *   uniform sampler2D u_image;\n *\n *   varying vec2 v_texCoord;\n *\n *   void main() {\n *     gl_FragColor = texture2D(u_image, v_texCoord);\n *   }\n *   ```\n *\n * @api\n */\nclass WebGLPostProcessingPass {\n  /**\n   * @param {Options} options Options.\n   */\n  constructor(options) {\n    this.gl_ = options.webGlContext;\n    const gl = this.gl_;\n\n    this.scaleRatio_ = options.scaleRatio || 1;\n\n    this.renderTargetTexture_ = gl.createTexture();\n    this.renderTargetTextureSize_ = null;\n\n    this.frameBuffer_ = gl.createFramebuffer();\n\n    // compile the program for the frame buffer\n    // TODO: make compilation errors show up\n    const vertexShader = gl.createShader(gl.VERTEX_SHADER);\n    gl.shaderSource(\n      vertexShader,\n      options.vertexShader || DEFAULT_VERTEX_SHADER\n    );\n    gl.compileShader(vertexShader);\n    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n    gl.shaderSource(\n      fragmentShader,\n      options.fragmentShader || DEFAULT_FRAGMENT_SHADER\n    );\n    gl.compileShader(fragmentShader);\n    this.renderTargetProgram_ = gl.createProgram();\n    gl.attachShader(this.renderTargetProgram_, vertexShader);\n    gl.attachShader(this.renderTargetProgram_, fragmentShader);\n    gl.linkProgram(this.renderTargetProgram_);\n\n    // bind the vertices buffer for the frame buffer\n    this.renderTargetVerticesBuffer_ = gl.createBuffer();\n    const verticesArray = [-1, -1, 1, -1, -1, 1, 1, -1, 1, 1, -1, 1];\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.renderTargetVerticesBuffer_);\n    gl.bufferData(\n      gl.ARRAY_BUFFER,\n      new Float32Array(verticesArray),\n      gl.STATIC_DRAW\n    );\n\n    this.renderTargetAttribLocation_ = gl.getAttribLocation(\n      this.renderTargetProgram_,\n      'a_position'\n    );\n    this.renderTargetUniformLocation_ = gl.getUniformLocation(\n      this.renderTargetProgram_,\n      'u_screenSize'\n    );\n    this.renderTargetTextureLocation_ = gl.getUniformLocation(\n      this.renderTargetProgram_,\n      'u_image'\n    );\n\n    /**\n     * Holds info about custom uniforms used in the post processing pass\n     * @type {Array<UniformInternalDescription>}\n     * @private\n     */\n    this.uniforms_ = [];\n    options.uniforms &&\n      Object.keys(options.uniforms).forEach(\n        function (name) {\n          this.uniforms_.push({\n            value: options.uniforms[name],\n            location: gl.getUniformLocation(this.renderTargetProgram_, name),\n          });\n        }.bind(this)\n      );\n  }\n\n  /**\n   * Get the WebGL rendering context\n   * @return {WebGLRenderingContext} The rendering context.\n   * @api\n   */\n  getGL() {\n    return this.gl_;\n  }\n\n  /**\n   * Initialize the render target texture of the post process, make sure it is at the\n   * right size and bind it as a render target for the next draw calls.\n   * The last step to be initialized will be the one where the primitives are rendered.\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState current frame state\n   * @api\n   */\n  init(frameState) {\n    const gl = this.getGL();\n    const textureSize = [\n      gl.drawingBufferWidth * this.scaleRatio_,\n      gl.drawingBufferHeight * this.scaleRatio_,\n    ];\n\n    // rendering goes to my buffer\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this.getFrameBuffer());\n    gl.viewport(0, 0, textureSize[0], textureSize[1]);\n\n    // if size has changed: adjust canvas & render target texture\n    if (\n      !this.renderTargetTextureSize_ ||\n      this.renderTargetTextureSize_[0] !== textureSize[0] ||\n      this.renderTargetTextureSize_[1] !== textureSize[1]\n    ) {\n      this.renderTargetTextureSize_ = textureSize;\n\n      // create a new texture\n      const level = 0;\n      const internalFormat = gl.RGBA;\n      const border = 0;\n      const format = gl.RGBA;\n      const type = gl.UNSIGNED_BYTE;\n      const data = null;\n      gl.bindTexture(gl.TEXTURE_2D, this.renderTargetTexture_);\n      gl.texImage2D(\n        gl.TEXTURE_2D,\n        level,\n        internalFormat,\n        textureSize[0],\n        textureSize[1],\n        border,\n        format,\n        type,\n        data\n      );\n\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\n      // bind the texture to the framebuffer\n      gl.framebufferTexture2D(\n        gl.FRAMEBUFFER,\n        gl.COLOR_ATTACHMENT0,\n        gl.TEXTURE_2D,\n        this.renderTargetTexture_,\n        0\n      );\n    }\n  }\n\n  /**\n   * Render to the next postprocessing pass (or to the canvas if final pass).\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState current frame state\n   * @param {WebGLPostProcessingPass} [nextPass] Next pass, optional\n   * @api\n   */\n  apply(frameState, nextPass) {\n    const gl = this.getGL();\n    const size = frameState.size;\n\n    gl.bindFramebuffer(\n      gl.FRAMEBUFFER,\n      nextPass ? nextPass.getFrameBuffer() : null\n    );\n    gl.activeTexture(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_2D, this.renderTargetTexture_);\n\n    // render the frame buffer to the canvas\n    gl.clearColor(0.0, 0.0, 0.0, 0.0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    gl.enable(gl.BLEND);\n    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.renderTargetVerticesBuffer_);\n\n    gl.useProgram(this.renderTargetProgram_);\n    gl.enableVertexAttribArray(this.renderTargetAttribLocation_);\n    gl.vertexAttribPointer(\n      this.renderTargetAttribLocation_,\n      2,\n      gl.FLOAT,\n      false,\n      0,\n      0\n    );\n    gl.uniform2f(this.renderTargetUniformLocation_, size[0], size[1]);\n    gl.uniform1i(this.renderTargetTextureLocation_, 0);\n\n    this.applyUniforms(frameState);\n\n    gl.drawArrays(gl.TRIANGLES, 0, 6);\n  }\n\n  /**\n   * @return {WebGLFramebuffer} Frame buffer\n   * @api\n   */\n  getFrameBuffer() {\n    return this.frameBuffer_;\n  }\n\n  /**\n   * Sets the custom uniforms based on what was given in the constructor.\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n   * @private\n   */\n  applyUniforms(frameState) {\n    const gl = this.getGL();\n\n    let value;\n    let textureSlot = 1;\n    this.uniforms_.forEach(function (uniform) {\n      value =\n        typeof uniform.value === 'function'\n          ? uniform.value(frameState)\n          : uniform.value;\n\n      // apply value based on type\n      if (value instanceof HTMLCanvasElement || value instanceof ImageData) {\n        // create a texture & put data\n        if (!uniform.texture) {\n          uniform.texture = gl.createTexture();\n        }\n        gl.activeTexture(gl[`TEXTURE${textureSlot}`]);\n        gl.bindTexture(gl.TEXTURE_2D, uniform.texture);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\n        if (value instanceof ImageData) {\n          gl.texImage2D(\n            gl.TEXTURE_2D,\n            0,\n            gl.RGBA,\n            gl.RGBA,\n            value.width,\n            value.height,\n            0,\n            gl.UNSIGNED_BYTE,\n            new Uint8Array(value.data)\n          );\n        } else {\n          gl.texImage2D(\n            gl.TEXTURE_2D,\n            0,\n            gl.RGBA,\n            gl.RGBA,\n            gl.UNSIGNED_BYTE,\n            value\n          );\n        }\n\n        // fill texture slots\n        gl.uniform1i(uniform.location, textureSlot++);\n      } else if (Array.isArray(value)) {\n        switch (value.length) {\n          case 2:\n            gl.uniform2f(uniform.location, value[0], value[1]);\n            return;\n          case 3:\n            gl.uniform3f(uniform.location, value[0], value[1], value[2]);\n            return;\n          case 4:\n            gl.uniform4f(\n              uniform.location,\n              value[0],\n              value[1],\n              value[2],\n              value[3]\n            );\n            return;\n          default:\n            return;\n        }\n      } else if (typeof value === 'number') {\n        gl.uniform1f(uniform.location, value);\n      }\n    });\n  }\n}\n\nexport default WebGLPostProcessingPass;\n","/**\n * @module ol/vec/mat4\n */\n\n/**\n * @return {Array<number>} \"4x4 matrix representing a 3D identity transform.\"\n */\nexport function create() {\n  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n}\n\n/**\n * @param {Array<number>} mat4 Flattened 4x4 matrix receiving the result.\n * @param {import(\"../transform.js\").Transform} transform Transformation matrix.\n * @return {Array<number>} \"2D transformation matrix as flattened 4x4 matrix.\"\n */\nexport function fromTransform(mat4, transform) {\n  mat4[0] = transform[0];\n  mat4[1] = transform[1];\n  mat4[4] = transform[2];\n  mat4[5] = transform[3];\n  mat4[12] = transform[4];\n  mat4[13] = transform[5];\n  return mat4;\n}\n","/**\n * A wrapper class to simplify rendering to a texture instead of the final canvas\n * @module ol/webgl/RenderTarget\n */\nimport {equals} from '../array.js';\n\n// for pixel color reading\nconst tmpArray4 = new Uint8Array(4);\n\n/**\n * @classdesc\n * This class is a wrapper around the association of both a `WebGLTexture` and a `WebGLFramebuffer` instances,\n * simplifying initialization and binding for rendering.\n * @api\n */\nclass WebGLRenderTarget {\n  /**\n   * @param {import(\"./Helper.js\").default} helper WebGL helper; mandatory.\n   * @param {Array<number>} [opt_size] Expected size of the render target texture; note: this can be changed later on.\n   */\n  constructor(helper, opt_size) {\n    /**\n     * @private\n     * @type {import(\"./Helper.js\").default}\n     */\n    this.helper_ = helper;\n    const gl = helper.getGL();\n\n    /**\n     * @private\n     * @type {WebGLTexture}\n     */\n    this.texture_ = gl.createTexture();\n\n    /**\n     * @private\n     * @type {WebGLFramebuffer}\n     */\n    this.framebuffer_ = gl.createFramebuffer();\n\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n    this.size_ = opt_size || [1, 1];\n\n    /**\n     * @type {Uint8Array}\n     * @private\n     */\n    this.data_ = new Uint8Array(0);\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.dataCacheDirty_ = true;\n\n    this.updateSize_();\n  }\n\n  /**\n   * Changes the size of the render target texture. Note: will do nothing if the size\n   * is already the same.\n   * @param {Array<number>} size Expected size of the render target texture\n   * @api\n   */\n  setSize(size) {\n    if (equals(size, this.size_)) {\n      return;\n    }\n    this.size_[0] = size[0];\n    this.size_[1] = size[1];\n    this.updateSize_();\n  }\n\n  /**\n   * Returns the size of the render target texture\n   * @return {Array<number>} Size of the render target texture\n   * @api\n   */\n  getSize() {\n    return this.size_;\n  }\n\n  /**\n   * This will cause following calls to `#readAll` or `#readPixel` to download the content of the\n   * render target into memory, which is an expensive operation.\n   * This content will be kept in cache but should be cleared after each new render.\n   * @api\n   */\n  clearCachedData() {\n    this.dataCacheDirty_ = true;\n  }\n\n  /**\n   * Returns the full content of the frame buffer as a series of r, g, b, a components\n   * in the 0-255 range (unsigned byte).\n   * @return {Uint8Array} Integer array of color values\n   * @api\n   */\n  readAll() {\n    if (this.dataCacheDirty_) {\n      const size = this.size_;\n      const gl = this.helper_.getGL();\n\n      gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer_);\n      gl.readPixels(\n        0,\n        0,\n        size[0],\n        size[1],\n        gl.RGBA,\n        gl.UNSIGNED_BYTE,\n        this.data_\n      );\n      this.dataCacheDirty_ = false;\n    }\n    return this.data_;\n  }\n\n  /**\n   * Reads one pixel of the frame buffer as an array of r, g, b, a components\n   * in the 0-255 range (unsigned byte).\n   * If x and/or y are outside of existing data, an array filled with 0 is returned.\n   * @param {number} x Pixel coordinate\n   * @param {number} y Pixel coordinate\n   * @return {Uint8Array} Integer array with one color value (4 components)\n   * @api\n   */\n  readPixel(x, y) {\n    if (x < 0 || y < 0 || x > this.size_[0] || y >= this.size_[1]) {\n      tmpArray4[0] = 0;\n      tmpArray4[1] = 0;\n      tmpArray4[2] = 0;\n      tmpArray4[3] = 0;\n      return tmpArray4;\n    }\n\n    this.readAll();\n    const index =\n      Math.floor(x) + (this.size_[1] - Math.floor(y) - 1) * this.size_[0];\n    tmpArray4[0] = this.data_[index * 4];\n    tmpArray4[1] = this.data_[index * 4 + 1];\n    tmpArray4[2] = this.data_[index * 4 + 2];\n    tmpArray4[3] = this.data_[index * 4 + 3];\n    return tmpArray4;\n  }\n\n  /**\n   * @return {WebGLTexture} Texture to render to\n   */\n  getTexture() {\n    return this.texture_;\n  }\n\n  /**\n   * @return {WebGLFramebuffer} Frame buffer of the render target\n   */\n  getFramebuffer() {\n    return this.framebuffer_;\n  }\n\n  /**\n   * @private\n   */\n  updateSize_() {\n    const size = this.size_;\n    const gl = this.helper_.getGL();\n\n    this.texture_ = this.helper_.createTexture(size, null, this.texture_);\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer_);\n    gl.viewport(0, 0, size[0], size[1]);\n    gl.framebufferTexture2D(\n      gl.FRAMEBUFFER,\n      gl.COLOR_ATTACHMENT0,\n      gl.TEXTURE_2D,\n      this.texture_,\n      0\n    );\n\n    this.data_ = new Uint8Array(size[0] * size[1] * 4);\n  }\n}\n\nexport default WebGLRenderTarget;\n","\n        const source = \"var e=\\\"function\\\"==typeof Object.assign?Object.assign:function(e,n){if(null==e)throw new TypeError(\\\"Cannot convert undefined or null to object\\\");for(var t=Object(e),r=1,o=arguments.length;r<o;++r){var i=arguments[r];if(null!=i)for(var f in i)i.hasOwnProperty(f)&&(t[f]=i[f])}return t},n=\\\"GENERATE_BUFFERS\\\",t=[],r={vertexPosition:0,indexPosition:0};function o(e,n,t,r,o){e[n+0]=t,e[n+1]=r,e[n+2]=o}function i(e,n,i,f,s,u){var a=3+s,l=e[n+0],v=e[n+1],c=t;c.length=s;for(var g=0;g<c.length;g++)c[g]=e[n+2+g];var b=u?u.vertexPosition:0,h=u?u.indexPosition:0,d=b/a;return o(i,b,l,v,0),c.length&&i.set(c,b+3),o(i,b+=a,l,v,1),c.length&&i.set(c,b+3),o(i,b+=a,l,v,2),c.length&&i.set(c,b+3),o(i,b+=a,l,v,3),c.length&&i.set(c,b+3),b+=a,f[h++]=d,f[h++]=d+1,f[h++]=d+3,f[h++]=d+1,f[h++]=d+2,f[h++]=d+3,r.vertexPosition=b,r.indexPosition=h,r}var f=self;f.onmessage=function(t){var r=t.data;if(r.type===n){for(var o=r.customAttributesCount,s=2+o,u=new Float32Array(r.renderInstructions),a=u.length/s,l=4*a*(o+3),v=new Uint32Array(6*a),c=new Float32Array(l),g=null,b=0;b<u.length;b+=s)g=i(u,b,c,v,o,g);var h=e({vertexBuffer:c.buffer,indexBuffer:v.buffer,renderInstructions:u.buffer},r);f.postMessage(h,[c.buffer,v.buffer,u.buffer])}};\";\n        const blob = new Blob([source], {type: 'application/javascript'});\n        const url = URL.createObjectURL(blob);\n        export function create() {\n          return new Worker(url);\n        }\n      \n"],"names":["$4e846b5067287bfa27b20cce73a80019$var$Property","$4e846b5067287bfa27b20cce73a80019$var$DEFAULT_GRADIENT","$4e846b5067287bfa27b20cce73a80019$export$9099ad97b570f7c","_super","Heatmap","opt_options","_this","this","options","baseOptions","$6RQ94","assign","gradient","radius","blur","weight","call","gradient_","addEventListener","$4ZHam","getChangeEventType","handleGradientChanged_","setGradient","setBlur","undefined","setRadius","weightFunction_","feature","get","setRenderOrder","$4e846b5067287bfa27b20cce73a80019$var$__extends","prototype","getBlur","getGradient","getRadius","colors","width","height","context","$4eVqD","createCanvasContext2D","createLinearGradient","step","length","i","ii","addColorStop","fillStyle","fillRect","canvas","$4e846b5067287bfa27b20cce73a80019$var$createGradient","set","createRenderer","$4Baa8","default","className","getClassName","attributes","name","callback","$4qq0p","clamp","bind","vertexShader","fragmentShader","hitVertexShader","hitFragmentShader","uniforms","u_size","u_blurSlope","Math","max","postProcesses","u_gradientTexture","renderDeclutter","$1rnY9","$971f56de0b1cde93924292a879dc7bb9$export$9099ad97b570f7c","WebGLPointsLayerRenderer","layer","projectionMatrixTransform","$5ljS4","create","$4VPJp","DefaultUniform","PROJECTION_MATRIX","sourceRevision_","verticesBuffer_","$5htZK","$30fvD","ARRAY_BUFFER","DYNAMIC_DRAW","hitVerticesBuffer_","indicesBuffer_","ELEMENT_ARRAY_BUFFER","program_","helper","getProgram","hitDetectionEnabled_","hitProgram_","customAttributes","map","attribute","size","type","AttributeType","FLOAT","concat","hitDetectionAttributes","previousExtent_","$4lmw7","createEmpty","currentTransform_","renderTransform_","invertRenderTransform_","renderInstructions_","Float32Array","hitRenderInstructions_","hitRenderTarget_","$7uMvR","worker_","$4MIn8","event","received","data","$2vgO4","WebGLWorkerMessageType","GENERATE_BUFFERS","projectionTransform","hitDetection","fromArrayBuffer","vertexBuffer","flushBufferData","indexBuffer","makeInverse","renderInstructions","getLayer","changed","featureCache_","featureCount_","source","getSource","sourceListenKeys_","$3H2uZ","listen","$2irPz","ADDFEATURE","handleSourceFeatureAdded_","CHANGEFEATURE","handleSourceFeatureChanged_","REMOVEFEATURE","handleSourceFeatureDelete_","CLEAR","handleSourceFeatureClear_","forEachFeature","$6fegY","getUid","properties","getProperties","geometry","getGeometry","$971f56de0b1cde93924292a879dc7bb9$var$__extends","renderFrame","frameState","preRender","renderCount","getSize","drawElements","finalizeDraw","getCanvas","opacity","layerStatesArray","layerIndex","parseFloat","style","String","renderHitDetection","clearCachedData","postRender","prepareFrame","vectorSource","viewState","viewNotMoving","viewHints","$3dwRD","ANIMATING","INTERACTING","extentChanged","equals","extent","sourceChanged","getRevision","projection","resolution","renderBuffer","$6isWD","getRenderBuffer","buffer","loadFeatures","rebuildBuffers_","slice","makeProjectionTransform","multiply","useProgram","prepareDraw","bindBuffer","enableAttributes","featureCache","totalInstructionsCount","totalHitInstructionsCount","hitColor","tmpCoords","tmpColor","renderIndex","hitIndex","featureUid","getType","$1gVIf","POINT","getFlatCoordinates","apply","colorEncodeId","Number","value","j","message","customAttributesCount","postMessage","hitMessage","forEachFeatureAtCoordinate","coordinate","hitTolerance","matches","$1mHUI","assert","pixel","coordinateToPixelTransform","readPixel","color","index","colorDecodeId","uid","floor","toString","getFeatureByUid","setSize","prepareDrawToRenderTarget","disposeInternal","terminate","layer_","forEach","key","unlistenByKey","$4b7d9e079415657c49d05e16783d2ed4$export$9099ad97b570f7c","FEATURESLOADSTART","FEATURESLOADEND","FEATURESLOADERROR","$02cc97bf01bb3e29729e4a43136299b6$export$ad4b78097bf94d85","STATIC_DRAW","STREAM_DRAW","$02cc97bf01bb3e29729e4a43136299b6$export$2ced8f41c55fa306","Uint32Array","$02cc97bf01bb3e29729e4a43136299b6$export$9099ad97b570f7c","WebGLArrayBuffer","opt_usage","array","usage","ofSize","fromArray","from","getArray","getUsage","$62b4010d0c10d05a6eb5fbcd9e877cb9$var$supportedExtensions","$62b4010d0c10d05a6eb5fbcd9e877cb9$export$4fae3d8ec3d62e0a","$62b4010d0c10d05a6eb5fbcd9e877cb9$export$1115845160c9bee9","$62b4010d0c10d05a6eb5fbcd9e877cb9$export$c40403109a8fdba1","$62b4010d0c10d05a6eb5fbcd9e877cb9$export$da1b14f6e17f1dec","$62b4010d0c10d05a6eb5fbcd9e877cb9$export$909515d02f210383","$62b4010d0c10d05a6eb5fbcd9e877cb9$export$8b99e5b1739c5dc3","$62b4010d0c10d05a6eb5fbcd9e877cb9$export$7b00a30a72fee650","$62b4010d0c10d05a6eb5fbcd9e877cb9$export$d14b3e4f0f91cd95","$62b4010d0c10d05a6eb5fbcd9e877cb9$export$b1f02ad1d77b2216","$62b4010d0c10d05a6eb5fbcd9e877cb9$var$CONTEXT_IDS","$62b4010d0c10d05a6eb5fbcd9e877cb9$export$1c9dfb92a34f1fcf","opt_attributes","getContext","e","$62b4010d0c10d05a6eb5fbcd9e877cb9$export$8185dc2b04913cae","gl","document","createElement","getSupportedExtensions","$52492a5d5a5cf9f2155f89c2c989fa4d$export$f35e0f0520ed8c07","$52492a5d5a5cf9f2155f89c2c989fa4d$var$WebGLLayerRenderer","WebGLLayerRenderer","$52492a5d5a5cf9f2155f89c2c989fa4d$var$__extends","dispose","dispatchRenderEvent_","hasListener","event_1","$OadRJ","dispatchEvent","$4uxJu","PRERENDER","POSTRENDER","$5iuGx","$52492a5d5a5cf9f2155f89c2c989fa4d$var$tmpArray_","$52492a5d5a5cf9f2155f89c2c989fa4d$var$bufferPositions_","vertexPosition","indexPosition","$52492a5d5a5cf9f2155f89c2c989fa4d$var$writePointVertex","pos","x","y","$52492a5d5a5cf9f2155f89c2c989fa4d$export$402a9517d8d9fb90","instructions","elementIndex","bufferPositions","stride","customAttrs","vPos","iPos","baseIndex","$52492a5d5a5cf9f2155f89c2c989fa4d$export$d2530fde2918c51d","image","createImageData","$52492a5d5a5cf9f2155f89c2c989fa4d$export$89728eb3e9a820de","id","opt_array","radix","divide","$52492a5d5a5cf9f2155f89c2c989fa4d$export$4a313f27a0e30974","mult","round","$52492a5d5a5cf9f2155f89c2c989fa4d$export$9099ad97b570f7c","$a213a3ce88096e82b8501ef33f381740$export$9fb8f3e6fc336132","FRAGMENT_SHADER","VERTEX_SHADER","$a213a3ce88096e82b8501ef33f381740$export$9aeec108beb7c801","OFFSET_SCALE_MATRIX","OFFSET_ROTATION_MATRIX","TIME","ZOOM","RESOLUTION","$a213a3ce88096e82b8501ef33f381740$export$a267a1a615d1668f","UNSIGNED_BYTE","UNSIGNED_SHORT","UNSIGNED_INT","$a213a3ce88096e82b8501ef33f381740$export$9f69b31ae6f7009b","attr","$a213a3ce88096e82b8501ef33f381740$var$getByteSizeFromType","Uint8Array","BYTES_PER_ELEMENT","Uint16Array","$a213a3ce88096e82b8501ef33f381740$export$9099ad97b570f7c","WebGLHelper","boundHandleWebGLContextLost_","handleWebGLContextLost","boundHandleWebGLContextRestored_","handleWebGLContextRestored","canvas_","position","left","gl_","getGL","bufferCache_","currentProgram_","$3MevS","includes","getExtension","$2raQ4","LOST","RESTORED","offsetRotateMatrix_","offsetScaleMatrix_","tmpMat4_","$5D0K3","uniformLocations_","attribLocations_","uniforms_","name_1","push","postProcessPasses_","options1","$foGAP","webGlContext","scaleRatio","shaderCompileErrors_","startTime_","Date","now","$a213a3ce88096e82b8501ef33f381740$var$__extends","bufferKey","bufferCache","webGlBuffer","createBuffer","bufferData","deleteBuffer","buf","bufferCacheEntry","isContextLost","removeEventListener","pixelRatio","init","bindTexture","TEXTURE_2D","clearColor","clear","COLOR_BUFFER_BIT","enable","BLEND","blendFunc","ONE","ONE_MINUS_SRC_ALPHA","applyFrameState","applyUniforms","renderTarget","opt_disableAlphaBlend","bindFramebuffer","FRAMEBUFFER","getFramebuffer","viewport","getTexture","ZERO","start","end","elementType","numItems","offsetInBytes","TRIANGLES","rotation","offsetScaleMatrix","reset","scale","offsetRotateMatrix","rotate","setUniformMatrixValue","fromTransform","setUniformFloatValue","zoom","textureSlot","uniform","HTMLCanvasElement","HTMLImageElement","ImageData","texture","prevValue","createTexture","activeTexture","texParameteri","TEXTURE_MIN_FILTER","LINEAR","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","complete","texImage2D","RGBA","uniform1i","getUniformLocation","Array","isArray","uniform2f","uniform3f","uniform4f","uniform1f","program","compileShader","shader","createShader","shaderSource","fragmentShaderSource","vertexShaderSource","createProgram","attachShader","linkProgram","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","Error","deleteShader","getProgramParameter","LINK_STATUS","getAttributeLocation","getAttribLocation","transform","center","compose","uniformMatrix4fv","enableAttributeArray_","attribName","offset","location","enableVertexAttribArray","vertexAttribPointer","opt_data","opt_texture","internalFormat","format","$7xsVg","$501d706d50d79bf1747fa2e06c13b468$export$9099ad97b570f7c","$082906594eab2940979815ab9b245f21$export$9099ad97b570f7c","WebGLPostProcessingPass","scaleRatio_","renderTargetTexture_","renderTargetTextureSize_","frameBuffer_","createFramebuffer","renderTargetProgram_","renderTargetVerticesBuffer_","renderTargetAttribLocation_","renderTargetUniformLocation_","renderTargetTextureLocation_","Object","keys","textureSize","drawingBufferWidth","drawingBufferHeight","getFrameBuffer","framebufferTexture2D","COLOR_ATTACHMENT0","nextPass","TEXTURE0","drawArrays","$b8f56a2658bfbbbe58c154ca943f14e7$export$83abccee78a744ce","$b8f56a2658bfbbbe58c154ca943f14e7$export$e2085a48d9d846ba","mat4","$f64fa72ac4564efa0d58e5ad5fee1414$var$tmpArray4","$f64fa72ac4564efa0d58e5ad5fee1414$export$9099ad97b570f7c","WebGLRenderTarget","opt_size","helper_","texture_","framebuffer_","size_","data_","dataCacheDirty_","updateSize_","readAll","readPixels","$9d3e887f16ae055cd8da2de24c5566f6$var$blob","Blob","$9d3e887f16ae055cd8da2de24c5566f6$var$url","URL","createObjectURL","$9d3e887f16ae055cd8da2de24c5566f6$export$83abccee78a744ce","Worker"],"version":3,"file":"extent-constrained.af3f9307.js.map"}